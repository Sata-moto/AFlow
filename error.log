2025-10-09 14:56:50 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-09 14:56:50 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 14:56:50 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 14:56:50 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 14:56:51 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 14:56:51 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 14:56:51 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 14:56:51 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 14:56:51 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 14:56:51 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-09 14:56:51 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 14:56:52 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-09 14:56:52 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 14:56:52 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 14:56:52 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-09 14:56:52 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-09 14:56:52 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 14:56:52 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 14:56:52 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 14:56:53 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 14:56:53 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 14:56:53 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 14:56:53 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-09 14:56:54 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 14:57:25 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 14:57:26 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items if len(max_items) > 1 else max_items[0].
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-09 14:57:30 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 14:57:31 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 14:57:32 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 14:57:34 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-09 14:57:34 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 14:57:35 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 14:57:35 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 14:57:35 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 14:57:36 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 14:57:37 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 14:57:38 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 14:57:42 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 14:57:46 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    top_area = math.pi * r ** 2
    total_area = lateral_area + 2 * top_area
    return total_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 14:57:54 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 14:59:00 - Error: Tuple must contain at least two elements..
 Solution: def multiply_elements(numbers_tuple):
    if not isinstance(numbers_tuple, tuple):
        raise ValueError('Input must be a tuple.')
    if len(numbers_tuple) < 2:
        raise ValueError('Tuple must contain at least two elements.')
    return tuple((numbers_tuple[i] * numbers_tuple[i + 1] for i in range(len(numbers_tuple) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-09 14:59:00 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    if not str1:
        return str1
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 14:59:06 - Error: .
 Solution: def list_difference(li1, li2):
    return list(set(li1) - set(li2))
def Diff(li1, li2):
    return list_difference(li1, li2).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 14:59:20 - Error: .
 Solution: def jacobsthal_num(index: int) -> int:
    if not isinstance(index, int):
        raise TypeError('Index must be an integer.')
    if index < 0:
        raise ValueError('Index must be a non-negative integer.')
    elif index == 0:
        return 0
    elif index == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, index + 1):
        current = prev2 + 2 * prev1
        prev2 = prev1
        prev1 = current
    return prev1.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 14:59:21 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return text_match_one_or_more(text)
def text_match_one_or_more(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 14:59:23 - Error: .
 Solution: def average_tuple(tuples_of_numbers):
    if not isinstance(tuples_of_numbers, tuple) or not all((isinstance(t, tuple) for t in tuples_of_numbers)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in tuples_of_numbers:
        if len(t) == 0:
            averages.append(None)
        else:
            try:
                avg = sum(t) / len(t)
                averages.append(avg)
            except TypeError:
                raise ValueError('All elements in the tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 14:59:24 - Error: .
 Solution: def check_answer(number):
    if number < 0:
        return False
    reverse_number = int(str(number)[::-1])
    return number == 2 * reverse_number + 1.
 Test: def check():
    assert check_answer(70) == False
    assert check_answer(23) == False
    assert check_answer(73) == True

2025-10-09 14:59:25 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    return 1 + 3 * (n * (n - 1)) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 14:59:32 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The total surface area of the cylinder.

    Raises:
    ValueError: If radius or height is negative.
    TypeError: If radius or height is not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    top_area = math.pi * r ** 2
    bottom_area = math.pi * r ** 2
    total_surface_area = lateral_area + top_area + bottom_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 14:59:39 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 14:59:41 - Error: .
 Solution: def snake_to_camel(snake_case_string):
    if not snake_case_string:
        return ''
    parts = snake_case_string.split('_')
    if len(parts) == 1:
        return snake_case_string
    camel_case_string = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case_string.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 14:59:46 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 14:59:46 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (left, right) = (0, len(arr) - 1)
    if arr[left] <= arr[right]:
        return 0
    while left <= right:
        mid = (left + right) // 2
        next_index = (mid + 1) % len(arr)
        prev_index = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 14:59:52 - Error: .
 Solution: def find_sum(arr):
    """
    Calculate the sum of non-repeated elements in the given list.

    Parameters:
    arr (list): A list of integers.

    Returns:
    int: The sum of non-repeated elements. Returns 0 if the list is empty or contains no valid integers.
    """
    if not arr:
        return 0
    from collections import Counter
    filtered_arr = [num for num in arr if isinstance(num, int)]
    if not filtered_arr:
        return 0
    element_count = Counter(filtered_arr)
    return sum((num for (num, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 14:59:54 - Error: .
 Solution: def max_product_tuple(tuple_list):
    if len(tuple_list) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(tuple_list)):
        for j in range(i + 1, len(tuple_list)):
            if len(tuple_list[i]) < 2 or len(tuple_list[j]) < 2:
                continue
            product1 = tuple_list[i][0] * tuple_list[j][1]
            product2 = tuple_list[i][1] * tuple_list[j][0]
            max_product = max(max_product, abs(product1), abs(product2))
    return max_product if max_product != float('-inf') else None.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:00:00 - Error: Both real_part and imaginary_part must be numbers..
 Solution: import cmath
def angle_complex(real_part, imaginary_part):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    real_part (float or int): The real part of the complex number.
    imaginary_part (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.

    Raises:
    ValueError: If the complex number is zero or if the inputs are not numbers.
    """
    if not isinstance(real_part, (int, float)) or not isinstance(imaginary_part, (int, float)):
        raise ValueError('Both real_part and imaginary_part must be numbers.')
    complex_number = complex(real_part, imaginary_part)
    if complex_number == 0:
        raise ValueError('The angle is undefined for the zero complex number.')
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:00:22 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                A[i][j] = (j + 1) * A[i - 1][j]
            elif j == i:
                A[i][j] = 1
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:02:39 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:02:41 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    if len(parts) == 1:
        return word
    camel_case_string = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case_string.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:02:41 - Error: .
 Solution: def find_even_numbers(numbers):
    if not isinstance(numbers, list):
        raise ValueError('Input must be a list.')
    even_numbers = [num for num in numbers if isinstance(num, int) and num % 2 == 0]
    return even_numbers
def Split(list):
    sample_list = list
    even_numbers = find_even_numbers(sample_list)
    print(even_numbers).
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-09 15:02:45 - Error: .
 Solution: def test_three_equal(x, y, z):
    if not all((isinstance(i, int) for i in (x, y, z))):
        return -1
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:03:01 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:03:03 - Error: .
 Solution: def find_star_num(n):
    """
    Calculate the nth star number.
    
    A star number is defined as:
    S(n) = n * (2n - 1)
    
    Parameters:
    n (int): The index of the star number to calculate. Must be a positive integer.
    
    Returns:
    int: The nth star number, or raises a ValueError for invalid input.
    """
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:03:03 - Error: .
 Solution: from collections import Counter
def find_sum(arr):
    if not arr:
        return 0
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1 and isinstance(key, (int, float)))).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:03:04 - Error: .
 Solution: def jacobsthal_num(n):
    """
    Calculate the nth Jacobsthal number.

    Parameters:
    n (int): The index of the Jacobsthal number to compute (non-negative integer).

    Returns:
    int: The nth Jacobsthal number.
    """
    if n < 0:
        raise ValueError('Index must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    jacobsthal = [0] * (n + 1)
    jacobsthal[0] = 0
    jacobsthal[1] = 1
    for i in range(2, n + 1):
        jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
    return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 15:03:04 - Error: Both a and b must be numeric values..
 Solution: import cmath
def angle_complex(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise ValueError('Both a and b must be numeric values.')
    complex_number = complex(a, b)
    if complex_number == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:03:04 - Error: .
 Solution: def check_answer(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer')
    reverse_n = int(str(n)[::-1])
    return n == 2 * reverse_n + 1.
 Test: def check():
    assert check_answer(70) == False
    assert check_answer(23) == False
    assert check_answer(73) == True

2025-10-09 15:03:05 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        return 0
    try:
        total_sum = sum((round(num) for num in list1))
    except TypeError:
        raise ValueError('All elements in the list must be numeric.')
    return total_sum.
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-09 15:03:06 - Error: .
 Solution: def diff_square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1
def dif_Square(n):
    return diff_square(n).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:03:08 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            if len(list1[i]) < 2 or len(list1[j]) < 2:
                continue
            try:
                product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
                max_product = max(max_product, product)
            except TypeError:
                continue
    return max_product if max_product != float('-inf') else None.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:03:19 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if not t:
            averages.append(None)
        else:
            try:
                avg = sum(t) / len(t)
                averages.append(avg)
            except TypeError:
                raise ValueError('All elements in the inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:03:22 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    if n == 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:03:29 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The total surface area of the cylinder.

    Raises:
    ValueError: If radius or height is negative.
    TypeError: If radius or height is not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:03:30 - Error: float division by zero.
 Solution: def rgb_to_hsv(r, g, b):
    """
    Convert RGB color to HSV color.

    Parameters:
    r (int): Red value (0-255)
    g (int): Green value (0-255)
    b (int): Blue value (0-255)

    Returns:
    tuple: A tuple containing (hue, saturation, value) where:
           - hue is in the range [0, 360)
           - saturation and value are in the range [0, 1]
    """
    if not all((isinstance(x, int) for x in (r, g, b))):
        raise TypeError('RGB values must be integers')
    if not all((0 <= x <= 255 for x in (r, g, b))):
        raise ValueError('RGB values must be in the range 0-255')
    (r, g, b) = (r / 255.0, g / 255.0, b / 255.0)
    mx = max(r, g, b)
    mn = min(r, g, b)
    df = mx - mn
    if mx == 0:
        h = s = 0
    else:
        s = df / mx
        if mx == r:
            h = (60 * ((g - b) / df) + 360) % 360
        elif mx == g:
            h = (60 * ((b - r) / df) + 120) % 360
        else:
            h = (60 * ((r - g) / df) + 240) % 360
    v = mx
    return (h, s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-09 15:03:40 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:03:40 - Error: .
 Solution: def count_rotation(arr):
    """
    Count the number of rotations required to generate a sorted array.
    
    Parameters:
    arr (List[int]): A rotated sorted array of integers.
    
    Returns:
    int: The number of rotations.
    
    Raises:
    ValueError: If the input array is empty.
    """
    if not arr:
        raise ValueError('Input array cannot be empty')
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low < high:
        mid = (low + high) // 2
        if arr[mid] == arr[high]:
            high -= 1
        elif arr[mid] > arr[high]:
            low = mid + 1
        else:
            high = mid
    return low.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:03:45 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                A[i][j] = (i - j) * A[i - 1][j]
            else:
                A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:06:57 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:06:57 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:06:58 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:19:04 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:19:04 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-09 15:19:05 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 15:19:05 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:19:06 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-09 15:19:06 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:19:06 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:19:06 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:19:06 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-09 15:19:06 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:19:07 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:19:07 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 15:19:07 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:19:07 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:19:08 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:19:08 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:19:08 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-09 15:19:08 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 1:
        return True
    for k in range(1, n):
        if (n - k * (k + 1) // 2) % k == 0 and (n - k * (k + 1) // 2) // k > 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:19:08 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:19:08 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:19:09 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:19:09 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-09 15:19:10 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:19:10 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-09 15:19:39 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    return parts[0] + ''.join((part.capitalize() for part in parts[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:19:41 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:19:43 - Error: name 'defaultdict' is not defined.
 Solution: def count_Substrings(s):
    n = len(s)
    count = 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-09 15:19:47 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:19:48 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits))
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-09 15:19:51 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        avg = sum(tup) / len(tup) if tup else 0
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:19:54 - Error: .
 Solution: def is_polite(n):
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:19:56 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_surface_area = 2 * base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:19:56 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:19:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:19:59 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    star_number = n * (6 * n - 6) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:20:00 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:20:02 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle * (180 / cmath.pi).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:20:04 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:20:12 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    if n == 0:
        return 0
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] >= arr[mid]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:20:14 - Error: .
 Solution: def eulerian_num(n, m):
    eulerian = [[0] * (m + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, min(i, m) + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j - 1] + 1
            else:
                eulerian[i][j] = (i - j) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:21:17 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    result = tuple((a * b for (a, b) in zip(test_tup, test_tup[1:])))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-09 15:21:18 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = [part.capitalize() for part in word.split('_') if part]
    return parts[0].lower() + ''.join(parts[1:]).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:21:23 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    memo = {0: 0, 1: 1}

    def compute_jacobsthal(k):
        if k in memo:
            return memo[k]
        memo[k] = compute_jacobsthal(k - 2) + 2 * compute_jacobsthal(k - 1)
        return memo[k]
    return compute_jacobsthal(n).
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 15:21:37 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:21:42 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:21:42 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r <= 0 or h <= 0:
        raise ValueError('Both radius and height must be positive numbers.')
    total_surface_area = 2 * math.pi * r * (r + h)
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:21:45 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:21:51 - Error: module 'cmath' has no attribute 'atan2'.
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    angle = cmath.atan2(b, a)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:22:03 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:22:06 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 0:
        raise ValueError('Input must be a positive integer.')
    if n == 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1.0 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:22:06 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    if n == 0:
        return 0
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:22:21 - Error: .
 Solution: def eulerian_num(n, m):
    if m > n or n < 0 or m < 0:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 1
        A[i][i] = 1
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:25:16 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 15:25:16 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:25:16 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:25:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:25:16 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:25:16 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-09 15:25:16 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-09 15:25:16 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        return None
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0] * (n + 1)
        jacobsthal[0] = 0
        jacobsthal[1] = 1
        for i in range(2, n + 1):
            jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
        return jacobsthal[n]
n = 10.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 15:25:16 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-09 15:25:16 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-09 15:25:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:25:17 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 1:
        return True
    for k in range(1, n):
        if (n - k * (k + 1) // 2) % k == 0 and (n - k * (k + 1) // 2) // k > 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:25:18 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:25:18 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:25:18 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 15:25:19 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:25:19 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:25:19 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:25:19 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:25:19 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:25:19 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-09 15:25:19 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:25:19 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-09 15:25:20 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:25:20 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:26:06 - Error: .
 Solution: def remove_odd(str1):
    """
    This function removes characters from the input string that are at odd indices.
    
    Parameters:
    str1 (str): The input string from which to remove odd-indexed characters.
    
    Returns:
    str: A new string with characters at odd indices removed.
    """
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:26:09 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items if len(max_items) > 1 else max_items[0].
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-09 15:26:10 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    if not isinstance(word, str):
        raise ValueError('Input must be a string')
    components = word.split('_')
    camel_case = components[0] + ''.join((part.capitalize() for part in components[1:]))
    for char in word:
        if not (char.isalnum() or char == '_'):
            raise ValueError('Input string can only contain alphanumeric characters and underscores')
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:26:12 - Error: List must contain at least two distinct numbers..
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        raise ValueError('List must contain at least two distinct numbers.')
    first = float('inf')
    second = float('inf')
    for number in numbers:
        if number < first:
            second = first
            first = number
        elif first < number < second:
            second = number
    if second == float('inf'):
        raise ValueError('List must contain at least two distinct numbers.')
    return second.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-09 15:26:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    """
    This function checks if the input string matches the pattern of 'a' followed by one or more 'b's.
    
    Parameters:
    text (str): The input string to be checked against the pattern.
    
    Returns:
    bool: True if the string matches the pattern, False otherwise.
    """
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:26:25 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not isinstance(tup, tuple) or not tup:
            averages.append(0.0)
            continue
        total = sum(tup)
        count = len(tup)
        average = total / count
        averages.append(average)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:26:26 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    else:
        return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:26:27 - Error: The input words must be a list of strings..
 Solution: def long_words(n, words):
    """
    Returns a list of words that are longer than n characters from the given list of words.

    Parameters:
    n (int): The length threshold.
    words (list): A list of words (strings).

    Returns:
    list: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('The length threshold n must be a non-negative integer.')
    if not isinstance(words, list):
        raise ValueError('The input words must be a list of strings.')
    if any((not isinstance(word, str) for word in words)):
        raise ValueError('All elements in the words list must be strings.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-09 15:26:28 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:26:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:26:35 - Error: Both a and b must be integers or floats..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.

    Parameters:
    a (float or int): The real part of the complex number.
    b (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be integers or floats.')
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:26:38 - Error: .
 Solution: def find_length(string):
    if not string:
        return 0
    transformed = [1 if char == '0' else -1 for char in string]
    max_diff = 0
    current_sum = 0
    sum_index_map = {0: -1}
    for (index, value) in enumerate(transformed):
        current_sum += value
        if current_sum not in sum_index_map:
            sum_index_map[current_sum] = index
        max_diff = max(max_diff, index - sum_index_map[current_sum])
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-09 15:26:42 - Error: .
 Solution: def Diff(li1, li2):
    """
    This function returns the difference between two lists.
    It returns a list of elements that are in li1 but not in li2.
    
    Parameters:
    li1 (list): The first list from which to find the difference.
    li2 (list): The second list to compare against.
    
    Returns:
    list: A list containing elements in li1 that are not in li2.
    """
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:26:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:26:49 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (n + 1) // 6.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:26:52 - Error: .
 Solution: def string_to_tuple(str1):
    if str1 is None:
        return ()
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:26:59 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:26:59 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:27:05 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:27:31 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    if equal_count == 3:
        return 3
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:27:31 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0:
        return True
    return n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:27:31 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:27:35 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:27:35 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    return round(2 * math.pi * r * (r + h), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:27:36 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:27:36 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for num_tuple in nums:
        if len(num_tuple) == 0:
            avg = 0
        else:
            avg = sum(num_tuple) / len(num_tuple)
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:27:37 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:27:38 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:27:40 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:27:41 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] <= arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:27:41 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:27:48 - Error: .
 Solution: def eulerian_num(n, m):
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = 1
            else:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:28:30 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:28:34 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    return parts[0] + ''.join((part.capitalize() for part in parts[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:28:42 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0.0)
        else:
            averages.append(sum(tup) / len(tup))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:28:42 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:28:48 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:28:52 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = set1 - set2
    return list(difference).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:28:53 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = (i + 1) * A[i - 1][j]
            elif j == i:
                A[i][j] = (i + 1) * A[i - 1][j - 1]
            else:
                A[i][j] = (i + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:28:53 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:28:53 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:28:53 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:28:56 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:28:56 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-09 15:28:58 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            max_product = max(max_product, abs(max(list1[i]) * max(list1[j])))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:28:59 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:29:07 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:29:52 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:29:53 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-09 15:29:55 - Error: .
 Solution: def string_to_tuple(str1: str) -> tuple:
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:29:56 - Error: .
 Solution: from collections import Counter
from typing import List
def find_sum(arr: List[int]) -> int:
    counts = Counter(arr)
    return sum((num for (num, count) in counts.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:29:59 - Error: .
 Solution: import cmath
def angle_complex(a: float, b: float) -> float:
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:30:00 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) > 0:
            avg = sum(tup) / len(tup)
            averages.append(avg)
        else:
            averages.append(0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:30:02 - Error: .
 Solution: from typing import List, Tuple
def max_product_tuple(list1: List[Tuple[int, int]]) -> int:
    if not list1:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:30:03 - Error: .
 Solution: from collections import defaultdict
from typing import List, Tuple, Optional
def max_occurrences(nums: List[int]) -> Optional[Tuple[int, int]]:
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_item = max(frequency.items(), key=lambda x: (x[1], -x[0]))
    return (max_item[0], max_item[1]).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-09 15:30:03 - Error: .
 Solution: def sum_div(number: int) -> int:
    if number <= 0:
        return 0
    total = 0
    for i in range(1, number // 2 + 1):
        if number % i == 0:
            total += i
    total += number
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 15:30:03 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:30:05 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    if not word:
        return ''
    parts = word.split('_')
    return parts[0] + ''.join((part.capitalize() for part in parts[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:30:08 - Error: Function count_rotation is not defined in the solution..
 Solution: from typing import List.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:30:10 - Error: .
 Solution: import re
def text_match_zero_one(text: str) -> bool:
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:30:12 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:30:13 - Error: .
 Solution: def Diff(li1: list, li2: list) -> list:
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:30:13 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:30:13 - Error: .
 Solution: from typing import List, Tuple
def start_withp(words: List[str]) -> Tuple[str, str]:
    filtered_words = [word for word in words if word.lower().startswith('p')]
    return tuple(filtered_words[:2]) if len(filtered_words) >= 2 else tuple(filtered_words + [None] * (2 - len(filtered_words))).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 15:30:14 - Error: .
 Solution: from typing import List, Tuple
def extract_freq(test_list: List[Tuple]) -> int:
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-09 15:30:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r: float, h: float) -> float:
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return 2 * math.pi * r * (r + h).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:31:26 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:31:28 - Error: .
 Solution: import cmath
def angle_complex(a: float, b: float) -> float:
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number at the origin (0, 0).')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:31:29 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:31:30 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (n + 1) // 6.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:31:32 - Error: .
 Solution: from typing import List, Tuple
def start_withp(words: List[str]) -> Tuple[str, str]:
    p_words = [word for word in words if isinstance(word, str) and word.lower().startswith('p')]
    return (p_words[0], p_words[1]) if len(p_words) >= 2 else (None, None).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 15:31:32 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:31:34 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:31:35 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] <= arr[-1]:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:31:40 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:31:40 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:31:42 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(None)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:31:42 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        (a, b) = (0, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + 2 * b)
        return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 15:31:44 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:31:44 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-09 15:31:45 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = set1.difference(set2)
    return list(difference).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:31:46 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:31:50 - Error: .
 Solution: from typing import List
from collections import Counter
def find_sum(arr: List[int]) -> int:
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:31:52 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        if prefix_sum - (i + 1) in sum_count:
            count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-09 15:34:06 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:34:08 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:34:09 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-09 15:34:12 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-09 15:34:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * (r + h), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:34:18 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if isinstance(tup, tuple) and len(tup) > 0:
            avg = sum(tup) / len(tup)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:34:19 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:34:22 - Error: .
 Solution: from typing import List, Tuple
def start_withp(words: List[str]) -> Tuple[str, str]:
    if not isinstance(words, list):
        return ('', '')
    filtered_words = [word for word in words if isinstance(word, str) and word.lower().startswith('p')]
    if len(filtered_words) < 2:
        return ('', '')
    return (filtered_words[0], filtered_words[1]).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-09 15:34:23 - Error: .
 Solution: from typing import List
def find_sum(arr: List[int]) -> int:
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    return sum((num for (num, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:34:26 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1).difference(set(li2))).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:34:27 - Error: .
 Solution: import cmath
import math
def angle_complex(a, b=None):
    if b is None:
        z = a
    else:
        z = complex(a, b)
    if isinstance(z, complex):
        return cmath.phase(z)
    else:
        raise ValueError('Input must be a complex number, integer, or float.').
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:34:28 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:34:31 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    c_max = max(r, g, b)
    c_min = min(r, g, b)
    delta = c_max - c_min
    if delta == 0:
        h = 0
    elif c_max == r:
        h = 60 * ((g - b) / delta % 6)
    elif c_max == g:
        h = 60 * ((b - r) / delta + 2)
    else:
        h = 60 * ((r - g) / delta + 4)
    if c_max == 0:
        s = 0
    else:
        s = delta / c_max
    v = c_max
    h = h if h >= 0 else h + 360
    s = s * 100
    v = v * 100
    return (int(h), s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-09 15:34:33 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-09 15:34:37 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (n - 1) // 3 + 1
def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (n - 1) // 3 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:34:40 - Error: .
 Solution: from typing import List, Tuple
def extract_freq(test_list: List[Tuple]) -> int:
    if not isinstance(test_list, list):
        raise ValueError('Input must be a list.')
    for item in test_list:
        if not isinstance(item, tuple):
            raise ValueError('All elements in the list must be tuples.')
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-09 15:34:41 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:34:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:34:57 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-09 15:34:58 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j > 0:
                A[i][j] += (i - j + 1) * A[i - 1][j - 1]
            A[i][j] += (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:36:24 - Error: .
 Solution: def remove_odd(str1):
    if str1 is None:
        raise ValueError('Input cannot be None')
    if not isinstance(str1, str):
        raise TypeError('Input must be a string')
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:36:35 - Error: .
 Solution: def dif_Square(n):
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:36:37 - Error: .
 Solution: def string_to_tuple(str1):
    if str1 is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(str1, str):
        raise TypeError('Input must be a string.')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:36:46 - Error: The 'words' parameter must be a list or tuple..
 Solution: def long_words(n, words):
    if not isinstance(n, int):
        raise ValueError("The length 'n' must be an integer.")
    if n < 0:
        return []
    if not isinstance(words, (list, tuple)):
        raise ValueError("The 'words' parameter must be a list or tuple.")
    for word in words:
        if not isinstance(word, str):
            raise ValueError("All elements in the 'words' list must be strings.")
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-09 15:36:46 - Error: .
 Solution: def sum_div(number):
    if number is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(number, int):
        raise TypeError('Input must be an integer.')
    if number < 0:
        raise ValueError('Input must be a non-negative integer.')
    total = 0
    for i in range(1, number // 2 + 1):
        if number % i == 0:
            total += i
    total += number
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 15:36:49 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r is None or h is None:
        raise ValueError('Radius and height must not be None.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:36:49 - Error: .
 Solution: def remove_nested(test_tup):
    if test_tup is None:
        raise ValueError('Input cannot be None')
    if not isinstance(test_tup, tuple):
        raise TypeError('Input must be a tuple')
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-09 15:36:58 - Error: .
 Solution: def jacobsthal_num(n):
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0:
        return 0
    elif n == 1:
        return 1
    (prev2, prev1) = (0, 1)
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        (prev2, prev1) = (prev1, current)
    return current.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-09 15:37:00 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple):
        raise TypeError('Input must be a tuple.')
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    for item in test_tup:
        if item is None:
            raise ValueError('Input tuple cannot contain None values.')
        if not isinstance(item, (int, float)):
            raise TypeError('All elements in the tuple must be numbers (int or float).')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-09 15:37:03 - Error: .
 Solution: def count_rotation(arr):
    if arr is None or not isinstance(arr, list) or (not all((isinstance(x, (int, float)) for x in arr))):
        raise ValueError('Input must be a list of numbers.')
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:37:09 - Error: .
 Solution: def find_sum(arr):
    if arr is None:
        raise ValueError('Input cannot be None')
    if not isinstance(arr, list):
        raise TypeError('Input must be a list')
    element_count = {}
    for element in arr:
        if not isinstance(element, (int, float)):
            raise TypeError('All elements in the list must be integers or floats')
        element_count[element] = element_count.get(element, 0) + 1
    return sum((key for (key, value) in element_count.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:37:12 - Error: .
 Solution: def snake_to_camel(word):
    if word is None:
        raise ValueError('Input cannot be None')
    if not isinstance(word, str):
        raise TypeError('Input must be a string')
    if len(word) == 0:
        return ''
    if any((char.isupper() for char in word)):
        raise ValueError('Input should be in snake_case (lowercase letters only)')
    if '_' not in word:
        return word
    parts = word.split('_')
    if any((len(part) == 0 for part in parts)):
        raise ValueError('Input cannot contain consecutive underscores')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:37:17 - Error: .
 Solution: def bell_number(n):
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    bell = [0] * (n + 1)
    bell[0] = 1
    for i in range(1, n + 1):
        bell[i] = 0
        for j in range(i):
            bell[i] += bell[j] * bell[i - 1 - j]
    return bell[n].
 Test: def check():
    assert bell_number(2)==2
    assert bell_number(10)==115975
    assert bell_number(56)==6775685320645824322581483068371419745979053216268760300

2025-10-09 15:37:19 - Error: Length of 'arr' must be equal to 'n'..
 Solution: def is_majority(arr, n, x):
    if not isinstance(arr, list):
        raise TypeError("Input 'arr' must be a list.")
    if not isinstance(n, int):
        raise TypeError("Input 'n' must be an integer.")
    if not isinstance(x, (int, float)):
        raise TypeError("Input 'x' must be an integer or float.")
    if n < 0:
        raise ValueError("Input 'n' must be non-negative.")
    if len(arr) != n:
        raise ValueError("Length of 'arr' must be equal to 'n'.")
    if n == 0:
        return False
    majority_count = n // 2
    first_index = binary_search(arr, x, True)
    if first_index == -1:
        return False
    last_index = binary_search(arr, x, False)
    count_x = last_index - first_index + 1
    return count_x > majority_count
def binary_search(arr, x, find_first):
    (low, high) = (0, len(arr) - 1)
    result = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            result = mid
            if find_first:
                high = mid - 1
            else:
                low = mid + 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return result.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-09 15:37:23 - Error: .
 Solution: def average_tuple(nums):
    if nums is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(nums, tuple):
        raise TypeError('Input must be a tuple of tuples.')
    averages = []
    for (index, inner_tuple) in enumerate(nums):
        if not isinstance(inner_tuple, tuple):
            raise TypeError(f'Element at index {index} is not a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
            continue
        total = sum(inner_tuple)
        count = len(inner_tuple)
        averages.append(total / count)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:37:29 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:37:32 - Error: .
 Solution: def Diff(li1, li2):
    if li1 is None or li2 is None:
        raise ValueError('Input lists cannot be None.')
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise TypeError('Both inputs must be lists.')
    set1 = set(li1)
    set2 = set(li2)
    difference = set1.symmetric_difference(set2)
    return sorted(list(difference)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-09 15:37:36 - Error: .
 Solution: def is_undulating(n):
    if not isinstance(n, int) or n < 0:
        return False
    if n < 10:
        return True
    previous_digit = n % 10
    n //= 10
    is_up = None
    while n > 0:
        current_digit = n % 10
        if current_digit == previous_digit:
            return False
        if is_up is None:
            is_up = current_digit < previous_digit
        elif (current_digit < previous_digit) == is_up:
            return False
        previous_digit = current_digit
        n //= 10
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-09 15:37:39 - Error: Input must be a list..
 Solution: def max_Abs_Diff(arr):
    if arr is None:
        raise ValueError('Input array cannot be None.')
    if not isinstance(arr, list):
        raise TypeError('Input must be a list.')
    if len(arr) < 2:
        raise ValueError('Input array must contain at least two elements.')
    if any((not isinstance(x, (int, float)) for x in arr)):
        raise TypeError('All elements in the array must be integers or floats.')
    min_value = min(arr)
    max_value = max(arr)
    return max_value - min_value.
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-09 15:37:51 - Error: .
 Solution: def max_product_tuple(list1):
    if not isinstance(list1, list):
        raise TypeError('Input must be a list.')
    if len(list1) < 2:
        raise ValueError('Input list must contain at least two tuples.')
    max_product = float('-inf')
    for i in range(len(list1)):
        if not isinstance(list1[i], tuple) or len(list1[i]) != 2:
            raise ValueError('All elements in the list must be tuples of exactly two elements.')
        for j in range(i + 1, len(list1)):
            if not isinstance(list1[j], tuple) or len(list1[j]) != 2:
                raise ValueError('All elements in the list must be tuples of exactly two elements.')
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:37:53 - Error: .
 Solution: def eulerian_num(n, m):
    if not isinstance(n, int) or not isinstance(m, int):
        raise TypeError('Both n and m must be integers.')
    if n < 0 or m < 0:
        raise ValueError('Both n and m must be non-negative integers.')
    if m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j]
            else:
                eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-09 15:39:21 - Error: .
 Solution: def square_Sum(n: int) -> int:
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * n * n.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-09 15:39:30 - Error: .
 Solution: def dif_Square(n):
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-09 15:39:32 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-09 15:39:35 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup: tuple) -> tuple:
    if not isinstance(test_tup, tuple):
        raise TypeError('Input must be a tuple.')
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    if not all((isinstance(x, (int, float)) for x in test_tup)):
        raise TypeError('All elements in the tuple must be numbers (int or float).')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-09 15:39:35 - Error: .
 Solution: def string_to_tuple(str1: str) -> tuple:
    if not isinstance(str1, str):
        raise TypeError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-09 15:39:38 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if nums is None:
        raise ValueError('Input cannot be None')
    if not isinstance(nums, list):
        raise TypeError('Input must be a list')
    if len(nums) == 0:
        return None
    frequency = defaultdict(int)
    for num in nums:
        if not isinstance(num, (int, float)):
            raise TypeError('All elements in the list must be integers or floats')
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items[0] if len(max_items) == 1 else max_items.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-09 15:39:47 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-09 15:39:48 - Error: Both inputs must be numeric..
 Solution: import cmath
def angle_complex(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both inputs must be numeric.')
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-09 15:39:48 - Error: .
 Solution: def remove_odd(str1):
    if str1 is None:
        raise ValueError('Input cannot be None')
    if not isinstance(str1, str):
        raise TypeError('Input must be a string')
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-09 15:39:49 - Error: .
 Solution: def find_sum(arr: list[int]) -> int:
    from collections import Counter
    count = Counter(arr)
    return sum((key for (key, value) in count.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-09 15:39:49 - Error: .
 Solution: def find_star_num(n: int) -> int:
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * (3 * n - 1) // 2 if n > 0 else 0.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-09 15:39:51 - Error: .
 Solution: from typing import List
def count_rotation(arr: List[int]) -> int:
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-09 15:39:52 - Error: .
 Solution: def sum_div(number: int) -> int:
    if number < 1:
        return 0
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-09 15:39:58 - Error: .
 Solution: from typing import List, Tuple
def max_product_tuple(list1: List[Tuple[int, int]]) -> int:
    if not isinstance(list1, list):
        raise TypeError('Input must be a list.')
    if len(list1) < 2:
        raise ValueError('Input list must contain at least two tuples.')
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-09 15:40:04 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
            continue
        total = sum(inner_tuple)
        count = len(inner_tuple)
        averages.append(total / count)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-09 15:40:08 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-09 15:40:12 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    if word is None:
        raise ValueError('Input cannot be None')
    if not isinstance(word, str):
        raise TypeError('Input must be a string')
    if len(word) == 0:
        return ''
    if any((char.isupper() for char in word)):
        raise ValueError('Input should be in snake_case (no uppercase letters allowed)')
    if '_' not in word:
        return word
    parts = word.split('_')
    if any((part == '' for part in parts)):
        raise ValueError('Input cannot contain consecutive underscores')
    return parts[0] + ''.join((part.capitalize() for part in parts[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-09 15:40:25 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s: str) -> int:
    if s is None:
        raise ValueError('Input cannot be None')
    if not isinstance(s, str):
        raise TypeError('Input must be a string')
    if any((not char.isdigit() for char in s)):
        raise ValueError('Input string must contain only digits')
    n = len(s)
    if n == 0:
        return 0
    count = 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        if prefix_sum - (i + 1) in sum_count:
            count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-09 15:40:26 - Error: .
 Solution: import math
def surfacearea_cylinder(r: float, h: float) -> float:
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-09 15:40:27 - Error: Invalid length of the array..
 Solution: from typing import List
def is_majority(arr: List[int], n: int, x: int) -> bool:
    if not isinstance(arr, list) or not all((isinstance(i, int) for i in arr)) or (not isinstance(n, int)) or (not isinstance(x, int)):
        raise ValueError('Invalid input types.')
    if n < 0 or n != len(arr):
        raise ValueError('Invalid length of the array.')
    if n == 0:
        return False
    (left, right) = (0, n - 1)
    first_index = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < x:
            left = mid + 1
        elif arr[mid] > x:
            right = mid - 1
        else:
            first_index = mid
            right = mid - 1
    if first_index == -1:
        return False
    last_index = first_index
    while last_index < n and arr[last_index] == x:
        last_index += 1
    count_x = last_index - first_index
    return count_x > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-09 15:42:04 - Error: .
 Solution: def find_lists(Input):
    count = 0
    for item in Input:
        if isinstance(item, list):
            count += 1
    return count.
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-09 15:42:06 - Error: .
 Solution: def count_bidirectional(test_list):
    unique_pairs = set()
    for (a, b) in test_list:
        unique_pairs.add((a, b))
        unique_pairs.add((b, a))
    count = 0
    for pair in unique_pairs:
        if (pair[1], pair[0]) in unique_pairs:
            count += 1
    return count // 2.
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-09 15:42:11 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    if sale_amount < actual_cost:
        return actual_cost - sale_amount
    return 0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-09 15:42:11 - Error: .
 Solution: def triangle_area(r):
    if r <= 0:
        return None
    return r * r / 2.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-09 15:42:12 - Error: .
 Solution: def find_First_Missing(array, start=0, end=None):
    if end is None:
        end = len(array) - 1
    if start > end:
        return 1
    expected_number = start + 1
    for i in range(start, end + 1):
        if array[i] > expected_number:
            return expected_number
        elif array[i] == expected_number:
            expected_number += 1
    return expected_number.
 Test: def check():
    assert find_First_Missing([0,1,2,3]) == 4
    assert find_First_Missing([0,1,2,6,9]) == 3
    assert find_First_Missing([2,3,5,8,9]) == 0

2025-10-09 15:42:13 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    matches = list(re.finditer(re.escape(pattern), text))
    if not matches:
        return None
    positions = [(match.group(), match.start(), match.end()) for match in matches]
    return positions if len(positions) > 1 else positions[0].
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-09 15:42:13 - Error: .
 Solution: def get_coordinates(test_tup):
    (x, y) = test_tup
    adjacent_coordinates = [(i, j) for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]
    adjacent_coordinates = [coord for coord in adjacent_coordinates if coord != (x, y)]
    return adjacent_coordinates.
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-09 15:42:13 - Error: .
 Solution: def tuple_intersection(test_list1, test_list2):
    set1 = set(test_list1)
    set2 = set(test_list2)
    intersection = set1.intersection(set2)
    return tuple(intersection).
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-09 15:42:13 - Error: .
 Solution: def common_element(list1, list2):
    set1 = set(list1)
    for element in list2:
        if element in set1:
            return True
    return False.
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-09 15:42:13 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    return sorted(nums_str, key=lambda x: int(x) if x.lstrip('-').isdigit() else float('inf')).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-09 15:42:13 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n < 1:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-09 15:42:13 - Error: .
 Solution: def surface_Area(b, s):
    base_area = b * b
    slant_height = (s ** 2 + (b / 2) ** 2) ** 0.5
    triangular_area = 2 * (0.5 * b * slant_height)
    total_surface_area = base_area + triangular_area
    return total_surface_area
def surface_Area(b, s):
    base_area = b * b
    slant_height = (s ** 2 + (b / 2) ** 2) ** 0.5
    triangular_area = 2 * (0.5 * b * slant_height)
    total_surface_area = base_area + triangular_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-09 15:42:14 - Error: .
 Solution: import math
def area_tetrahedron(side):
    return math.sqrt(2) / 12 * side ** 2 * math.sqrt(2) * 3.
 Test: def check():
    assert area_tetrahedron(3)==15.588457268119894
    assert area_tetrahedron(20)==692.8203230275509
    assert area_tetrahedron(10)==173.20508075688772

2025-10-09 15:42:14 - Error: .
 Solution: def remove_kth_element(list1, L):
    if L < 0 or L >= len(list1):
        return list1
    return list1[:L] + list1[L + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-09 15:42:14 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    for (start, end) in ranges:
        length = end - start + 1
        rotations_mod = rotations % length
        arr[start:end + 1] = arr[start:end + 1][-rotations_mod:] + arr[start:end + 1][:-rotations_mod]
    return arr[index].
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-09 15:42:14 - Error: .
 Solution: def set_left_most_unset_bit(n):
    position = 0
    temp = n
    while temp > 0:
        position += 1
        temp >>= 1
    leftmost_unset_bit_mask = 1 << position
    if n & leftmost_unset_bit_mask:
        leftmost_unset_bit_mask <<= 1
    return n | leftmost_unset_bit_mask.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-09 15:42:15 - Error: .
 Solution: def merge_dictionaries_three(dict1, dict2, dict3):
    merged_dict = {**dict1, **dict2, **dict3}
    return merged_dict.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-09 15:42:16 - Error: .
 Solution: def count_vowels(test_str):
    vowels = set('aeiouAEIOU')
    count = 0
    for i in range(len(test_str)):
        if i > 0 and test_str[i - 1] in vowels or (i < len(test_str) - 1 and test_str[i + 1] in vowels):
            count += 1
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-09 15:42:16 - Error: .
 Solution: def find_Max_Num(arr):
    arr = list(map(str, arr))
    arr.sort(key=lambda x: x * 10, reverse=True)
    largest_num = ''.join(arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-09 15:42:16 - Error: .
 Solution: from itertools import chain, combinations
def combinations_list(list1):
    return sorted(map(list, chain.from_iterable((combinations(list1, r) for r in range(len(list1) + 1)))), key=lambda x: (len(x), x)).
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-09 15:42:16 - Error: .
 Solution: def group_tuples(Input):
    if not Input:
        return None
    first_element_map = {}
    for tup in Input:
        if tup:
            first_elem = tup[0]
            if first_elem not in first_element_map:
                first_element_map[first_elem] = []
            first_element_map[first_elem].append(tup[1:])
    common_first_elements = [tuple([first_elem] + list(tup_list)) for (first_elem, tup_list) in first_element_map.items() if len(tup_list) > 1]
    return common_first_elements if common_first_elements else None.
 Test: def check():
    assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]
    assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]
    assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]

2025-10-09 15:42:16 - Error: .
 Solution: def comb_sort(nums):
    gap = len(nums)
    shrink = 1.3
    sorted = False
    while not sorted:
        gap = max(1, int(gap / shrink))
        sorted = True
        for i in range(len(nums) - gap):
            if nums[i] > nums[i + gap]:
                (nums[i], nums[i + gap]) = (nums[i + gap], nums[i])
                sorted = False
    return nums.
 Test: def check():
    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
    assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]
    assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]

2025-10-09 15:42:17 - Error: .
 Solution: def find_dissimilar(test_tup1, test_tup2):
    set1 = set(test_tup1)
    set2 = set(test_tup2)
    dissimilar_elements = set1.symmetric_difference(set2)
    return tuple(sorted(dissimilar_elements)).
 Test: def check():
    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)
    assert find_dissimilar((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)
    assert find_dissimilar((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)

2025-10-09 15:42:17 - Error: .
 Solution: from itertools import combinations
def find_combinations(test_list):
    result = set()
    for r in range(1, len(test_list) + 1):
        for combo in combinations(test_list, r):
            combo_sum = tuple((sum(x) for x in zip(*combo)))
            result.add(combo_sum)
    return sorted(result).
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-09 15:42:18 - Error: '<=' not supported between instances of 'tuple' and 'int'.
 Solution: def min_Jumps(steps, d):
    if d < 0 or steps <= 0:
        return -1
    max_distance = steps * (steps + 1) // 2
    if max_distance < d:
        return -1
    if (max_distance - d) % 2 != 0:
        return -1
    for jumps in range(1, steps + 1):
        current_distance = jumps * (jumps + 1) // 2
        if current_distance >= d and (current_distance - d) % 2 == 0:
            return jumps
    return -1.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-09 15:42:18 - Error: .
 Solution: def max_difference(test_list):
    if not test_list or len(test_list) < 2:
        return 0
    min_value = float('inf')
    max_value = float('-inf')
    for tup in test_list:
        if isinstance(tup, tuple) and len(tup) == 2:
            min_value = min(min_value, min(tup))
            max_value = max(max_value, max(tup))
    return max_value - min_value if max_value != float('-inf') and min_value != float('inf') else 0.
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-09 15:42:19 - Error: .
 Solution: def upper_ctr(s):
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-09 15:42:19 - Error: .
 Solution: def max_length(list1):
    if not list1:
        return (0, [])
    max_len = 0
    max_lists = []
    for sublist in list1:
        if len(sublist) > max_len:
            max_len = len(sublist)
            max_lists = [sublist]
        elif len(sublist) == max_len:
            max_lists.append(sublist)
    return (max_len, max_lists).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-09 15:42:19 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    return re.sub('\\(.*?\\)', '', items).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-09 15:42:19 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    mask = (1 << r - l + 1) - 1 << l
    return n & mask == 0.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-09 15:42:19 - Error: 'int' object is not iterable.
 Solution: def check_tuplex(tuplex, tuple1):
    return any((item in tuplex for item in tuple1)).
 Test: def check():
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c", "e"),'r')==True
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c", "e"),'5')==False
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c","e"),3)==True

2025-10-09 15:42:20 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count1 = str1.count('1')
    count2 = str2.count('1')
    if count1 != count2:
        return -1
    mismatches = []
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            mismatches.append((str1[i], str2[i]))
    count_swaps = 0
    count_01 = 0
    count_10 = 0
    for mismatch in mismatches:
        if mismatch == ('0', '1'):
            count_01 += 1
        elif mismatch == ('1', '0'):
            count_10 += 1
    count_swaps = max(count_01, count_10)
    return count_swaps.
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-09 15:42:20 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-09 15:42:21 - Error: .
 Solution: def min_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    min_product = float('inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = list1[i][0] * list1[i][1] + list1[j][0] * list1[j][1]
            if product < min_product:
                min_product = product
    return min_product.
 Test: def check():
    assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8
    assert min_product_tuple([(10,20), (15,2), (5,10)] )==30
    assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100

2025-10-09 15:42:21 - Error: .
 Solution: def sum_Of_Subarray_Prod(arr):
    n = len(arr)
    total_sum = 0
    mod = 10 ** 9 + 7
    for i in range(n):
        left_count = i + 1
        right_count = n - i
        contribution = arr[i] * left_count * right_count
        total_sum = (total_sum + contribution) % mod
    return total_sum.
 Test: def check():
    assert sum_Of_Subarray_Prod([1,2,3]) == 20
    assert sum_Of_Subarray_Prod([1,2]) == 5
    assert sum_Of_Subarray_Prod([1,2,3,4]) == 84

2025-10-09 15:42:21 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if m < 0 or n < 0 or m >= len(tuplex) or (n >= len(tuplex)) or (m > n):
        return ()
    return tuplex[m:n + 1].
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-09 15:42:21 - Error: Function is_octagonal is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_octagonal(5) == 65
    assert is_octagonal(10) == 280
    assert is_octagonal(15) == 645

2025-10-09 15:42:21 - Error: .
 Solution: def get_ludic(n):
    ludic_numbers = []
    non_ludic = set()
    current = 1
    while current <= n:
        if current not in non_ludic:
            ludic_numbers.append(current)
            for ln in ludic_numbers[:-1]:
                if current + ln <= n:
                    non_ludic.add(current + ln)
        current += 1
    return ludic_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-09 15:42:22 - Error: .
 Solution: def get_Char(strr):
    ascii_sum = sum((ord(char) for char in strr))
    return chr(ascii_sum % 26 + ord('a')).
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-09 15:42:22 - Error: .
 Solution: def merge(lst):
    first_elements = [sublist[0] for sublist in lst]
    second_elements = [sublist[1] for sublist in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-09 15:42:23 - Error: .
 Solution: def min_k(test_list, K):
    sorted_list = sorted(test_list, key=lambda x: x[0])
    return sorted_list[:K].
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-09 15:42:23 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n <= 0:
        return False
    return n & n - 1 == 0 or n > 0.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-09 15:42:24 - Error: .
 Solution: import re
def text_match_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_one("ac")==False
    assert text_match_one("dc")==False
    assert text_match_one("abba")==True

2025-10-09 15:42:24 - Error: .
 Solution: def is_prime(num):
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True
def newman_prime(n):
    if n < 1:
        return None
    count = 0
    candidate = 1
    while count < n:
        candidate += 1
        if is_prime(candidate):
            if candidate == 2 or candidate == 3 or candidate == 5 or (candidate == 7):
                count += 1
            else:
                for a in range(0, 20):
                    for b in range(0, 20):
                        newman_candidate = 2 ** a * 3 ** b + 1
                        if newman_candidate == candidate:
                            count += 1
                            break
                    if count >= n:
                        break
    return candidate.
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-09 15:42:25 - Error: .
 Solution: import math
def polar_rect(r, theta):
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return ((x, y), complex(x, y)).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-09 15:42:26 - Error: .
 Solution: def re_arrange_array(arr, n):
    negatives = []
    positives = []
    for i in range(n):
        if arr[i] < 0:
            negatives.append(arr[i])
        else:
            positives.append(arr[i])
    arr[:n] = negatives + positives
    return arr.
 Test: def check():
    assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]
    assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]
    assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]

2025-10-09 15:42:26 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    result = n | mask
    return result.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-09 15:42:27 - Error: .
 Solution: import re
def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((component.capitalize() for component in components[1:])).
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-09 15:42:27 - Error: Function sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert sum(10,15) == 6
    assert sum(100,150) == 93
    assert sum(4,6) == 3

2025-10-09 15:42:27 - Error: .
 Solution: def max_product(arr):
    n = len(arr)
    if n == 0:
        return 0
    max_prod = [0] * n
    for i in range(n):
        max_prod[i] = arr[i]
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])
    return max(max_prod)
def max_product(arr):
    n = len(arr)
    if n == 0:
        return 0
    max_prod = [0] * n
    for i in range(n):
        max_prod[i] = arr[i]
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])
    return max(max_prod).
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-09 15:42:28 - Error: Function is_num_decagonal is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_num_decagonal(3) == 27
    assert is_num_decagonal(7) == 175
    assert is_num_decagonal(10) == 370

2025-10-09 15:42:28 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' cannot be zero for a parabola.")
    vertex_x = -b / (2 * a)
    vertex_y = (4 * a * c - b ** 2) / (4 * a)
    p = 1 / (4 * a)
    directrix_y = vertex_y - p
    return directrix_y.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-09 15:42:28 - Error: .
 Solution: def trim_tuple(test_list, K):
    return [t[K:len(t) - K] if len(t) > 2 * K else () for t in test_list].
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-09 15:42:29 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must have the same length')
    return tuple((a * b for (a, b) in zip(test_tup1, test_tup2))).
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-09 15:42:30 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        return None
    max1 = max2 = float('-inf')
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return (max2, max1).
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-09 15:42:30 - Error: Temperature must be between -50 and 10 degrees Celsius..
 Solution: import math
def wind_chill(v, t):
    if v < 0:
        raise ValueError('Wind velocity must be non-negative.')
    if t < -50 or t > 10:
        raise ValueError('Temperature must be between -50 and 10 degrees Celsius.')
    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wind_chill_index).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-09 15:42:30 - Error: .
 Solution: def dog_age(h_age):
    if h_age < 0:
        return 'Age cannot be negative'
    elif h_age == 0:
        return 0
    elif h_age == 1:
        return 15
    elif h_age == 2:
        return 24
    else:
        return 24 + (h_age - 2) * 5.
 Test: def check():
    assert dog_age(12)==61
    assert dog_age(15)==73
    assert dog_age(24)==109

2025-10-09 15:42:31 - Error: .
 Solution: def odd_Equivalent(s, n):
    original_value = int(s, 2)
    odd_values = set()
    for i in range(n):
        if original_value % 2 == 1:
            odd_values.add(original_value)
        original_value = (original_value >> 1 | (original_value & 1) << len(s) - 1) & (1 << len(s)) - 1
    return len(odd_values).
 Test: def check():
    assert odd_Equivalent("011001",6) == 3
    assert odd_Equivalent("11011",5) == 4
    assert odd_Equivalent("1010",4) == 2

2025-10-09 15:42:31 - Error: .
 Solution: def and_tuples(test_tup1, test_tup2):
    elementwise_and = tuple((a & b for (a, b) in zip(test_tup1, test_tup2)))
    common_tuples = tuple((item for item in test_tup1 if item in test_tup2))
    return (elementwise_and, common_tuples).
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-09 15:42:32 - Error: .
 Solution: def sum_of_digits(nums):

    def digit_sum(n):
        return sum((int(digit) for digit in str(abs(n))))
    return [digit_sum(num) for num in nums].
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-09 15:42:33 - Error: .
 Solution: def centered_hexagonal_number(n):
    if n < 1:
        return 0
    return n * (3 * n - 3) // 2 + 1.
 Test: def check():
    assert centered_hexagonal_number(10) == 271
    assert centered_hexagonal_number(2) == 7
    assert centered_hexagonal_number(9) == 217

2025-10-09 15:42:33 - Error: .
 Solution: def cal_sum(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 3 + 0
    (p0, p1) = (3, 0)
    total_sum = p0 + p1
    for i in range(2, n):
        p_next = p0 + p1
        total_sum += p_next
        (p0, p1) = (p1, p_next)
    return total_sum.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-09 15:42:33 - Error: check_value() takes 1 positional argument but 2 were given.
 Solution: def check_value(d):
    if not d:
        return True
    first_value = next(iter(d.values()))
    return all((value == first_value for value in d.values())).
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-09 15:42:33 - Error: .
 Solution: def max_sum_increasing_subseq(a, n, index, k):
    max_sum = [0] * n
    for i in range(n):
        max_sum[i] = a[i]
        for j in range(i):
            if a[j] < a[i]:
                max_sum[i] = max(max_sum[i], max_sum[j] + a[i])
    max_sum_up_to_index = max(max_sum[:index + 1])
    max_sum_with_k = max_sum_up_to_index
    if a[k] > max_sum_up_to_index:
        max_sum_with_k = max_sum_up_to_index + a[k]
    return max_sum_with_k.
 Test: def check():
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7
    assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71

2025-10-09 15:42:34 - Error: .
 Solution: def count_first_elements(test_tup):
    result = []
    for (index, element) in enumerate(test_tup):
        count = 0
        for e in test_tup[:index]:
            if e == element:
                count += 1
        result.append(count)
    return tuple(result)
def count_first_elements(test_tup):
    result = []
    element_count = {}
    for element in test_tup:
        if element in element_count:
            result.append(element_count[element])
            element_count[element] += 1
        else:
            result.append(0)
            element_count[element] = 1
    return tuple(result).
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-09 15:42:34 - Error: Input must be a list or tuple of complex numbers..
 Solution: import cmath
def convert(numbers):
    if not isinstance(numbers, (list, tuple)):
        raise ValueError('Input must be a list or tuple of complex numbers.')
    polar_coordinates = []
    for number in numbers:
        if not isinstance(number, complex):
            raise ValueError('All elements in the input must be complex numbers.')
        polar_coordinates.append(cmath.polar(number))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-09 15:42:36 - Error: Each item in the input must be a list..
 Solution: def two_unique_nums(nums):
    if not isinstance(nums, list):
        raise ValueError('Input must be a list of lists.')
    unique_nums = set()
    for num_list in nums:
        if not isinstance(num_list, list):
            raise ValueError('Each item in the input must be a list.')
        unique_nums.update(num_list)
    return list(unique_nums).
 Test: def check():
    assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]
    assert two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5]
    assert two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5]

2025-10-09 15:42:38 - Error: .
 Solution: def find_solution(a, b, n):

    def gcd(x, y):
        while y:
            (x, y) = (y, x % y)
        return x
    g = gcd(a, b)
    if n % g != 0:
        return None
    a //= g
    b //= g
    n //= g

    def extended_gcd(x, y):
        if y == 0:
            return (x, 1, 0)
        (g, x1, y1) = extended_gcd(y, x % y)
        return (g, y1, x1 - x // y * y1)
    (_, x0, y0) = extended_gcd(a, b)
    x0 *= n
    y0 *= n
    return (x0, y0).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-09 15:42:38 - Error: .
 Solution: def max_sub_array_sum_repeated(a, n, k):

    def kadane(arr):
        max_ending_here = max_so_far = arr[0]
        for x in arr[1:]:
            max_ending_here = max(x, max_ending_here + x)
            max_so_far = max(max_so_far, max_ending_here)
        return max_so_far
    if k == 1:
        return kadane(a)
    total_sum = sum(a)
    max_start = kadane(a)
    max_end = kadane(a[::-1])
    if total_sum > 0:
        return max(max_start, max_end, max_start + max_end + (k - 2) * total_sum)
    else:
        return max(max_start, max_end).
 Test: def check():
    assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30
    assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59
    assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1

2025-10-10 09:31:20 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-10 09:31:20 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 09:31:20 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-10 09:31:21 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:31:21 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:31:21 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 09:31:21 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-10 09:31:21 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:31:21 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 09:31:21 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 09:31:22 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-10 09:31:22 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-10 09:31:22 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:31:22 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 09:31:22 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-10 09:31:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:31:23 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-10 09:31:23 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:31:23 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:31:23 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:31:23 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 1:
        return True
    for k in range(1, n):
        if (n - k * (k + 1) // 2) % k == 0 and (n - k * (k + 1) // 2) // k > 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 09:31:24 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:31:24 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 09:31:25 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 09:32:04 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:32:04 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:32:04 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:32:08 - Error: .
 Solution: def get_max_sum(n):
    memo = {}

    def helper(x):
        if x in memo:
            return memo[x]
        if x < 12:
            return x
        result = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)
        memo[x] = result
        return result
    return helper(n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-10 09:32:10 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:32:11 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:32:18 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 09:32:20 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 09:32:21 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:32:23 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 09:32:23 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:32:24 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    star_number = n * (2 * n - 1) * (n + 1) // 6
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:32:27 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 09:32:29 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle of the complex number in radians.
    """
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:32:32 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (left, right) = (0, len(arr) - 1)
    while left <= right:
        if arr[left] <= arr[right]:
            return left
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:33:16 - Error: .
 Solution: def remove_odd(str1):
    memo = {}

    def helper(s, index):
        if index in memo:
            return memo[index]
        if index == len(s):
            return ''
        if index % 2 == 0:
            result = s[index] + helper(s, index + 1)
        else:
            result = helper(s, index + 1)
        memo[index] = result
        return result
    return helper(str1, 0).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:33:16 - Error: .
 Solution: def snake_to_camel(word):

    def convert_to_camel(snake_str, index, memo):
        if index in memo:
            return memo[index]
        if index >= len(snake_str):
            return ''
        if snake_str[index] == '_':
            result = convert_to_camel(snake_str, index + 1, memo).capitalize()
        else:
            result = snake_str[index] + convert_to_camel(snake_str, index + 1, memo)
        memo[index] = result
        return result
    return convert_to_camel(word, 0, {}).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:33:16 - Error: .
 Solution: def swap_List(newList):

    def swap_helper(lst, start, end):
        if start >= end:
            return lst
        (lst[start], lst[end]) = (lst[end], lst[start])
        return swap_helper(lst, start + 1, end - 1)
    return swap_helper(newList, 0, len(newList) - 1).
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-10 09:33:21 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r <= 0 or h <= 0:
        return 0
    lateral_area = 2 * math.pi * r * h
    top_bottom_area = 2 * math.pi * r ** 2
    return round(lateral_area + top_bottom_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:33:23 - Error: .
 Solution: def find_star_num(n):
    """
    This function finds the n-th star number.
    A star number is defined as the number of points in a star polygon with n points.
    The formula for the n-th star number is given by: 
    S(n) = 6 * n * (n - 1) / 2 + 1
    """
    if n < 1:
        return 0
    return 6 * n * (n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:33:26 - Error: .
 Solution: def count_rotation(arr):

    def count_rotations_recursive(low, high):
        if low > high:
            return 0
        if low == high:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] >= arr[mid]:
            return count_rotations_recursive(low, mid - 1)
        else:
            return count_rotations_recursive(mid + 1, high)
    if not arr:
        return 0
    return count_rotations_recursive(0, len(arr) - 1)
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:33:32 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    This function calculates the angle (or phase) of a complex number
    represented by its real part 'a' and imaginary part 'b'.
    """
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:33:35 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False

    def count_occurrences(arr, n, x, memo):
        if n in memo:
            return memo[n]
        if n == 0:
            return 0
        count = count_occurrences(arr, n - 1, x, memo)
        if arr[n - 1] == x:
            count += 1
        memo[n] = count
        return count
    memo = {}
    count = count_occurrences(arr, n, x, memo)
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-10 09:33:36 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return harmonic_sum(n - 1) + 1 / (n - 1).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:33:36 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:33:42 - Error: .
 Solution: def text_match_zero_one(text):
    return match_helper(text, 0)
def match_helper(text, index):
    if index == len(text):
        return False
    if text[index] == 'a':
        index += 1
        while index < len(text) and text[index] == 'b':
            index += 1
        return index > 1 and text[index - 1] == 'b'
    return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 09:33:46 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(tup) / len(tup) for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:34:48 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1) if str1 is not None else ().
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 09:34:48 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return None
    if r == 0 or h == 0:
        return 0
    lateral_area = 2 * math.pi * r * h
    top_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * top_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:34:48 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 09:34:52 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:34:53 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:34:53 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    if not s:
        return 0
    count = 0
    digit_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(len(s)):
        if not s[i].isdigit():
            raise ValueError('Input string must contain only digits.')
        digit_sum += int(s[i])
        count += sum_count[digit_sum - (i + 1)]
        sum_count[digit_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 09:34:53 - Error: .
 Solution: def find_star_num(n):
    if n is None or n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:34:58 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:34:58 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):
    if startnum is None or endnum is None or startnum > endnum:
        return []

    def is_divisible(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits))
    return [num for num in range(startnum, endnum + 1) if is_divisible(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-10 09:35:02 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:35:02 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0:
        return 0
    if m > n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j - 1]
            else:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j] + i * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 09:35:04 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:35:05 - Error: .
 Solution: def extract_freq(test_list):
    if not test_list:
        return 0
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-10 09:35:06 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    frequency = {}
    for num in arr:
        frequency[num] = frequency.get(num, 0) + 1
    return sum((num for (num, count) in frequency.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:35:08 - Error: .
 Solution: def kth_element(arr, k):
    if not arr or k < 1 or k > len(arr):
        return None

    def quickselect(left, right, k_smallest):
        if left == right:
            return arr[left]
        pivot_index = partition(left, right)
        if k_smallest == pivot_index:
            return arr[k_smallest]
        elif k_smallest < pivot_index:
            return quickselect(left, pivot_index - 1, k_smallest)
        else:
            return quickselect(pivot_index + 1, right, k_smallest)

    def partition(left, right):
        pivot = arr[right]
        i = left
        for j in range(left, right):
            if arr[j] < pivot:
                (arr[i], arr[j]) = (arr[j], arr[i])
                i += 1
        (arr[i], arr[right]) = (arr[right], arr[i])
        return i
    return quickselect(0, len(arr) - 1, k - 1).
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-10 09:35:09 - Error: .
 Solution: import re
def text_match_zero_one(text):
    if not isinstance(text, str):
        return False
    pattern = '^a(b+)$'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 09:35:23 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for t in nums:
        if not t:
            averages.append(0)
        else:
            averages.append(sum(t) / len(t))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:36:08 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:36:15 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of its characters.
    
    Parameters:
    str1 (str): The input string to be converted.
    
    Returns:
    tuple: A tuple containing each character of the string.
    """
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 09:36:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.
    
    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.
    
    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:36:17 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = max(list1[i]) * max(list1[j])
            product2 = min(list1[i]) * min(list1[j])
            max_product = max(max_product, abs(product1), abs(product2))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 09:36:19 - Error: .
 Solution: def find_star_num(n):
    """
    Calculate the n-th star number.
    A star number is defined as the number of points in a star polygon with n points.
    The formula for the n-th star number is: S(n) = n * (6n - 6) / 2 + 1
    """
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:36:19 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 09:36:20 - Error: .
 Solution: def dif_Square(n):
    """
    Determine if the given number n can be expressed as the difference of two squares.
    
    A number can be expressed as the difference of two squares if:
    1. n is even, or
    2. n is odd and not equal to 2 (since 2 cannot be expressed as a difference of two squares)
    
    Parameters:
    n (int): The number to check.

    Returns:
    bool: True if n can be expressed as the difference of two squares, False otherwise.
    """
    if n < 0:
        return False
    return n != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 09:36:21 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        if isinstance(num, (int, float)):
            count[num] = count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:36:22 - Error: .
 Solution: def remove_nested(test_tup):
    """
    Remove nested tuples from the given tuple.
    
    Parameters:
    test_tup (tuple): The input tuple which may contain nested tuples.
    
    Returns:
    tuple: A new tuple with all nested tuples removed.
    """
    result = []

    def flatten(tup):
        for item in tup:
            if isinstance(item, tuple):
                flatten(item)
            else:
                result.append(item)
    flatten(test_tup)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-10 09:36:23 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:36:25 - Error: Both inputs must be strings representing complex numbers..
 Solution: import cmath
import re
def parse_complex(s):
    s = s.strip()
    pattern = '([+-]?\\d*\\.?\\d+)([+-]?\\d*\\.?\\d*)j'
    match = re.match(pattern, s)
    if not match:
        raise ValueError(f'Invalid complex number format: {s}')
    real_part = float(match.group(1))
    imaginary_part = float(match.group(2))
    return complex(real_part, imaginary_part)
def angle_complex(a, b):
    if isinstance(a, str) and isinstance(b, str):
        z1 = parse_complex(a)
        z2 = parse_complex(b)
        angle_z1 = cmath.phase(z1)
        angle_z2 = cmath.phase(z2)
        return (angle_z1, angle_z2)
    else:
        raise ValueError('Both inputs must be strings representing complex numbers.').
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:36:25 - Error: .
 Solution: def remove_odd(str1):
    if not str1:
        return str1
    even_indexed_chars = [str1[i] for i in range(len(str1)) if i % 2 == 0]
    return ''.join(even_indexed_chars).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:36:28 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:36:34 - Error: .
 Solution: def Diff(li1, li2):
    """
    Returns the difference between two lists.
    
    Parameters:
    li1 (list): The first list from which to subtract elements.
    li2 (list): The second list containing elements to be removed from the first list.
    
    Returns:
    list: A new list containing elements from li1 that are not in li2.
    """
    set_li2 = set(li2)
    return [item for item in li1 if item not in set_li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:36:37 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    if equal_count == 3:
        return 3
    elif equal_count == 2:
        return 2
    else:
        return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 09:36:41 - Error: must be real number, not str.
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = sum((1.0 / i for i in range(1, n)))
    return f'H({n - 1}) = {harmonic_sum_value:.6f}'.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:36:43 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 09:36:45 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = A[i - 1][1]
        for j in range(1, i + 1):
            A[i][j] = (i - j + 1) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m] if 0 <= m <= n else 0.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 09:38:07 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Calculate the angle (in radians) of the complex number z.
    
    Parameters:
    z (complex): The complex number.
    
    Returns:
    float: The angle in radians of the complex number.
    """
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:38:19 - Error: .
 Solution: def snake_to_camel(word):
    """
    Convert a snake_case string to camelCase string.
    
    Args:
    word (str): The input string in snake_case format.
    
    Returns:
    str: The converted string in camelCase format.
    """
    if not isinstance(word, str):
        raise ValueError('Input must be a string')
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:38:21 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:38:26 - Error: .
 Solution: def find_star_num(n):
    """
    Calculate the n-th star number.
    
    A star number is defined as:
    S(n) = 6 * n * (n - 1) / 2 + 1 = 3 * n * (n - 1) + 1
    
    Parameters:
    n (int): The index of the star number to find (n >= 0).
    
    Returns:
    int: The n-th star number.
    """
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    star_number = 6 * n * (n - 1) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:38:29 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(None)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:38:29 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of characters.

    Parameters:
    str1 (str): The input string to be converted.

    Returns:
    tuple: A tuple containing the characters of the input string.
    """
    if str1 is None:
        return ()
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 09:38:30 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-10 09:38:31 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    """
    Function to find the item with maximum frequency in a given list.
    
    Args:
    nums (list): A list of elements (can be of any type).
    
    Returns:
    tuple: A tuple containing the item with maximum frequency and its count.
           If the input list is empty, returns (None, 0).
    """
    if not nums:
        return (None, 0)
    frequency_map = defaultdict(int)
    for num in nums:
        frequency_map[num] += 1
    max_item = max(frequency_map.items(), key=lambda x: (x[1], x[0]))
    return max_item.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-10 09:38:33 - Error: .
 Solution: def dif_Square(n):
    """
    Check if the given number n can be represented as the difference of two squares.
    
    The difference of two squares can be expressed as:
    a^2 - b^2 = (a - b)(a + b)
    
    For n to be expressible as the difference of two squares:
    - If n is even, it can always be expressed as the difference of two squares.
    - If n is odd, it can only be expressed if n is not of the form 4k + 2.
    
    Args:
    n (int): The number to check.
    
    Returns:
    bool: True if n can be represented as the difference of two squares, False otherwise.
    """
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    return n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 09:38:33 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.
    
    The harmonic sum H(k) is defined as the sum of the reciprocals of the first k natural numbers:
    H(k) = 1 + 1/2 + 1/3 + ... + 1/k
    
    Parameters:
    n (int): The integer input to calculate the harmonic sum of n-1.
    
    Returns:
    float: The harmonic sum of n-1. Returns 0 if n <= 1.
    """
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:38:35 - Error: .
 Solution: def extract_freq(test_list):
    """
    Extracts the number of unique tuples from the given list.

    Parameters:
    test_list (list): A list of tuples from which unique tuples are to be counted.

    Returns:
    int: The number of unique tuples in the list.
    """
    if not test_list:
        return 0
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-10 09:38:40 - Error: .
 Solution: def remove_odd(str1):
    """
    Remove characters from the input string that have odd indices.
    
    Parameters:
    str1 (str): The input string from which to remove odd-indexed characters.
    
    Returns:
    str: A new string with characters at odd indices removed.
    """
    if not str1:
        return ''
    result = ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0])
    return result.
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:38:41 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)

    def binary_search(arr, low, high):
        if high < low:
            return 0
        if high == low:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid + 1] < arr[mid]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[high] >= arr[mid]:
            return binary_search(arr, low, mid - 1)
        return binary_search(arr, mid + 1, high)
    rotation_index = binary_search(arr, 0, n - 1)
    return rotation_index.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:38:42 - Error: name 'defaultdict' is not defined.
 Solution: def count_Substrings(s):
    count = 0
    n = len(s)
    if n == 0:
        return 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 09:38:44 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j - 1] + 1
            else:
                eulerian[i][j] = (i - j) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 09:38:47 - Error: words must be a list of strings..
 Solution: def long_words(n, words):
    """
    This function returns a list of words that are longer than n characters from the given list of words.
    
    Parameters:
    n (int): The minimum length of words to be considered.
    words (list of str): The list of words to filter.
    
    Returns:
    list of str: A list containing words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer.')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-10 09:38:53 - Error: .
 Solution: def Diff(li1, li2):
    """
    Calculate the difference between two lists.
    
    The difference is defined as the elements that are in li1 but not in li2.
    
    Parameters:
    li1 (list): The first list from which to subtract elements.
    li2 (list): The second list containing elements to be removed from li1.
    
    Returns:
    list: A list containing elements that are in li1 but not in li2.
    """
    set_li2 = set(li2)
    difference = [item for item in li1 if item not in set_li2]
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:38:58 - Error: .
 Solution: def find_length(string):
    if not string:
        return 0
    transformed = [1 if char == '0' else -1 for char in string]
    max_diff = 0
    current_sum = 0
    sum_index_map = {0: -1}
    for (index, value) in enumerate(transformed):
        current_sum += value
        if current_sum not in sum_index_map:
            sum_index_map[current_sum] = index
        max_diff = max(max_diff, index - sum_index_map[current_sum])
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-10 09:39:01 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    frequency = {}
    for num in arr:
        frequency[num] = frequency.get(num, 0) + 1
    return sum((num for (num, count) in frequency.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:40:17 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 09:40:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.
    
    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.
    
    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 09:40:21 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 09:40:25 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 09:40:30 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 09:40:30 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        avg = sum(tup) / len(tup) if len(tup) > 0 else 0
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 09:40:51 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 09:40:58 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 09:41:00 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 09:41:03 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    return list(set1 - set2).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 09:41:04 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (2 * n - 2) // 6 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 09:41:05 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 09:41:15 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 09:41:16 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(n + 1):
            if j == 0:
                A[i][j] = (i + 1) * A[i - 1][j]
            elif j == i:
                A[i][j] = (i + 1) * A[i - 1][j - 1]
            else:
                A[i][j] = j * A[i - 1][j] + (i - j + 1) * A[i - 1][j - 1]
    return A[n][m] if 0 <= m <= n else 0.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 10:42:49 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-10 10:42:50 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 10:42:50 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 10:42:50 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 1:
        return True
    for k in range(1, n):
        if (n - k * (k + 1) // 2) % k == 0 and (n - k * (k + 1) // 2) // k > 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 10:42:50 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 10:42:50 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-10 10:42:52 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 10:42:53 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 10:42:54 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 10:42:54 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-10 10:42:54 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 10:42:54 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-10 10:42:54 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-10 10:42:54 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 10:42:54 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 10:42:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 10:42:54 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 10:42:54 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 10:42:54 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-10 10:42:55 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 10:42:57 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 10:43:00 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 10:43:01 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 10:43:01 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-10 10:43:22 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 10:43:30 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-10 10:43:32 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 10:43:32 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 10:43:34 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 10:52:53 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-10 10:52:54 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 10:52:54 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-10 10:52:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 10:52:55 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return []
    polite_numbers = []
    count = 0
    num = 1
    while count < n:
        if num % 2 == 1:
            polite_numbers.append(num)
            count += 1
        else:
            for start in range(1, num // 2 + 1):
                total = 0
                for i in range(start, num // 2 + 1):
                    total += i
                    if total == num:
                        break
                    if total > num:
                        break
                if total == num:
                    break
            else:
                polite_numbers.append(num)
                count += 1
        num += 1
    return polite_numbers[-1]
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 10:52:55 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 10:52:55 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 10:52:56 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 10:52:56 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-10 10:52:56 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 10:52:56 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 10:52:56 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-10 10:52:57 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 10:52:57 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 10:52:58 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-10 10:52:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 10:52:59 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 10:53:00 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 10:53:00 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-10 10:53:00 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 10:53:00 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 10:53:01 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 10:53:02 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-10 11:02:25 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:02:26 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:19:53 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:19:55 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:19:57 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if n == 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        A[i][0] = 1 if i == 0 else 0
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            A[i][j] = (i - j + 1) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:19:58 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:19:59 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:20:00 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:20:02 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:20:04 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-10 11:20:05 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:20:05 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:20:08 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:20:51 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    top_area = math.pi * r ** 2
    bottom_area = math.pi * r ** 2
    total_surface_area = lateral_area + top_area + bottom_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:21:07 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:22:17 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:22:17 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:22:21 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:22:21 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:22:31 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:22:34 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:22:34 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:22:36 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:22:39 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-10 11:22:41 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 0
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_area = lateral_area + 2 * base_area
    return total_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:22:41 - Error: Function find_length is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-10 11:22:42 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:22:50 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:22:51 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:22:55 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (n * 6 - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:22:57 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:23:09 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:23:15 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] <= arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:34:37 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:34:40 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-10 11:34:41 - Error: List must contain at least two distinct numbers..
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        raise ValueError('List must contain at least two distinct numbers.')
    smallest = float('inf')
    second_smallest = float('inf')
    for number in numbers:
        if number < smallest:
            second_smallest = smallest
            smallest = number
        elif smallest < number < second_smallest:
            second_smallest = number
    if second_smallest == float('inf'):
        raise ValueError('List must contain at least two distinct numbers.')
    return second_smallest.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-10 11:34:42 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:34:42 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:34:50 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:34:52 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0)
            continue
        total = 0
        count = 0
        for value in inner_tuple:
            if isinstance(value, (int, float)):
                total += value
                count += 1
        if count == 0:
            averages.append(0)
        else:
            averages.append(total / count)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:34:53 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:34:58 - Error: Function count_Substrings is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:34:58 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-10 11:35:04 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:35:05 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-10 11:35:09 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n > 0 and m == 0:
        return 0
    if n == m:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:35:12 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:35:14 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    if len(arr) == 1:
        return 0
    (low, high) = (0, len(arr) - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:35:17 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    k = n - 1
    if k == 0:
        return 0.0
    return sum((1 / i for i in range(1, k + 1))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:35:17 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:35:18 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-10 11:35:20 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    if '' in parts:
        raise ValueError('Invalid snake case string: contains leading, trailing, or consecutive underscores.')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:35:25 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:35:25 - Error: .
 Solution: def remove_nested(test_tup):
    result = []

    def helper(tup):
        for item in tup:
            if isinstance(item, tuple):
                helper(item)
            else:
                result.append(item)
    helper(test_tup)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-10 11:35:33 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    non_repeated_sum = sum((num for (num, freq) in count.items() if freq == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:35:33 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = 2 * math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = base_area + lateral_area
    return total_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:35:34 - Error: Function Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:35:48 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-10 11:37:25 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:37:29 - Error: Function swap_List is not defined in the solution..
 Solution: .
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-10 11:37:31 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:37:38 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:37:41 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:37:42 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:37:43 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-10 11:37:44 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-10 11:37:51 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:37:52 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:37:54 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:37:56 - Error: Function Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:38:09 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:38:09 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:38:11 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-10 11:38:12 - Error: Function count_Substrings is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:38:17 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-10 11:38:17 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-10 11:38:23 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:38:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:38:23 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:38:38 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:38:41 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:38:44 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] <= arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:38:46 - Error: .
 Solution: def snake_to_camel(word):
    if not word or word.startswith('_') or word.endswith('_') or ('__' in word):
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:39:47 - Error: Function surfacearea_cylinder is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:40:36 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:40:37 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:40:38 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:40:41 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:40:43 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    n = len(s)
    count = 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:40:46 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 11:40:46 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 2] + 2 * dp[i - 1]
    return dp[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-10 11:40:50 - Error: .
 Solution: def is_polite(n):
    if n is None or n < 1:
        return 'Invalid input. Please provide a positive integer.'
    polite_numbers = []
    count = 0
    num = 1
    while count < n:
        if num == 1 or num % 2 == 1:
            polite_numbers.append(num)
            count += 1
        else:
            for start in range(1, num // 2 + 1):
                total = 0
                for i in range(start, num // 2 + 1):
                    total += i
                    if total == num:
                        break
                    if total > num:
                        break
                if total == num:
                    break
            else:
                polite_numbers.append(num)
                count += 1
        num += 1
    return polite_numbers[-1].
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:40:51 - Error: .
 Solution: def find_star_num(n):
    if n is None:
        raise ValueError('Input cannot be None')
    if n < 1:
        raise ValueError('Input must be a positive integer')
    return (6 * n * n - 6 * n + 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:40:53 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:40:58 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numeric values.')
    if r <= 0 or h <= 0:
        raise ValueError('Both radius and height must be greater than zero.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_surface_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:41:01 - Error: .
 Solution: import cmath
def angle_complex(a=0, b=0):
    if a == 0 and b == 0:
        raise ValueError('Undefined angle for the complex number (0, 0).')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:41:08 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] > arr[next_mid]:
            return next_mid
        if arr[mid] < arr[prev_mid]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:41:14 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:41:19 - Error: .
 Solution: def harmonic_sum(n):
    if n is None:
        raise ValueError('Input cannot be None')
    if n < 0:
        raise ValueError('Input cannot be negative')
    if n == 0:
        return 0.0
    if n == 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:41:20 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:41:41 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0:
        return 0
    if m > n:
        return 0
    if n == 0 and m > 0:
        return 0
    if n == 0 and m == 0:
        return 1
    if n > 0 and m == 0:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1] if j > 0 else (i - j) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:43:20 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:43:21 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-10 11:43:22 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-10 11:43:26 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-10 11:43:29 - Error: Function count_Substrings is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:43:36 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:43:39 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:43:44 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:43:50 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-10 11:43:50 - Error: .
 Solution: def sum_div(number):
    if not isinstance(number, int) or number is None:
        raise ValueError('Input must be a non-negative integer.')
    if number == 0:
        return 0
    number = abs(number)
    total = 0
    for i in range(1, int(number ** 0.5) + 1):
        if number % i == 0:
            total += i
            if i != number // i:
                total += number // i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-10 11:43:51 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:43:53 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_abs_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            products = [list1[i][0] * list1[j][0], list1[i][0] * list1[j][1], list1[i][1] * list1[j][0], list1[i][1] * list1[j][1]]
            max_abs_product = max(max_abs_product, *map(abs, products))
    return max_abs_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:43:56 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:43:57 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = 2 * math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = base_area + lateral_area
    return total_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:44:02 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:44:03 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:44:04 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        return None
    angle = cmath.phase(complex(a, b))
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:44:08 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:44:08 - Error: Function Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:44:14 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    non_repeated_sum = sum((key for (key, value) in count.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:44:18 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-10 11:44:19 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    k = n - 1
    if k == 0:
        return 0.0
    harmonic_sum_value = sum((1 / i for i in range(1, k + 1)))
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:44:22 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:44:24 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:45:28 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:45:32 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:45:41 - Error: .
 Solution: def find_sum(arr):
    unique_sum = sum((x for x in arr if arr.count(x) == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:45:41 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:45:41 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:45:46 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * 3.14159 * r * h + 2 * 3.14159 * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:45:47 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [round(sum(inner_tuple) / len(inner_tuple), 2) if inner_tuple else 0.0 for inner_tuple in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:45:52 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:45:54 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:46:00 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:46:08 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:46:37 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 0
    seen_elements = set()
    left = 0
    for right in range(len(lst)):
        if isinstance(lst[right], list):
            left = right + 1
            seen_elements.clear()
        else:
            while lst[right] in seen_elements:
                seen_elements.remove(lst[left])
                left += 1
            seen_elements.add(lst[right])
            current_length = right - left + 1
            max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:48:01 - Error: Function _sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert _sum([1, 2, 3]) == 6
    assert _sum([15, 12, 13, 10]) == 50
    assert _sum([0, 1, 2]) == 3

2025-10-10 11:48:03 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:48:06 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-10 11:48:06 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:48:08 - Error: Function swap_List is not defined in the solution..
 Solution: .
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-10 11:48:10 - Error: Function test_three_equal is not defined in the solution..
 Solution: .
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:48:10 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-10 11:48:10 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:48:11 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:48:12 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-10 11:48:14 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:48:16 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:48:17 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-10 11:48:26 - Error: .
 Solution: from collections import Counter
def Diff(li1, li2):
    count_li2 = Counter(li2)
    result = []
    for item in li1:
        if count_li2[item] > 0:
            count_li2[item] -= 1
        else:
            result.append(item)
    return result.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:48:31 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:48:32 - Error: .
 Solution: def string_to_tuple(str1: str) -> tuple:
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 11:48:32 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:48:32 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:48:32 - Error: Function dif_Square is not defined in the solution..
 Solution: .
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:48:36 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:48:38 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-10 11:48:41 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = [w for w in word.split('_') if w]
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:48:43 - Error: Function count_Substrings is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:48:49 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('The angle of the complex number 0 + 0j is undefined.')
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:48:58 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            if arr[low] > arr[low + 1]:
                return low + 1
            low += 1
            if arr[high] < arr[high - 1]:
                return high
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:49:00 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple):
        raise TypeError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise TypeError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(None)
        elif all((isinstance(x, (int, float)) for x in inner_tuple)):
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
        else:
            raise ValueError('All elements in the inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:49:02 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('n must be a positive integer (n >= 1).')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:49:03 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    if r == 0 or h == 0:
        return 0.0
    surface_area = 2 * math.pi * r * (h + r)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:50:01 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:50:02 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:50:04 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:50:12 - Error: .
 Solution: def test_three_equal(x, y, z):
    return len(set([x, y, z])) * (3 if len(set([x, y, z])) == 1 else 0).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:50:17 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:50:18 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:50:19 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:50:21 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, cnt) in count.items() if cnt == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:50:27 - Error: .
 Solution: from collections import deque
import heapq
def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 11:50:29 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (n * 2 - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:50:35 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    current_diff = 0
    diff_map = {0: -1}
    for (i, char) in enumerate(string):
        current_diff += 1 if char == '0' else -1
        if current_diff in diff_map:
            max_diff = max(max_diff, i - diff_map[current_diff])
        else:
            diff_map[current_diff] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-10 11:50:36 - Error: 'int' object is not subscriptable.
 Solution: import cmath
def angle_complex(a, b):
    complex_a = complex(a[0], a[1])
    complex_b = complex(b[0], b[1])
    angle_a = cmath.phase(complex_a)
    angle_b = cmath.phase(complex_b)
    return angle_b - angle_a.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:50:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_area = lateral_area + 2 * base_area
    return total_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:50:43 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    max_pair = None
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
                max_pair = (list1[i], list1[j])
    return (max_pair, max_product).
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:50:45 - Error: .
 Solution: def count_rotation(arr):

    def binary_search(arr, low, high):
        if high < low:
            return 0
        if high == low:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] >= arr[mid]:
            return binary_search(arr, low, mid - 1)
        return binary_search(arr, mid + 1, high)
    n = len(arr)
    return binary_search(arr, 0, n - 1).
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:50:47 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    eulerian = [[0] * (m + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(m + 1):
            eulerian[i][j] = (i - 1) * (eulerian[i - 1][j] + (j > 0) * eulerian[i - 1][j - 1])
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:52:09 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-10 11:52:10 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:52:11 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:52:14 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-10 11:52:14 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:52:16 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-10 11:52:19 - Error: Function swap_List is not defined in the solution..
 Solution: .
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-10 11:52:19 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 11:52:19 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-10 11:52:20 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:52:24 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-10 11:52:43 - Error: Function _sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert _sum([1, 2, 3]) == 6
    assert _sum([15, 12, 13, 10]) == 50
    assert _sum([0, 1, 2]) == 3

2025-10-10 11:52:44 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:52:47 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:52:48 - Error: Function Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:52:48 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not nums:
        return []
    return [sum(tup) / len(tup) for tup in nums if len(tup) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:52:49 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:52:50 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0:
        return 0
    if n == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        prev2 = prev1
        prev1 = current
    return current.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-10 11:52:52 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = [w for w in word.split('_') if w]
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:52:52 - Error: Function count_Substrings is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:52:54 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1 and isinstance(key, (int, float))))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:52:59 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:52:59 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-10 11:53:00 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-10 11:53:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:53:29 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:53:36 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:54:19 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    if '_' not in word:
        return word[0].lower() + word[1:]
    (first_segment, rest_of_word) = word.split('_', 1)
    camel_case_segment = first_segment.lower().capitalize()
    return camel_case_segment + snake_to_camel(rest_of_word).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:54:25 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:54:26 - Error: .
 Solution: def remove_odd(str1, index=0):
    if index >= len(str1):
        return ''
    return (str1[index] if index % 2 == 0 else '') + remove_odd(str1, index + 1).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:54:26 - Error: Function find_length is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-10 11:54:27 - Error: .
 Solution: def swap_List(newList):

    def recursive_swap(lst):
        if len(lst) <= 1:
            return lst
        if len(lst) == 2:
            return [lst[1], lst[0]]
        return [lst[-1]] + recursive_swap(lst[1:-1]) + [lst[0]]
    return recursive_swap(newList).
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-10 11:54:28 - Error: .
 Solution: def is_divisible_by_11(n):
    n = abs(n)
    if n < 10:
        return n == 0 or n == 11
    last_digit = n % 10
    remaining_number = n // 10
    if len(str(n)) % 2 == 0:
        return is_divisible_by_11(remaining_number) - last_digit == 0
    else:
        return is_divisible_by_11(remaining_number) + last_digit == 0
def is_Diff(n):
    return is_divisible_by_11(n).
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:54:36 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:54:39 - Error: Function _sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert _sum([1, 2, 3]) == 6
    assert _sum([15, 12, 13, 10]) == 50
    assert _sum([0, 1, 2]) == 3

2025-10-10 11:54:42 - Error: .
 Solution: def average_tuple(nums):

    def helper(tup, index):
        if index == len(tup):
            return []
        current_avg = sum(tup[index]) / len(tup[index])
        return [current_avg] + helper(tup, index + 1)
    return helper(nums, 0).
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:54:46 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:54:47 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2))
li1 = [10, 15, 20, 25, 30, 35, 40]
li2 = [25, 40, 35].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:54:53 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 0
    if h == 0:
        return 2 * 3.14159 * r * r
    return 2 * 3.14159 * r * r + 2 * 3.14159 * r * surfacearea_cylinder(r, h - 1).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:54:58 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if isinstance(a, complex):
        return cmath.phase(a)
    if isinstance(b, complex):
        return cmath.phase(b)
    if a == 0 and b == 0:
        raise ValueError('The angle of the complex number 0 + 0j is undefined.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:55:03 - Error: .
 Solution: def find_star_num(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 0:
        return 0
    if n == 1:
        return 1
    result = find_star_num(n - 1, memo) + 6 * (n - 1)
    memo[n] = result
    return result.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:55:06 - Error: .
 Solution: def max_product_tuple(list1):

    def helper(index):
        if index >= len(list1) - 1:
            return 0
        current_product = abs(list1[index][0] * list1[index][1])
        next_max = helper(index + 1)
        return max(current_product, next_max)
    return helper(0).
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:55:10 - Error: count_rotation() takes 1 positional argument but 3 were given.
 Solution: def count_rotation(arr, low, high):
    if low > high:
        return 0
    if low == high:
        return low
    mid = (low + high) // 2
    if mid < high and arr[mid] > arr[mid + 1]:
        return mid + 1
    if mid > low and arr[mid] < arr[mid - 1]:
        return mid
    if arr[low] >= arr[mid]:
        return count_rotation(arr, low, mid - 1)
    return count_rotation(arr, mid + 1, high)
def count_rotation(arr):
    return count_rotation(arr, 0, len(arr) - 1).
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:55:11 - Error: .
 Solution: def eulerian_num(n, m, memo=None):
    if memo is None:
        memo = {}
    if (n, m) in memo:
        return memo[n, m]
    if n == 0 and m == 0:
        return 1
    if n == 0:
        return 0
    if m == 0:
        return 0
    result = (n - m) * eulerian_num(n - 1, m - 1, memo) + (m + 1) * eulerian_num(n - 1, m, memo)
    memo[n, m] = result
    return result.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 11:56:17 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = [w for w in word.split('_') if w]
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:56:18 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 11:56:18 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:56:25 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:56:28 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:56:43 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:56:50 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z.real == 0 and z.imag == 0:
        return float('nan')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:56:50 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    surface_area = lateral_surface_area + base_area
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 11:56:53 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    if not arr:
        return 0
    count = Counter(arr)
    unique_sum = sum((x for x in count if count[x] == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:56:57 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if arr[0] <= arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 11:56:59 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:57:07 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return 3 * n * (n - 1) + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 11:57:07 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:57:20 - Error: .
 Solution: def Diff(li1, li2):
    unique_to_li1 = [item for item in li1 if item not in li2]
    unique_to_li2 = [item for item in li2 if item not in li1]
    return unique_to_li1 + unique_to_li2.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 11:58:34 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 11:58:42 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 11:58:43 - Error: .
 Solution: def square_Sum(n):
    return n * (n * n).
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-10 11:58:43 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 11:59:03 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    return words[0] + ''.join((w.capitalize() for w in words[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 11:59:09 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 11:59:14 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 11:59:19 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 11:59:20 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 11:59:24 - Error: .
 Solution: import math
def is_power_of_two(n):
    return n > 0 and n & n - 1 == 0
def is_polite(n):
    return not is_power_of_two(n).
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 11:59:30 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s: str) -> int:
    count = 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for (i, char) in enumerate(s):
        prefix_sum += int(char)
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 11:59:38 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            if len(list1[i]) != 2 or len(list1[j]) != 2:
                raise ValueError('Each element must be a tuple of two numbers.')
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][0] * list1[j][1])
            product3 = abs(list1[i][1] * list1[j][0])
            product4 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 11:59:49 - Error: .
 Solution: import cmath
import math
def angle_complex(a, b):
    if a == 0 and b == 0:
        return None
    z = complex(a, b)
    angle_radians = cmath.phase(z)
    angle_degrees = math.degrees(angle_radians)
    return angle_degrees.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 11:59:51 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    element_count = {}
    for x in arr:
        if not isinstance(x, int):
            raise ValueError('All elements in the list must be integers.')
        element_count[x] = element_count.get(x, 0) + 1
    return sum((x for x in element_count if element_count[x] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 11:59:54 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    if r is None or h is None:
        raise ValueError('Radius and height must not be None.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * 3.141592653589793 * r * (h + r)
    return surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 12:00:04 - Error: .
 Solution: def eulerian_num(n, m):
    if not isinstance(n, int) or not isinstance(m, int):
        raise ValueError('Both n and m must be integers.')
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j - 1]
            else:
                eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 12:00:19 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (left, right) = (0, n - 1)
    if arr[left] < arr[right]:
        return 0
    while left <= right:
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[left] == arr[mid] == arr[right]:
            left += 1
            right -= 1
        elif arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 12:01:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    return sum([x == y, y == z, x == z]).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 12:01:57 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 12:02:01 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 12:02:04 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s: str) -> int:
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    for i in range(n):
        prefix_sum += int(s[i])
        if prefix_sum == i + 1:
            count += 1
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 12:02:05 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    return words[0] + ''.join((w.capitalize() for w in words[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 12:02:24 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 12:02:25 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 12:02:27 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1).difference(set(li2))).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 12:02:39 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * 3.141592653589793 * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 12:02:42 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 12:02:49 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    return sum((key for (key, value) in count.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 12:03:07 - Error: str must be a list or tuple.
 Solution: def long_words(n, str):
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer')
    if not isinstance(str, (list, tuple)):
        raise ValueError('str must be a list or tuple')
    return [word for word in str if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-10 12:03:14 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):
    if not isinstance(startnum, int) or not isinstance(endnum, int):
        raise ValueError('Both startnum and endnum must be integers.')
    if startnum > endnum:
        return []

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    return [num for num in range(startnum, endnum + 1) if num >= 0 and is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-10 12:03:17 - Error: Both inputs must be numbers (int or float)..
 Solution: def angle_complex(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError('Both inputs must be numbers (int or float).')
    z = complex(a, b)
    if z == 0:
        raise ValueError('Angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 12:03:20 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0)
        elif all((isinstance(x, (int, float)) for x in inner_tuple)):
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
        else:
            raise ValueError('All elements in the inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 12:03:37 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 12:03:37 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n <= 1:
        raise ValueError('Input must be a positive integer greater than 1.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 12:03:46 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 12:04:41 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 12:04:42 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-10 12:04:44 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 12:04:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 12:04:48 - Error: .
 Solution: def is_undulating(n):
    str_n = str(abs(n))
    if len(str_n) < 2:
        return True
    prev_digit = int(str_n[0])
    current_state = None
    for i in range(1, len(str_n)):
        current_digit = int(str_n[i])
        if current_digit > prev_digit:
            if current_state == 'up':
                return False
            current_state = 'up'
        elif current_digit < prev_digit:
            if current_state == 'down':
                return False
            current_state = 'down'
        prev_digit = current_digit
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-10 12:04:48 - Error: .
 Solution: def find_star_num(n):
    if n <= 0:
        return 0
    return n * (2 * n - 1) * 3 // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 12:04:49 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 12:04:52 - Error: name 'heapq' is not defined.
 Solution: def large_product(nums1, nums2, N):
    if N <= 0:
        return []
    if not nums1 or not nums2:
        return []
    min_heap = []
    for num1 in nums1:
        for num2 in nums2:
            product = num1 * num2
            if len(min_heap) < N:
                heapq.heappush(min_heap, product)
            elif product > min_heap[0]:
                heapq.heappushpop(min_heap, product)
    return sorted(min_heap, reverse=True)[:N].
 Test: def check():
    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]
    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]
    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]

2025-10-10 12:04:54 - Error: .
 Solution: def find_sum(arr):
    unique_sum = sum((x for x in arr if arr.count(x) == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 12:04:54 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * 3.14159 * r * h + 2 * 3.14159 * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 12:05:05 - Error: name 'heapq' is not defined.
 Solution: def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    result = []
    for j in range(min(k, len(nums2))):
        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append([nums1[i], nums2[j]])
        k -= 1
        if i + 1 < len(nums1):
            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-10 12:05:07 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 12:05:08 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 12:05:10 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-10 12:05:17 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 12:05:21 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 12:05:26 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_abs_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = max(list1[i]) * max(list1[j])
            product2 = min(list1[i]) * min(list1[j])
            max_abs_product = max(max_abs_product, abs(product1), abs(product2))
    return max_abs_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 12:05:27 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 1
        A[i][i] = 1
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 12:07:01 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 12:07:06 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-10 12:07:09 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-10 12:07:10 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    return ''.join((w.capitalize() if i > 0 else w for (i, w) in enumerate(word.split('_')))).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 12:07:13 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s: str) -> int:
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    for i in range(n):
        prefix_sum += int(s[i])
        if prefix_sum == i + 1:
            count += 1
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-10 12:07:15 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 12:07:37 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            continue
        avg = sum(inner_tuple) / len(inner_tuple)
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 12:07:53 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-10 12:08:02 - Error: Both real and imaginary parts must be numeric (int or float)..
 Solution: import cmath
import math
def angle_complex(real_part, imaginary_part):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    real_part (int, float): The real part of the complex number.
    imaginary_part (int, float): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number.

    Raises:
    TypeError: If either real_part or imaginary_part is not a numeric type.
    ValueError: If the complex number is 0 + 0i (angle is undefined).
    """
    if not isinstance(real_part, (int, float)) or not isinstance(imaginary_part, (int, float)):
        raise TypeError('Both real and imaginary parts must be numeric (int or float).')
    if real_part == 0 and imaginary_part == 0:
        raise ValueError('Angle is undefined for the complex number 0 + 0i.')
    if math.isinf(real_part) or math.isinf(imaginary_part) or math.isnan(real_part) or math.isnan(imaginary_part):
        raise ValueError('Inputs must be finite numbers.')
    angle = cmath.phase(complex(real_part, imaginary_part))
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 12:08:12 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 12:08:27 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return None
    max_abs_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            tuple1 = list1[i]
            tuple2 = list1[j]
            if isinstance(tuple1, tuple) and len(tuple1) == 2 and isinstance(tuple2, tuple) and (len(tuple2) == 2) and all((isinstance(x, (int, float)) for x in tuple1 + tuple2)):
                products = [tuple1[0] * tuple2[0], tuple1[0] * tuple2[1], tuple1[1] * tuple2[0], tuple1[1] * tuple2[1]]
                current_max = max((abs(p) for p in products))
                max_abs_product = max(max_abs_product, current_max)
    return max_abs_product if max_abs_product != float('-inf') else None.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-10 12:08:33 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    element_count = {}
    for x in arr:
        if isinstance(x, int):
            element_count[x] = element_count.get(x, 0) + 1
    return sum((x for x in element_count if element_count[x] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 12:08:35 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (h + r)
    return surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 12:08:43 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    set_li2 = set(li2)
    unique_to_li1 = [item for item in li1 if item not in set_li2]
    unique_to_li2 = [item for item in li2 if item not in li1]
    return unique_to_li1 + unique_to_li2.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 12:08:49 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.

    Parameters:
    n (int): A positive integer greater than 1.

    Returns:
    float: The harmonic sum of integers from 1 to n-1.

    Raises:
    TypeError: If n is not an integer.
    ValueError: If n is not greater than 1.
    """
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n <= 1:
        raise ValueError('Input must be a positive integer greater than 1.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 12:08:55 - Error: .
 Solution: def count_rotation(arr):
    if not isinstance(arr, list) or any((not isinstance(x, (int, float)) for x in arr)):
        raise ValueError('Input must be a list of numbers.')
    n = len(arr)
    if n == 0:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            if arr[low] > arr[low + 1]:
                return low + 1
            low += 1
            if arr[high] < arr[high - 1]:
                return high
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 12:10:56 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-10 12:10:57 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-10 12:11:06 - Error: .
 Solution: def snake_to_camel(word):
    if not word or word == '_':
        return ''
    words = word.split('_')
    words = [w for w in words if w]
    if not words:
        return ''
    camel_case = words[0].lower() + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-10 12:11:09 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-10 12:11:17 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    products = [test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)]
    return tuple(products).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-10 12:11:17 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    if not arr:
        return 0
    element_count = Counter(arr)
    unique_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-10 12:11:19 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-10 12:11:30 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m >= n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j + 1) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-10 12:11:39 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        next_mid = (mid + 1) % len(arr)
        prev_mid = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-10 12:11:39 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-10 12:11:44 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-10 12:11:44 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-10 12:11:49 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return 1 if n == 0 else 3 * n * (n - 1) + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-10 12:11:50 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-10 12:12:19 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count_0_str1 = str1.count('0')
    count_1_str1 = str1.count('1')
    count_0_str2 = str2.count('0')
    count_1_str2 = str2.count('1')
    if count_0_str1 != count_0_str2 or count_1_str1 != count_1_str2:
        return -1
    mismatch_0 = 0
    mismatch_1 = 0
    for i in range(len(str1)):
        if str1[i] == '0' and str2[i] == '1':
            mismatch_0 += 1
        elif str1[i] == '1' and str2[i] == '0':
            mismatch_1 += 1
    return max(mismatch_0, mismatch_1).
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-10 12:12:33 - Error: .
 Solution: def upper_ctr(s: str) -> int:
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-10 12:12:34 - Error: Input must be a string.
 Solution: def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    result = []
    skip = 0
    for char in items:
        if char == '(':
            skip += 1
        elif char == ')':
            skip -= 1
        elif skip == 0:
            result.append(char)
    return ''.join(result).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-10 12:12:35 - Error: .
 Solution: def merge(lst):
    first_elements = [sublist[0] for sublist in lst]
    second_elements = [sublist[1] for sublist in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-10 12:12:36 - Error: .
 Solution: def get_Char(strr):
    ascii_sum = sum((ord(char) for char in strr))
    result_index = ascii_sum % 26
    result_char = chr(result_index + ord('a')) if result_index != 0 else 'z'
    return result_char.
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-10 12:12:39 - Error: .
 Solution: def trim_tuple(test_list, K):
    result = []
    for tup in test_list:
        if len(tup) <= 2 * K:
            result.append(())
        else:
            trimmed = tup[K:len(tup) - K]
            result.append(trimmed)
    return result.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-10 12:12:42 - Error: concatenate_tuple() missing 1 required positional argument: 'delimiter'.
 Solution: def concatenate_tuple(test_tup, delimiter):
    if not test_tup:
        return ''
    return delimiter.join(map(str, test_tup)).
 Test: def check():
    assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
    assert concatenate_tuple(("QWE", "is", 4, "RTY") ) == 'QWE-is-4-RTY'
    assert concatenate_tuple(("ZEN", "is", 4, "OP") ) == 'ZEN-is-4-OP'

2025-10-10 12:12:43 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    return sum((a == b for (a, b) in zip(nums1, nums2))).
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-10 12:12:44 - Error: sum() missing 1 required positional argument: 'b'.
 Solution: def sum(a, b):

    def find_divisors(n):
        divisors = set()
        for i in range(1, int(n ** 0.5) + 1):
            if n % i == 0:
                divisors.add(i)
                divisors.add(n // i)
        return divisors
    if a == 0 and b == 0:
        return 0
    elif a == 0:
        return sum(find_divisors(abs(b)))
    elif b == 0:
        return sum(find_divisors(abs(a)))
    gcd_value = abs(a) if b == 0 else abs(b) if a == 0 else math.gcd(abs(a), abs(b))
    common_divisors = find_divisors(gcd_value)
    return sum(common_divisors).
 Test: def check():
    assert sum(10,15) == 6
    assert sum(100,150) == 93
    assert sum(4,6) == 3

2025-10-10 12:12:48 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [0] * n
    for i in range(n):
        dp[i] = arr[i]
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] * arr[i])
    return max(dp).
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-10 12:12:51 - Error: .
 Solution: def count_no_of_ways(n, k):
    if n == 0:
        return 1
    if k == 0:
        return 0
    if n == 1:
        return k
    if n == 2:
        return k * k
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = k
    dp[2] = k * k
    for i in range(3, n + 1):
        dp[i] = (k - 1) * dp[i - 1] + k * dp[i - 2]
    return dp[n].
 Test: def check():
    assert count_no_of_ways(2, 4) == 16
    assert count_no_of_ways(3, 2) == 6
    assert count_no_of_ways(4, 4) == 228

2025-10-10 12:12:51 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return int(''.join(sorted(digits)))
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-10 12:12:55 - Error: .
 Solution: def cal_sum(n):
    if n == 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 3 + 0
    (P0, P1) = (3, 0)
    total_sum = P0 + P1
    for i in range(2, n):
        Pn = P0 + P1
        total_sum += Pn
        (P0, P1) = (P1, Pn)
    return total_sum.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-10 12:12:56 - Error: .
 Solution: def check_value(d, n):
    if not d:
        return True
    return len(set(d.values())) == 1 and len(d) == n.
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-10 12:13:00 - Error: .
 Solution: import math
def polar_rect(radius, angle):
    if radius < 0:
        raise ValueError('Radius must be non-negative.')
    rect_x = radius * math.cos(angle)
    rect_y = radius * math.sin(angle)
    return (rect_x, rect_y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-10 12:13:01 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((word.capitalize() for word in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-10 12:13:06 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must be of the same length.')
    return tuple((a * b for (a, b) in zip(test_tup1, test_tup2)))
test_tup1 = (1, 2, 3)
test_tup2 = (4, 5, 6).
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-10 12:13:06 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    return sorted(nums_str, key=int).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-10 12:13:16 - Error: .
 Solution: def sum_of_digits(nums):
    return [sum((int(digit) for digit in str(abs(num)))) for num in nums].
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-10 12:13:16 - Error: Step length must be a positive number..
 Solution: def min_Jumps(steps, d):
    if not isinstance(steps, (int, float)) or steps <= 0:
        raise ValueError('Step length must be a positive number.')
    if not isinstance(d, (int, float)):
        raise ValueError('Destination must be a number.')
    distance = abs(d)
    jumps = (distance + steps - 1) // steps
    return jumps.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-10 12:13:18 - Error: .
 Solution: def count_vowels(test_str):
    vowels = set('aeiouAEIOU')
    count = 0
    length = len(test_str)
    for i in range(length):
        if i > 0 and test_str[i - 1] in vowels or (i < length - 1 and test_str[i + 1] in vowels):
            count += 1
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-10 12:13:18 - Error: .
 Solution: def re_arrange_array(arr, n):
    if n <= 0 or not arr:
        return arr
    n = min(n, len(arr))
    negatives = [arr[i] for i in range(n) if arr[i] < 0]
    positives = [arr[i] for i in range(n) if arr[i] >= 0]
    arr[:n] = negatives + positives
    return arr.
 Test: def check():
    assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]
    assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]
    assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]

2025-10-10 12:13:20 - Error: .
 Solution: def occurance_substring(text, pattern):
    if not text or not pattern:
        return None
    matches = [(m.start(), m.group()) for m in re.finditer(re.escape(pattern), text)]
    return matches if matches else None.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-10 12:13:26 - Error: .
 Solution: def get_total_number_of_sequences(m, n):
    if n == 1:
        return m
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for j in range(1, m + 1):
        dp[1][j] = 1
    for i in range(2, n + 1):
        for j in range(1, m + 1):
            for k in range((j + 1) // 2, j):
                dp[i][j] += dp[i - 1][k]
    return sum((dp[n][j] for j in range(1, m + 1))).
 Test: def check():
    assert get_total_number_of_sequences(10, 4) == 4
    assert get_total_number_of_sequences(5, 2) == 6
    assert get_total_number_of_sequences(16, 3) == 84

2025-10-10 12:13:26 - Error: name 'combinations' is not defined.
 Solution: def find_combinations(test_list):
    if not test_list:
        return []
    result = set()
    n = len(test_list)
    for r in range(1, n + 1):
        for combo in combinations(test_list, r):
            summed_tuple = tuple((sum(x) for x in zip(*combo)))
            result.add(summed_tuple)
    return sorted(result).
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-10 12:13:31 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    result = n | mask
    return result.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-10 12:13:34 - Error: .
 Solution: def factorial(num):
    if num == 0 or num == 1:
        return 1
    result = 1
    for i in range(2, num + 1):
        result *= i
    return result
def binomial_coefficient(n, k):
    if k > n or k < 0:
        return 0
    return factorial(n) // (factorial(k) * factorial(n - k))
def sum_Of_product(n):
    if n < 2:
        return 0
    total_sum = 0
    for k in range(n):
        C_n_k = binomial_coefficient(n, k)
        C_n_k_plus_1 = binomial_coefficient(n, k + 1)
        total_sum += C_n_k * C_n_k_plus_1
    return total_sum.
 Test: def check():
    assert sum_Of_product(3) == 15
    assert sum_Of_product(4) == 56
    assert sum_Of_product(1) == 1

2025-10-10 12:13:39 - Error: .
 Solution: def find_First_Missing(array, start=0, end=None):
    if end is None:
        end = len(array)
    for i in range(start, end):
        if array[i] != i + 1:
            return i + 1
    return end + 1.
 Test: def check():
    assert find_First_Missing([0,1,2,3]) == 4
    assert find_First_Missing([0,1,2,6,9]) == 3
    assert find_First_Missing([2,3,5,8,9]) == 0

2025-10-10 12:13:43 - Error: unsupported operand type(s) for +=: 'int' and 'list'.
 Solution: def Find_Min(lst):
    n = len(lst)
    if n == 0:
        return []
    min_length = float('inf')
    min_sublist = []
    for start in range(n):
        current_sum = 0
        for end in range(start, n):
            current_sum += lst[end]
            if current_sum < 0:
                current_length = end - start + 1
                if current_length < min_length:
                    min_length = current_length
                    min_sublist = lst[start:end + 1]
                break
    return min_sublist if min_length != float('inf') else [].
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-10 12:13:45 - Error: argument of type 'int' is not iterable.
 Solution: def check_K(test_tup, K):
    if not isinstance(K, tuple):
        K = (K,)
    for tup in test_tup:
        if any((k in tup for k in K)):
            return True
    return False.
 Test: def check():
    assert check_K((10, 4, 5, 6, 8), 6) == True
    assert check_K((1, 2, 3, 4, 5, 6), 7) == False
    assert check_K((7, 8, 9, 44, 11, 12), 11) == True

2025-10-10 12:13:46 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n <= 0:
        return False
    return True.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-10 12:13:46 - Error: .
 Solution: def merge_dictionaries_three(dict1, dict2, dict3):
    return {**dict1, **dict2, **dict3}.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-10 12:13:47 - Error: unsupported operand type(s) for +: 'int' and 'str'.
 Solution: def max_aggregate(stdata):
    if not stdata:
        return 0
    max_agg = 0
    for tup in stdata:
        if isinstance(tup, tuple) and tup:
            current_agg = sum(tup)
            max_agg = max(max_agg, current_agg)
    return max_agg.
 Test: def check():
    assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)
    assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)
    assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)

2025-10-10 12:13:50 - Error: .
 Solution: def find_Max_Num(arr):
    if not arr:
        return '0'
    str_arr = list(map(str, arr))
    str_arr.sort(key=lambda x: x * 10, reverse=True)
    largest_num = ''.join(str_arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-10 12:13:53 - Error: .
 Solution: def combinations_list(list1):

    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(list1)):
            backtrack(i + 1, path + [list1[i]])
    result = []
    backtrack(0, [])
    return result.
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-10 12:13:56 - Error: .
 Solution: def check_Consecutive(l):
    if len(l) < 2:
        return False
    unique_numbers = set(l)
    min_num = min(unique_numbers)
    max_num = max(unique_numbers)
    return max_num - min_num == len(unique_numbers) - 1.
 Test: def check():
    assert check_Consecutive([1,2,3,4,5]) == True
    assert check_Consecutive([1,2,3,5,6]) == False
    assert check_Consecutive([1,2,1]) == False

2025-10-10 12:14:00 - Error: .
 Solution: def common_element(list1, list2):
    set1 = set(list1)
    for element in list2:
        if element in set1:
            return True
    return False.
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-10 12:14:01 - Error: .
 Solution: def set_left_most_unset_bit(n):
    position = 0
    while position < 32 and n & 1 << 31 - position:
        position += 1
    return n | 1 << 31 - position if position < 32 else n.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-10 12:14:04 - Error: .
 Solution: def count_bidirectional(test_list):
    unique_pairs = set()
    for (a, b) in test_list:
        if a != b:
            normalized_pair = tuple(sorted((a, b)))
            unique_pairs.add(normalized_pair)
    return len(unique_pairs).
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-10 12:14:10 - Error: 1.
 Solution: import heapq
def expensive_items(items, n):
    if n <= 0 or not items:
        return []
    min_heap = []
    for item in items:
        cost = item[1]
        heapq.heappush(min_heap, (cost, item))
        if len(min_heap) > n:
            heapq.heappop(min_heap)
    return [item for (cost, item) in sorted(min_heap, key=lambda x: x[0], reverse=True)].
 Test: def check():
    assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]
    assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09}],2)==[{'name': 'Item-2', 'price': 555.22},{'name': 'Item-1', 'price': 101.1}]
    assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}],1)==[{'name': 'Item-2', 'price': 555.22}]

2025-10-10 12:14:12 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    if l > r:
        return False
    mask = (1 << r + 1) - 1 ^ (1 << l) - 1
    return n & mask == 0.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-10 12:14:14 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n < 1:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-10 12:14:17 - Error: name 'sys' is not defined.
 Solution: def tuple_size(tuple_list):
    if not isinstance(tuple_list, tuple):
        raise TypeError('Input must be a tuple')
    return sum(map(sys.getsizeof, tuple_list)) + sys.getsizeof(tuple_list).
 Test: def check():
    assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
    assert tuple_size((1, "Raju", 2, "Nikhil", 3, "Deepanshu") ) == sys.getsizeof((1, "Raju", 2, "Nikhil", 3, "Deepanshu"))
    assert tuple_size(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf"))  ) == sys.getsizeof(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf")))

2025-10-10 12:14:18 - Error: .
 Solution: import re
def text_match_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_one("ac")==False
    assert text_match_one("dc")==False
    assert text_match_one("abba")==True

2025-10-10 12:14:19 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero.")
    directrix = -(b / (2 * a)) - 1 / (4 * a)
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-10 12:14:22 - Error: .
 Solution: def min_k(test_list, K):
    if K <= 0:
        return []
    if K > len(test_list):
        return test_list
    sorted_list = sorted(test_list, key=lambda x: x[0])
    return sorted_list[:K].
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-10 12:14:23 - Error: .
 Solution: def surface_Area(b, s):
    base_area = b ** 2
    slant_height = ((b / 2) ** 2 + s ** 2) ** 0.5
    triangle_area = 0.5 * b * slant_height
    total_surface_area = base_area + 4 * triangle_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-10 12:14:35 - Error: name 'heapq' is not defined.
 Solution: def larg_nnum(list1, n):
    if n <= 0:
        return []
    return heapq.nlargest(n, list1).
 Test: def check():
    assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])
    assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5))==set([100,90,80,70,60])
    assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3))==set([100,90,80])

2025-10-10 12:14:35 - Error: .
 Solution: def get_coordinates(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) != 2:
        raise ValueError('Input must be a tuple of two integers.')
    (x, y) = test_tup
    return [[x + i, y + j] for i in range(-1, 2) for j in range(-1, 2) if (i, j) != (0, 0)].
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-10 12:14:35 - Error: .
 Solution: def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    (gcd, x1, y1) = extended_gcd(b, a % b)
    x = y1
    y = x1 - a // b * y1
    return (gcd, x, y)
def find_solution(a, b, n):
    (gcd, x, y) = extended_gcd(a, b)
    if n % gcd != 0:
        return None
    x *= n // gcd
    y *= n // gcd
    return (x, y).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-10 12:14:36 - Error: .
 Solution: def triangle_area(r):
    if r <= 0:
        return None
    area = r * r / 2
    return area.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-10 12:14:39 - Error: .
 Solution: def count_Pairs(arr, n):
    if n < 2:
        return 0
    unique_elements = set(arr)
    count = len(unique_elements)
    return count * (count - 1) // 2
arr = [1, 2, 3, 1, 2]
n = len(arr).
 Test: def check():
    assert count_Pairs([1,2,1],3) == 2
    assert count_Pairs([1,1,1,1],4) == 0
    assert count_Pairs([1,2,3,4,5],5) == 10

2025-10-10 12:14:44 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        return 'Array must contain at least two elements.'
    max1 = max(arr)
    arr.remove(max1)
    max2 = max(arr)
    return (max2, max1).
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-10 12:14:44 - Error: .
 Solution: def newman_prime(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    primes = []
    candidate = 1
    while len(primes) < n:
        candidate += 1
        if is_prime(candidate):
            if candidate % 6 == 1 or candidate % 6 == 5:
                primes.append(candidate)
    return primes[n - 1]
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True.
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-10 12:14:52 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    return max(0, actual_cost - sale_amount).
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-10 12:14:52 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if m < 0 or m >= len(tuplex) or n < 0 or (n > len(tuplex)) or (m > n):
        return tuplex
    return tuplex[:m] + (50,) * (n - m) + tuplex[n:].
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-10 12:14:55 - Error: .
 Solution: def count_first_elements(test_tup):
    result = []
    for (index, element) in enumerate(test_tup):
        count_before = sum((1 for e in test_tup[:index] if e == element or (isinstance(element, tuple) and e in element)))
        result.append(count_before)
    return tuple(result).
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-10 12:14:56 - Error: .
 Solution: def sort_sublists(input_list):
    for sublist in input_list:
        sublist.sort()
    return input_list.
 Test: def check():
    assert sort_sublists((["green", "orange"], ["black", "white"], ["white", "black", "orange"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]
    assert sort_sublists(([" red ","green" ],["blue "," black"],[" orange","brown"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]
    assert sort_sublists((["zilver","gold"], ["magnesium","aluminium"], ["steel", "bronze"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]

2025-10-10 12:14:57 - Error: .
 Solution: def remove_kth_element(list1, L):
    if L < 0 or L >= len(list1):
        return list1
    return list1[:L] + list1[L + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-10 12:14:58 - Error: .
 Solution: def otherside_rightangle(w, h):
    if w <= 0 or h <= 0:
        raise ValueError('Sides must be positive numbers.')
    if w == h:
        raise ValueError('The hypotenuse must be the longest side.')
    hypotenuse = max(w, h)
    leg = min(w, h)
    other_side = math.sqrt(hypotenuse ** 2 - leg ** 2)
    return round(other_side, 10).
 Test: def check():
    assert otherside_rightangle(7,8)==10.63014581273465
    assert otherside_rightangle(3,4)==5
    assert otherside_rightangle(7,15)==16.55294535724685

2025-10-10 12:15:00 - Error: .
 Solution: def positive_count(nums):
    if len(nums) == 0:
        return 0.0
    positive_count = sum((1 for num in nums if num > 0))
    total_count = len(nums)
    return positive_count / total_count.
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-10 12:15:05 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    n = len(arr)
    if n == 0 or index < 0 or index >= n:
        return None
    total_rotations = rotations
    for (start, end) in ranges:
        if start <= index <= end:
            total_rotations += end - start + 1
    total_rotations = total_rotations % n
    new_index = (index + total_rotations) % n
    return arr[new_index]
arr = [1, 2, 3, 4, 5]
ranges = [[0, 2], [0, 3]]
rotations = 2
index = 1.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-10 12:15:07 - Error: .
 Solution: def max_length(list1):
    if not list1:
        return (0, [])
    max_length = 0
    longest_sublists = []
    for sublist in list1:
        current_length = len(sublist)
        if current_length > max_length:
            max_length = current_length
            longest_sublists = [sublist]
        elif current_length == max_length:
            longest_sublists.append(sublist)
    return (max_length, longest_sublists).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-10 12:15:12 - Error: .
 Solution: def tuple_intersection(test_list1, test_list2):
    set1 = {tuple(sorted(t)) for t in test_list1}
    set2 = {tuple(sorted(t)) for t in test_list2}
    intersection = set1.intersection(set2)
    return list(intersection)
test_list1 = [(3, 4), (5, 6), (9, 10), (4, 5)]
test_list2 = [(5, 4), (3, 4), (6, 5), (9, 11)].
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-10 12:15:12 - Error: .
 Solution: def max_difference(test_list):
    if not test_list:
        return 0
    max_diff = 0
    for i in range(len(test_list)):
        for j in range(i + 1, len(test_list)):
            diff = abs(test_list[i][0] - test_list[j][0]) + abs(test_list[i][1] - test_list[j][1])
            max_diff = max(max_diff, diff)
    return max_diff.
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-10 12:15:14 - Error: .
 Solution: def get_ludic(n):
    if n < 1:
        return []
    lucid_numbers = []
    for i in range(1, n + 1):
        if i == 1 or i == 2 or i == 3 or (i == 5) or (i == 7):
            lucid_numbers.append(i)
        elif i > 7 and all((i % p != 0 for p in lucid_numbers)):
            lucid_numbers.append(i)
    return lucid_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-10 12:15:19 - Error: Input must be a list or tuple of complex numbers..
 Solution: def convert(numbers):
    if not isinstance(numbers, (list, tuple)):
        raise ValueError('Input must be a list or tuple of complex numbers.')
    polar_coordinates = []
    for number in numbers:
        if not isinstance(number, complex):
            raise ValueError('All elements in the input must be complex numbers.')
        (r, theta) = cmath.polar(number)
        polar_coordinates.append((round(r, 2), round(theta, 2)))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-11 14:12:21 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:12:21 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:12:21 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:12:21 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:12:21 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:12:21 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:12:21 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:12:21 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:12:21 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:12:21 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:12:21 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:12:22 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:12:22 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:12:22 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:12:22 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:12:22 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:12:22 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:12:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:12:23 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:12:23 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 14:12:23 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:12:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:12:23 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:12:23 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:13:05 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:13:05 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:13:05 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:13:05 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:13:05 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:13:05 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:13:05 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:13:05 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:13:05 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return 'Match'
    else:
        return 'No Match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:13:05 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:13:06 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:13:06 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:13:06 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:13:06 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:13:06 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:13:06 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:13:06 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:13:07 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:13:07 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:13:07 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:13:07 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:13:07 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:13:07 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:21:15 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:21:16 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:21:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:21:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:21:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:21:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:21:16 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:21:16 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:21:16 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:21:16 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:21:16 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:21:17 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:21:17 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:21:17 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:21:17 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:21:17 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:21:17 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:21:17 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:21:17 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:21:17 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:21:17 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:21:18 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:21:18 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:21:35 - Error: .
 Solution: import re
def text_match_zero_one(text):
    if not isinstance(text, str):
        raise ValueError('Input must be a string')
    pattern = 'a(b+)'
    match = re.fullmatch(pattern, text)
    return match is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:21:35 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n <= 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:21:35 - Error: .
 Solution: def dif_Square(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:21:35 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    if any((not isinstance(i, (int, float)) for i in li1)) or any((not isinstance(i, (int, float)) for i in li2)):
        raise ValueError('Both lists must contain only numeric values.')
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:21:35 - Error: .
 Solution: def test_three_equal(x, y, z):
    if not all((isinstance(i, int) for i in (x, y, z))):
        raise ValueError('All inputs must be integers.')
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    return equal_count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:21:35 - Error: Tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    if len(test_tup) < 2:
        raise ValueError('Tuple must contain at least two elements.')
    if any((not isinstance(x, (int, float)) for x in test_tup)):
        raise ValueError('All elements in the tuple must be numbers.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 14:21:35 - Error: .
 Solution: def snake_to_camel(word):
    if not isinstance(word, str):
        raise ValueError('Input must be a string.')
    if not word:
        return ''
    if any((char not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_' for char in word)):
        raise ValueError('Input string can only contain letters, numbers, and underscores.')
    if word.startswith('_') or word.endswith('_'):
        raise ValueError('Input string cannot start or end with an underscore.')
    if '__' in word:
        raise ValueError('Input string cannot contain consecutive underscores.')
    components = word.split('_')
    camel_case = components[0] + ''.join((component.capitalize() for component in components[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:21:35 - Error: List must contain at least two distinct numbers..
 Solution: def second_smallest(numbers):
    if not isinstance(numbers, list):
        raise ValueError('Input must be a list.')
    if len(numbers) < 2:
        raise ValueError('List must contain at least two distinct numbers.')
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        raise ValueError('List must contain at least two distinct numbers.')
    unique_numbers.sort()
    return unique_numbers[1].
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-11 14:21:37 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string.')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:21:37 - Error: .
 Solution: def remove_odd(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    result = ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0))
    return result.
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:21:38 - Error: .
 Solution: import cmath
def angle_complex(a, b=None):
    if b is not None:
        z = complex(a, b)
    else:
        z = a
    if not isinstance(z, complex):
        raise ValueError('Input must be a complex number.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:21:39 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not isinstance(nums, list):
        raise ValueError('Input must be a list.')
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        if not isinstance(num, (int, float, str)):
            raise ValueError('List items must be integers, floats, or strings.')
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [key for (key, value) in frequency.items() if value == max_freq]
    return max_items[0] if len(max_items) == 1 else max_items.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 14:21:39 - Error: Input must be a list..
 Solution: def max_Abs_Diff(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if len(arr) < 2:
        raise ValueError('Array must contain at least two elements.')
    for element in arr:
        if not isinstance(element, (int, float)):
            raise ValueError('All elements in the array must be numbers.')
    return max(arr) - min(arr).
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-11 14:21:39 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    star_number = n * (6 * n - 6) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:21:40 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:21:40 - Error: .
 Solution: def start_withp(words):
    if not isinstance(words, list):
        raise ValueError('Input must be a list of words.')
    if not all((isinstance(word, str) for word in words)):
        raise ValueError('All elements in the list must be strings.')
    p_words = [word for word in words if word.lower().startswith('p')]
    if len(p_words) < 2:
        return "Not enough words starting with 'p'."
    return tuple(p_words[:2]).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:21:40 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if not all((isinstance(x, (int, float)) for x in arr)):
        raise ValueError('All elements in the list must be numbers.')
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:21:41 - Error: The input 'words' must be a list or tuple..
 Solution: def long_words(n, words):
    if not isinstance(n, int) or n < 0:
        raise ValueError("The length 'n' must be a non-negative integer.")
    if not isinstance(words, (list, tuple)):
        raise ValueError("The input 'words' must be a list or tuple.")
    if not all((isinstance(word, str) for word in words)):
        raise ValueError("All elements in 'words' must be strings.")
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:21:41 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:21:41 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:21:41 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for tup in nums:
        if not isinstance(tup, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(tup) == 0:
            averages.append(0)
            continue
        total = sum(tup)
        count = len(tup)
        averages.append(total / count)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:21:42 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:21:44 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        raise ValueError('Invalid input: n and m must be non-negative integers with m <= n.')
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        eulerian[i][0] = (i - 1) * eulerian[i - 1][0]
        for j in range(1, i + 1):
            eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:22:14 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:22:15 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:22:15 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:22:15 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:22:15 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:22:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:22:18 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:22:18 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:22:18 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:22:19 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:22:19 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:22:20 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:22:22 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:22:22 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    odd_sum = 0
    for i in range(1, n // 2 + 1):
        if n % i == 0 and i % 2 == 1:
            odd_sum += i
    return odd_sum % 2 == 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:22:24 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:22:49 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:22:51 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:22:51 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a+b+$'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:22:53 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:22:53 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:22:53 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:22:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:22:55 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:22:55 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:22:57 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:22:58 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    count = 0
    for i in range(1, n + 1):
        if n % i == 0 and i % 2 == 1:
            count += 1
    return count > 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:22:58 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:22:58 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:23:00 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:23:04 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:23:07 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:23:30 - Error: name 'collections' is not defined.
 Solution: def freq_count(list1):
    return dict(collections.Counter(list1)).
 Test: def check():
    assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})
    assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})
    assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})

2025-10-11 14:23:31 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:23:32 - Error: .
 Solution: def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:23:32 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:23:33 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:23:33 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:23:33 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:23:33 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:23:33 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:23:34 - Error: name 'bisect' is not defined.
 Solution: def left_insertion(a, x):
    return bisect.bisect_left(a, x).
 Test: def check():
    assert left_insertion([1,2,4,5],6)==4
    assert left_insertion([1,2,4,5],3)==2
    assert left_insertion([1,2,4,5],7)==4

2025-10-11 14:23:34 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    import math
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:23:35 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:23:36 - Error: name 'heapq' is not defined.
 Solution: def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append([nums1[i], nums2[j]])
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:23:36 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:23:36 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:23:37 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1] or (i > 1 and s[i] == s[i - 2]):
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-11 14:23:39 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:23:40 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:23:40 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:24:03 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:24:03 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:24:05 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:24:06 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:24:06 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:24:06 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:24:06 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:24:06 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:24:06 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:24:08 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:24:09 - Error: .
 Solution: def surfacearea_cylinder(r, h):
    import math
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:24:10 - Error: .
 Solution: def get_max_sum(n, memo={}):
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 14:24:10 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:24:11 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:24:11 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:24:12 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:29:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:29:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:29:16 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:29:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:29:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:29:16 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:29:16 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:29:16 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:29:16 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:29:16 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:29:16 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:29:17 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:29:17 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:29:17 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:29:17 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:29:17 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:29:17 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:29:17 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:29:17 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:29:17 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:29:17 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:29:18 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:29:18 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:29:35 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:29:35 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:29:35 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:29:36 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:29:37 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:29:37 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:29:38 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:29:38 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:29:38 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:29:39 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:29:39 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:29:39 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:29:39 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:29:42 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    count = 0
    for i in range(1, n // 2 + 1):
        if (n - i) % 2 == 1:
            count += 1
    return count > 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:29:42 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:37:58 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:37:58 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:37:58 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:37:58 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:37:59 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:37:59 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:37:59 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:37:59 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:37:59 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:37:59 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:37:59 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:37:59 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:37:59 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:38:00 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:38:00 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:38:00 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:38:00 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:38:00 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:38:00 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:38:00 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:38:01 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:38:01 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:38:01 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:38:16 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:38:16 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:38:17 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:38:17 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:38:17 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:38:17 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:38:17 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:38:17 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:38:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:38:17 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:38:17 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:38:17 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:38:18 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:38:18 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:38:18 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:38:18 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:38:18 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:38:18 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:38:18 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:38:18 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:38:18 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:38:19 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:38:19 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:39:01 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:39:02 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:39:02 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 14:39:02 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:39:02 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:39:02 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:39:02 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 14:39:02 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:39:02 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:39:02 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:39:02 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:39:02 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:39:02 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:39:03 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:39:03 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:39:03 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:39:03 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:39:03 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if (i - 1) % 2 == 0 and (n // i - 1) % 2 == 0:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:39:03 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:39:03 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:39:03 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:39:04 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:39:04 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:39:18 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:39:19 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:39:20 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:39:21 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:39:21 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:39:21 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:39:21 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:39:21 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:39:23 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:39:23 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:39:23 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:39:24 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n > 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:39:25 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:39:26 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:40:01 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = ''.join((part.capitalize() for part in parts))
    return camel_case[0].lower() + camel_case[1:].
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:40:01 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:40:03 - Error: .
 Solution: def test_three_equal(x, y, z):
    numbers = [x, y, z]
    unique_numbers = set(numbers)
    count = {num: numbers.count(num) for num in unique_numbers}
    return max(count.values()).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:40:04 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:40:08 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:40:08 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:40:09 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise IndexError('k is out of bounds')
    return sorted(arr)[k - 1].
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-11 14:40:10 - Error: .
 Solution: def find_sum(arr):
    frequency = {}
    for num in arr:
        frequency[num] = frequency.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in frequency.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:40:11 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0.0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:40:12 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    top_surface_area = math.pi * r ** 2
    bottom_surface_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + top_surface_area + bottom_surface_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:40:12 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:40:12 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    if startnum > endnum:
        return []
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-11 14:40:13 - Error: .
 Solution: def find_length(string):
    arr = [1 if char == '0' else -1 for char in string]
    max_diff = 0
    current_sum = 0
    sum_map = {0: -1}
    for index in range(len(arr)):
        current_sum += arr[index]
        if current_sum in sum_map:
            max_diff = max(max_diff, index - sum_map[current_sum])
        else:
            sum_map[current_sum] = index
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 14:40:14 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle_radians = cmath.phase(z)
    angle_degrees = angle_radians * (180 / cmath.pi)
    return angle_degrees.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:40:15 - Error: .
 Solution: def is_undulating(n):
    str_n = str(n)
    if len(str_n) < 2:
        return True
    previous_digit = int(str_n[0])
    for i in range(1, len(str_n)):
        current_digit = int(str_n[i])
        if current_digit == previous_digit:
            return False
        if i > 1 and (previous_digit - int(str_n[i - 1])) * (current_digit - previous_digit) >= 0:
            return False
        previous_digit = current_digit
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-11 14:40:18 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:40:21 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j - 1] + 1
            else:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j] + eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:41:23 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:41:23 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:41:24 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    if equal_count == 3:
        return 3
    if equal_count == 2:
        return 2
    return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:41:25 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:41:26 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:41:28 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    if number < 0:
        number = abs(number)
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:41:28 - Error: .
 Solution: def unique_product(list_data):
    unique_numbers = [number for number in list_data if list_data.count(number) == 1]
    product = 1
    for number in unique_numbers:
        product *= number
    return product if unique_numbers else 1.
 Test: def check():
    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000
    assert unique_product([1, 2, 3, 1,]) == 6
    assert unique_product([7, 8, 9, 0, 1, 1]) == 0

2025-10-11 14:41:30 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:41:32 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1))
    return unique_sum if unique_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:41:33 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:41:34 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (n - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:41:34 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:41:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:42:23 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((component.capitalize() for component in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:42:24 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:42:24 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:42:27 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)) + sum((num for num in arr if num not in count or count[num] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:42:27 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    top_surface_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * top_surface_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:42:27 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:42:29 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:42:30 - Error: .
 Solution: def find_length(string):
    transformed = [1 if char == '0' else -1 for char in string]
    max_diff = 0
    current_sum = 0
    sum_index_map = {0: -1}
    for (index, value) in enumerate(transformed):
        current_sum += value
        if current_sum in sum_index_map:
            max_diff = max(max_diff, index - sum_index_map[current_sum])
        else:
            sum_index_map[current_sum] = index
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 14:42:31 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 4 == 0 or n % 4 == 1:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:42:32 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:42:32 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:42:33 - Error: .
 Solution: def eulerian_num(n, m):
    if m == 0 or m == n:
        return 1
    if n == 0:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            eulerian[i][j] = (i - j) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:42:33 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:42:35 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 14:42:36 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:43:54 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:43:54 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    components = word.split('_')
    return components[0] + ''.join((part.capitalize() for part in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:43:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:43:55 - Error: .
 Solution: def last_Digit_Factorial(n):
    if n < 0:
        return None
    if n == 0 or n == 1:
        return 1
    count_zeros = 0
    while n >= 5:
        n //= 5
        count_zeros += n
    last_digit = 1
    for i in range(1, n + 1):
        if i % 5 != 0:
            last_digit *= i
            while last_digit % 10 == 0:
                last_digit //= 10
            last_digit %= 10
    for _ in range(count_zeros):
        last_digit *= 2
        last_digit %= 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-11 14:43:55 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:44:04 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:44:04 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:44:06 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:44:06 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) if len(tup) > 0 else 0 for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:44:07 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((x for (x, cnt) in count.items() if cnt == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:44:08 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    current_diff = 0
    diff_map = {0: -1}
    for (i, char) in enumerate(string):
        if char == '0':
            current_diff += 1
        elif char == '1':
            current_diff -= 1
        if current_diff in diff_map:
            max_diff = max(max_diff, i - diff_map[current_diff])
        else:
            diff_map[current_diff] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 14:44:08 - Error: .
 Solution: def get_max_sum(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 14:44:09 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_all_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_all_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-11 14:44:10 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:44:11 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        return 'Invalid input'
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        (a, b) = (0, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + 2 * b)
        return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-11 14:44:11 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:44:17 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:44:21 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0:
        return 0
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = (i - 1) * A[i - 1][0]
    for j in range(1, m + 1):
        A[0][j] = 0
    for i in range(1, n + 1):
        for j in range(1, min(i, m) + 1):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - 1) * A[i - 1][j - 1]
    return A[n][m]
def eulerian_num(n, m):
    if n < 0 or m < 0:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = (i - 1) * A[i - 1][0]
    for j in range(1, n + 1):
        A[0][j] = 0
    for i in range(1, n + 1):
        for j in range(1, min(i, m) + 1):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:45:00 - Error: .
 Solution: def remove_odd(str1, index=0):
    if index >= len(str1):
        return ''
    if index % 2 == 0:
        return str1[index] + remove_odd(str1, index + 1)
    else:
        return remove_odd(str1, index + 1).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:45:03 - Error: .
 Solution: def text_match_zero_one(text):

    def text_match_recursive(subtext):
        if not subtext:
            return False
        if subtext[0] == 'a':
            if len(subtext) > 1 and subtext[1] == 'b':
                return True if subtext[2:] == '' or subtext[2] == 'b' else text_match_recursive(subtext[1:])
            else:
                return False
        elif subtext[0] == 'b':
            return text_match_recursive(subtext[1:])
        else:
            return False
    return text_match_recursive(text).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 14:45:04 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:45:04 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:45:05 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return harmonic_sum(n - 1) + 1 / (n - 1).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:45:06 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:45:09 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:45:11 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:45:12 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative')
    top_bottom_area = 2 * math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_surface_area = top_bottom_area + lateral_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:45:12 - Error: .
 Solution: def start_withp(words):
    result = []
    for word in words:
        for w in word.split():
            if w.startswith('p') and len(result) < 2:
                result.append(w)
            if len(result) == 2:
                return tuple(result)
    return tuple(result).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:45:16 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:46:18 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:46:18 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:46:18 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    if number < 0:
        number = abs(number)
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:46:19 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:46:20 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:46:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    return round(lateral_area + 2 * base_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:46:20 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-11 14:46:21 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer (n >= 1).')
    star_number = n * (6 * n - 6) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:46:36 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:46:37 - Error: .
 Solution: def find_sum(arr):
    unique_sum = sum((x for x in arr if arr.count(x) == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:46:38 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:46:45 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[left] <= arr[mid]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:47:17 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        return 0
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    length_of_list = len(list1)
    result = total_sum * length_of_list
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 14:47:17 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples)
test_list = [(1, 2), (2, 3), (1, 2), (3, 4), (2, 3)].
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 14:47:17 - Error: .
 Solution: def remove_odd(str1):
    even_indexed_chars = []
    for i in range(0, len(str1), 2):
        even_indexed_chars.append(str1[i])
    return ''.join(even_indexed_chars).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:47:17 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer.')
    star_number = n * (2 * n - 1)
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:47:17 - Error: .
 Solution: def Diff(li1, li2):
    set_li2 = set(li2)
    return [item for item in li1 if item not in set_li2].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:47:17 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    unique_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:47:18 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 14:47:18 - Error: .
 Solution: def sum_div(number):
    if number <= 0:
        raise ValueError('Input must be a positive integer.')
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:47:19 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2:
        return []
    min_heap = []
    for j in range(min(k, len(nums2))):
        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))
    result = []
    while k > 0 and min_heap:
        (current_sum, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if i + 1 < len(nums1):
            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 14:47:19 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:47:20 - Error: .
 Solution: def remove_nested(test_tup):
    result = []

    def flatten(tup):
        for item in tup:
            if isinstance(item, tuple):
                flatten(item)
            else:
                result.append(item)
    flatten(test_tup)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-11 14:47:21 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    max_c = max(r, g, b)
    min_c = min(r, g, b)
    v = max_c
    if max_c == 0:
        s = 0
    else:
        s = (max_c - min_c) / max_c
    if max_c == min_c:
        h = 0
    elif max_c == r:
        h = (g - b) / (max_c - min_c)
    elif max_c == g:
        h = 2.0 + (b - r) / (max_c - min_c)
    else:
        h = 4.0 + (r - g) / (max_c - min_c)
    h = h * 60 % 360
    return (h, s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 14:47:23 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    else:
        harmonic_sum_value = 0.0
        for i in range(1, n):
            harmonic_sum_value += 1 / i
        return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:47:24 - Error: .
 Solution: def start_withp(words):
    filtered_words = [word for word in words if word.lower().startswith('p')]
    return filtered_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 14:47:24 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:47:24 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = 2 * math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_surface_area = base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:47:24 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    if arr[left] < arr[right]:
        return 0
    while left <= right:
        mid = (left + right) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:47:25 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:47:25 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:47:25 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    elif count == 2:
        return 2
    elif count == 0:
        return 0
    else:
        return 1.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:48:25 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:48:26 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:48:28 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer (n >= 1).')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:48:28 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:48:28 - Error: .
 Solution: import cmath
import math
def angle_complex(real, imag):
    if real == 0 and imag == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    z = complex(real, imag)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:48:30 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    for sublist in lst:
        if isinstance(sublist, list):
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 0
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 14:48:32 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:48:32 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = set1 - set2
    return list(difference).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 14:48:34 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:48:34 - Error: .
 Solution: def unique_product(list_data):
    unique_numbers = set((num for num in list_data if list_data.count(num) == 1))
    if not unique_numbers:
        return 1
    product = 1
    for num in unique_numbers:
        product *= num
    return product.
 Test: def check():
    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000
    assert unique_product([1, 2, 3, 1,]) == 6
    assert unique_product([7, 8, 9, 0, 1, 1]) == 0

2025-10-11 14:48:35 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:48:36 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:49:02 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        (a, b) = (0, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + 2 * b)
        return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-11 14:49:57 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 14:50:00 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 4 == 0 or n % 4 == 1:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 14:50:17 - Error: .
 Solution: def snake_to_camel(word):
    if not word or not isinstance(word, str):
        return ''
    parts = word.split('_')
    camel_case = ''.join((part.capitalize() for part in parts))
    return camel_case[0].lower() + camel_case[1:].
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 14:50:46 - Error: .
 Solution: def find_star_num(n):
    if n is None or not isinstance(n, int) or n < 1:
        return 0
    return n * (n * 3 - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 14:50:56 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 14:50:57 - Error: .
 Solution: def last_Digit_Factorial(n):
    if n < 0:
        return None
    if n == 0 or n == 1:
        return 1
    count_zeros = 0
    while n >= 5:
        n //= 5
        count_zeros += n
    last_digit = 1
    for i in range(1, n + 1):
        last_digit *= i
        while last_digit % 10 == 0:
            last_digit //= 10
        last_digit %= 10
    for _ in range(count_zeros):
        last_digit *= 2
        last_digit %= 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-11 14:51:02 - Error: .
 Solution: def find_sum(arr):
    if arr is None or not isinstance(arr, list):
        return 0
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1 and isinstance(key, (int, float)))).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 14:51:18 - Error: .
 Solution: def string_to_tuple(str1):
    if str1 is None or not isinstance(str1, str):
        return ()
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 14:51:21 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if len(t) == 0:
            averages.append(0)
        else:
            total = sum(t)
            count = len(t)
            averages.append(total / count)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 14:51:25 - Error: .
 Solution: def eulerian_num(n, m):
    if m > n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = 1
            else:
                eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 14:51:27 - Error: .
 Solution: def sum_div(number):
    if not isinstance(number, int) or number < 1:
        return 0
    divisors_sum = sum((i for i in range(1, number + 1) if number % i == 0))
    return divisors_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 14:51:27 - Error: must be real number, not str.
 Solution: import cmath
def angle_complex(a, b):
    try:
        a = float(a)
        b = float(b)
    except (ValueError, TypeError):
        return 'Invalid input: Please provide numeric values.'
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 14:51:28 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 14:51:29 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r is None or h is None:
        raise ValueError('Radius and height must not be None.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 14:51:30 - Error: .
 Solution: def harmonic_sum(n):
    if n is None or n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 14:51:33 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 14:51:36 - Error: .
 Solution: def is_undulating(n):
    if n is None or (isinstance(n, str) and n.strip() == ''):
        return False
    s = str(n).strip()
    if len(s) < 2:
        return True
    direction = None
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        elif s[i] > s[i - 1]:
            if direction is None:
                direction = 'up'
            elif direction == 'down':
                return False
            direction = 'up'
        else:
            if direction is None:
                direction = 'down'
            elif direction == 'up':
                return False
            direction = 'down'
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-11 15:03:48 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:03:48 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:03:49 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:03:49 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:03:49 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:03:49 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:03:49 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 15:03:49 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 15:03:49 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:03:49 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 15:03:49 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:03:49 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:03:50 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:03:50 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:03:50 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:03:50 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:03:50 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:03:50 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:03:50 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:03:50 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:03:50 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:03:50 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:03:52 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:04:03 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:04:03 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:04:03 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:04:05 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:04:05 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:04:05 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:04:07 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:04:07 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:04:08 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:04:08 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:04:08 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:04:08 - Error: .
 Solution: def get_max_sum(n, memo={}):
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 15:04:09 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    count = 0
    for i in range(1, n // 2 + 1):
        if n % i == 0:
            count += 1
            if count > 1:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:04:09 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:04:10 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:04:12 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:04:33 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:04:34 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:04:34 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:04:35 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:04:35 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:04:36 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:04:46 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:04:47 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0 + 0j:
        return 'Undefined angle for zero complex number.'
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:04:48 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:04:49 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if isinstance(t, tuple):
            if len(t) > 0:
                averages.append(sum(t) / len(t))
            else:
                averages.append(0.0)
        else:
            raise ValueError('All elements of the input must be tuples.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:04:51 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:04:51 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Both radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:04:52 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        raise ValueError('At least two tuples are required to calculate a product.')
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    if len(list1) < 2:
        raise ValueError('At least two tuples are required to calculate a product.')
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = list1[i][0] * list1[i][1] * (list1[j][0] * list1[j][1])
            max_product = max(max_product, abs(product))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:04:54 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:05:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:05:23 - Error: .
 Solution: def start_withp(words):
    result = []
    for word in words:
        if word.lower().startswith('p'):
            result.append(word)
            if len(result) == 2:
                break
    return result.
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 15:05:23 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:05:23 - Error: .
 Solution: from collections import Counter
def find_sum(arr):
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:05:23 - Error: .
 Solution: def remove_odd(str1):
    result = []
    for i in range(len(str1)):
        if i % 2 == 0:
            result.append(str1[i])
    return ''.join(result).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:05:24 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set()
    for item in test_list:
        if isinstance(item, tuple):
            unique_tuples.add(item)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:05:25 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = []
    for (i, w) in enumerate(words):
        if w:
            if i == 0:
                camel_case.append(w.lower())
            else:
                camel_case.append(w.capitalize())
    return ''.join(camel_case).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:05:27 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    if not 0 <= r <= 255 or not 0 <= g <= 255 or (not 0 <= b <= 255):
        raise ValueError('RGB values must be in the range [0, 255]')
    r /= 255.0
    g /= 255.0
    b /= 255.0
    max_c = max(r, g, b)
    min_c = min(r, g, b)
    delta = max_c - min_c
    v = max_c
    if max_c == 0:
        s = 0
    else:
        s = delta / max_c
    if delta == 0:
        h = 0
    elif max_c == r:
        h = (60 * ((g - b) / delta) + 360) % 360
    elif max_c == g:
        h = (60 * ((b - r) / delta) + 120) % 360
    elif max_c == b:
        h = (60 * ((r - g) / delta) + 240) % 360
    return (h, s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 15:05:28 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        print(0)
        return
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 15:05:29 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    abs_number = abs(number)
    total_sum = 0
    for i in range(1, abs_number + 1):
        if abs_number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:05:29 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        return None
    angle = cmath.phase(complex(a, b))
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:05:29 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    k = n - 1
    if k == 0:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, k + 1):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:05:30 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:05:30 - Error: .
 Solution: def Diff(li1, li2):
    set_li2 = set(li2)
    difference = []
    for item in li1:
        if item not in set_li2:
            difference.append(item)
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:05:30 - Error: unhashable type: 'list'.
 Solution: def Find_Max_Length(lst):
    unique_elements = set()
    max_length = 0
    left = 0
    for right in range(len(lst)):
        while lst[right] in unique_elements:
            unique_elements.remove(lst[left])
            left += 1
        unique_elements.add(lst[right])
        max_length = max(max_length, right - left + 1)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 15:05:31 - Error: Invalid input types. 'n' should be an integer and 'words' should be a list..
 Solution: def long_words(n, words):
    """
    Returns a list of words that are longer than n characters from the given list of words.

    :param n: An integer representing the minimum length of words to include.
    :param words: A list of strings (words).
    :return: A list of strings containing words longer than n characters.
    """
    if not isinstance(n, int) or not isinstance(words, list):
        raise ValueError("Invalid input types. 'n' should be an integer and 'words' should be a list.")
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:05:32 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:05:32 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][0] * list1[j][1])
            product3 = abs(list1[i][1] * list1[j][0])
            product4 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:06:02 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:06:08 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    if not all((0 <= x <= 255 for x in (r, g, b))):
        raise ValueError('RGB values must be in the range [0, 255]')
    r /= 255.0
    g /= 255.0
    b /= 255.0
    max_c = max(r, g, b)
    min_c = min(r, g, b)
    delta = max_c - min_c
    if delta == 0:
        hue = 0
    elif max_c == r:
        hue = (60 * ((g - b) / delta) + 360) % 360
    elif max_c == g:
        hue = (60 * ((b - r) / delta) + 120) % 360
    else:
        hue = (60 * ((r - g) / delta) + 240) % 360
    saturation = 0 if max_c == 0 else delta / max_c
    value = max_c * 100
    return (hue, saturation, value).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 15:06:10 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'ab+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:06:11 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:06:14 - Error: .
 Solution: def string_to_tuple(str1: str) -> tuple:
    """
    Convert a given string to a tuple of its characters.

    Parameters:
    str1 (str): The input string to be converted.

    Returns:
    tuple: A tuple containing the characters of the input string.

    Raises:
    ValueError: If the input is not a string.
    """
    if not isinstance(str1, str):
        raise ValueError(f'Input must be a string, got {type(str1).__name__} instead.')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:06:16 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(None)
            continue
        avg = sum(inner_tuple) / len(inner_tuple)
        averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:06:18 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.
    
    Parameters:
    n (int): A positive integer.
    
    Returns:
    float: The harmonic sum of n-1, or raises a ValueError for invalid inputs.
    """
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:06:19 - Error: Both inputs must be numbers (int or float) or the first input can be a complex number..
 Solution: import cmath
def angle_complex(a, b=0):
    """
    Calculate the angle (phase) of a complex number.

    Parameters:
    a (float or complex): The real part or a complex number.
    b (float, optional): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.

    Raises:
    ValueError: If the input is not a valid complex number.
    """
    if isinstance(a, complex):
        z = a
    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):
        z = complex(a, b)
    else:
        raise ValueError('Both inputs must be numbers (int or float) or the first input can be a complex number.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:06:19 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 0
    seen = set()
    for sublist in lst:
        sublist_tuple = tuple(sublist)
        if sublist_tuple not in seen:
            seen.add(sublist_tuple)
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
            seen = {sublist_tuple}
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 15:06:24 - Error: .
 Solution: def find_sum(arr):
    """
    Calculate the sum of non-repeated elements in a given list.

    Parameters:
    arr (list): A list of numbers.

    Returns:
    int: The sum of non-repeated elements. Returns 0 if there are no non-repeated elements or if the input list is empty.
    
    Raises:
    ValueError: If the input is not a list or contains non-numeric elements.
    """
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    counts = {}
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('All elements in the list must be numbers.')
        counts[num] = counts.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, value) in counts.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:06:24 - Error: .
 Solution: def count_rotation(arr):
    if arr is None or len(arr) == 0:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:06:26 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder rounded to two decimal places.

    Raises:
    ValueError: If radius or height is negative.
    TypeError: If radius or height is not a number.
    """
    if r is None or h is None:
        raise ValueError('Both radius and height must be provided.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:06:29 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m]
def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:07:30 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:07:31 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:07:32 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:07:37 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] > arr[next_mid] and arr[mid] > arr[prev_mid]:
            return next_mid
        elif arr[mid] == arr[low] and arr[mid] == arr[high]:
            if arr[low] > arr[low + 1]:
                return low + 1
            low += 1
            if arr[high] < arr[high - 1]:
                return high
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:07:42 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:07:44 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of its characters.

    Parameters:
    str1 (str): The string to be converted.

    Returns:
    tuple: A tuple containing the characters of the input string.

    Raises:
    ValueError: If the input is not a string.
    """
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:07:46 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:07:46 - Error: .
 Solution: def sum_div(number):
    if not isinstance(number, int):
        raise ValueError('Input must be an integer.')
    if number <= 0:
        return 0
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:07:52 - Error: Invalid input type for 'words'. It must be a list..
 Solution: def long_words(n, words):
    """
    Returns a list of words that are longer than n characters from the given list of words.

    :param n: An integer representing the minimum length of words to include.
    :param words: A list of strings (words).
    :return: A list of strings containing words longer than n characters.
    """
    if not isinstance(n, int):
        raise ValueError("Invalid input type for 'n'. It must be an integer.")
    if not isinstance(words, list):
        raise ValueError("Invalid input type for 'words'. It must be a list.")
    if any((not isinstance(word, str) for word in words)):
        raise ValueError("All elements in 'words' must be strings.")
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:07:53 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_surface_area = 2 * base_area + lateral_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:07:55 - Error: Both a and b must be numeric types (int or float)..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number. Must be a numeric type.
    b (float): The imaginary part of the complex number. Must be a numeric type.

    Returns:
    float: The angle of the complex number in radians.
           Returns None if both a and b are zero (undefined angle).
    
    Raises:
    ValueError: If a or b are not numeric types.
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numeric types (int or float).')
    if a == 0 and b == 0:
        return None
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:07:59 - Error: .
 Solution: def average_tuple(nums):
    """
    Calculate the average of each inner tuple in a tuple of tuples.

    Args:
    nums (tuple of tuples): A tuple containing inner tuples of numeric values.

    Returns:
    list: A list of averages for each inner tuple. Returns None for empty inner tuples.
    """
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(None)
            continue
        if not all((isinstance(x, (int, float)) for x in inner_tuple)):
            raise ValueError('All elements in inner tuples must be numeric.')
        avg = sum(inner_tuple) / len(inner_tuple)
        averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:08:02 - Error: .
 Solution: from collections import Counter
def find_sum(arr):
    """
    Calculate the sum of non-repeated elements in the given list.

    Parameters:
    arr (list): A list of integers.

    Returns:
    int: The sum of non-repeated elements.
    """
    if not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input list must contain only integers.')
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:08:27 - Error: .
 Solution: def string_to_tuple(input_string):
    return tuple(input_string).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:08:27 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:08:28 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    if not components:
        return ''
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:08:28 - Error: .
 Solution: def Diff(list1, list2):
    return list(set(list1) ^ set(list2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:08:28 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 in {0, 1}.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:08:28 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return True
    return False.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:08:28 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:08:28 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:08:28 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = sum((i for i in range(1, number + 1) if number % i == 0))
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:08:29 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:08:30 - Error: .
 Solution: def text_match_zero_one(text):
    pattern = 'a+b+'
    return 'Match' if re.fullmatch(pattern, text) else 'No Match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:08:30 - Error: .
 Solution: def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 15:08:30 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:08:30 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:08:30 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    star_number = (6 * n * n - 6 * n + 2) // 2
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:08:30 - Error: name 'cmath' is not defined.
 Solution: def angle_complex(a, b):
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:08:30 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:08:30 - Error: .
 Solution: def extract_freq(test_list):
    return len(set(test_list)).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:08:30 - Error: name 'tan' is not defined.
 Solution: def area_polygon(s, l):
    if s < 3:
        return 0
    area = s * l ** 2 / (4 * tan(pi / s))
    return area.
 Test: def check():
    assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)
    assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)
    assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)

2025-10-11 15:08:31 - Error: .
 Solution: def surfacearea_cylinder(radius, height):
    import math
    lateral_area = 2 * math.pi * radius * height
    base_area = 2 * math.pi * radius ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:08:31 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if (n, m) == (0, 0):
        return 1
    if (n, m) == (1, 0):
        return 1
    if (n, m) == (1, 1):
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:08:31 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:08:32 - Error: name 'heapq' is not defined.
 Solution: def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 15:09:12 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:09:12 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:09:13 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:09:13 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:09:14 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:09:14 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:09:45 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.

    Parameters:
    n (int): A positive integer.

    Returns:
    float: The harmonic sum of integers from 1 to n-1.

    Raises:
    ValueError: If n is not a positive integer.
    """
    if not isinstance(n, int) or n <= 1:
        raise ValueError('Input must be a positive integer greater than 1.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:09:45 - Error: .
 Solution: def average_tuple(nums):

    def average_of_tuple(t):
        if len(t) == 0:
            return None
        total = sum(t)
        count = len(t)
        return total / count
    return [average_of_tuple(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:09:48 - Error: Both a and b must be numeric values (int or float)..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    a (float or int): The real part of the complex number.
    b (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    if a is None or b is None:
        raise ValueError('Both a and b must be numeric values (int or float), and cannot be None.')
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numeric values (int or float).')
    complex_number = complex(a, b)
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:09:49 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1:
        return 1 if m == 0 else 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1] if j > 0 else 0
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:09:50 - Error: .
 Solution: from itertools import combinations
def max_product_tuple(tuples_list):
    if not tuples_list:
        return None
    max_product = float('-inf')
    for (a, b) in combinations(tuples_list, 2):
        product = abs(a[0] * a[1]) * abs(b[0] * b[1])
        max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:09:53 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.

    Parameters:
    r (float or int): The radius of the cylinder. Must be non-negative.
    h (float or int): The height of the cylinder. Must be non-negative.

    Returns:
    float: The total surface area of the cylinder, rounded to two decimal places.

    Raises:
    ValueError: If radius or height is None or negative.
    TypeError: If radius or height is not a number.
    """
    if r is None or h is None:
        raise ValueError('Radius and height must not be None.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:09:54 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:10:29 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = set1 - set2
    return list(difference).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:10:30 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    elif count == 2:
        return 2
    else:
        return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:10:31 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:10:37 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return re.fullmatch(pattern, text) is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:10:38 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:10:39 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:10:40 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:10:40 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, value) in counts.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:10:43 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:10:45 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 0
    seen = set()
    for sublist in lst:
        sublist_tuple = tuple(sublist)
        if sublist_tuple not in seen:
            seen.add(sublist_tuple)
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
            seen = {sublist_tuple}
    return max(max_length, current_length)
def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 0
    seen = set()
    for sublist in lst:
        sublist_tuple = tuple(sublist)
        if sublist_tuple not in seen:
            seen.add(sublist_tuple)
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
            seen = {sublist_tuple}
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 15:10:47 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:10:52 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:11:58 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:11:58 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:11:58 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:11:59 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:11:59 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:12:40 - Error: .
 Solution: def harmonic_sum(n):
    if n is None:
        raise TypeError('Input cannot be None')
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:12:41 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a is None or b is None:
        raise ValueError('Inputs cannot be None')
    if not isinstance(a, (int, float, complex)) or not isinstance(b, (int, float, complex)):
        raise TypeError('Inputs must be numeric (int, float, or complex)')
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:12:41 - Error: .
 Solution: def find_sum(arr):
    if arr is None or len(arr) == 0:
        return 0
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, value) in count.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:12:43 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * (3 * n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:12:43 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0)
            continue
        if all((isinstance(x, (int, float)) for x in inner_tuple)):
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
        else:
            raise ValueError('All elements in inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:12:46 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r is None or h is None:
        raise ValueError('Radius and height must not be None.')
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Both radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:12:49 - Error: .
 Solution: def similar_elements(test_tup1, test_tup2):
    if not isinstance(test_tup1, list) or not isinstance(test_tup2, list):
        return 'Both inputs must be lists.'
    if not test_tup1 or not test_tup2:
        return []
    shared_elements = list(set(test_tup1).intersection(set(test_tup2)))
    return shared_elements
test_tup1 = [1, 2, 3, 4, 3]
test_tup2 = [3, 4, 5, 6, 3].
 Test: def check():
    assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))
    assert set(similar_elements((1, 2, 3, 4),(5, 4, 3, 7))) == set((3, 4))
    assert set(similar_elements((11, 12, 14, 13),(17, 15, 14, 13))) == set((13, 14))

2025-10-11 15:12:49 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:12:56 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:13:21 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else None.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:13:58 - Error: .
 Solution: def remove_odd(str1):
    if not str1:
        return ''
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:13:59 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:13:59 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 4 == 0 or n % 4 == 1:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:13:59 - Error: .
 Solution: def snake_to_camel(word):
    if not word or not isinstance(word, str):
        return ''
    parts = word.split('_')
    camel_case = ''.join((part.capitalize() for part in parts))
    return camel_case[0].lower() + camel_case[1:] if camel_case else ''.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:13:59 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:14:00 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    frequency = Counter(arr)
    return sum((key for (key, count) in frequency.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:14:01 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:14:01 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0.0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:14:01 - Error: .
 Solution: def get_max_sum(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 15:14:01 - Error: .
 Solution: def string_to_tuple(str1):
    if str1 is None:
        return ()
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:14:01 - Error: .
 Solution: import cmath
import math
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:14:02 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:14:02 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:14:03 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    top_surface_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * top_surface_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:14:04 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        eulerian[i][0] = (i - 1) * eulerian[i - 1][0]
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - j) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:14:05 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:14:54 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:14:55 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:14:55 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:14:55 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:14:55 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:14:55 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:15:32 - Error: .
 Solution: from collections import Counter
from typing import List
def find_sum(arr: List[int]) -> int:
    if not isinstance(arr, list) or not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input must be a list of integers.')
    counts = Counter(arr)
    non_repeated_sum = sum((value for (value, count) in counts.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:15:33 - Error: .
 Solution: def harmonic_sum(n):
    if n is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        return 0.0
    harmonic_sum_value = 0.0
    for k in range(1, n):
        harmonic_sum_value += 1 / k
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:15:37 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0.0)
            continue
        if not all((isinstance(x, (int, float)) for x in inner_tuple)):
            raise ValueError('All elements must be numeric.')
        avg = sum(inner_tuple) / len(inner_tuple)
        averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:15:38 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:15:40 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Both radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:15:48 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:16:34 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = set1 - set2
    return list(difference).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:16:35 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return re.fullmatch(pattern, text) is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:16:35 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:16:42 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:16:45 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:16:46 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    return n * (3 * n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:16:48 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Calculate the angle (phase) of a complex number.

    Parameters:
    z (complex): The complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:16:53 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:16:53 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:16:53 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:16:54 - Error: .
 Solution: def find_sum(arr):
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, value) in counts.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:16:58 - Error: .
 Solution: def is_power_of_two(n):
    return n and n & n - 1 == 0
def is_polite(n):
    return not is_power_of_two(n) and n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:17:53 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:17:56 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:17:57 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:17:57 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:17:57 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:17:58 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:18:39 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:18:39 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * (3 * n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:18:41 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:18:42 - Error: .
 Solution: from collections import Counter
from typing import List, Union
def find_sum(arr: List[Union[int, float]]) -> int:
    if not isinstance(arr, list) or not all((isinstance(x, (int, float)) for x in arr)):
        raise ValueError('Input must be a list of integers or floats.')
    count = Counter(arr)
    non_repeated_sum = sum((num for (num, freq) in count.items() if freq == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:18:44 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.

    Parameters:
    n (int): A positive integer.

    Returns:
    float: The harmonic sum of n-1.

    Raises:
    ValueError: If n is less than 1 or not an integer.
    """
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:18:50 - Error: Both a and b must be numbers (int or float)..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    a (float or int): The real part of the complex number.
    b (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number.
    
    Raises:
    ValueError: If both a and b are zero, as the angle is undefined.
    TypeError: If a or b are not numbers.
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError('Both a and b must be numbers (int or float).')
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number (0, 0).')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:18:57 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (left, right) = (0, n - 1)
    if arr[left] < arr[right]:
        return 0
    while left <= right:
        mid = (left + right) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:19:10 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:19:54 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:19:55 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = []
    for (i, part) in enumerate(parts):
        if part:
            if i == 0:
                camel_case.append(part.lower())
            else:
                camel_case.append(part.capitalize())
    return ''.join(camel_case).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:20:00 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:20:05 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:20:07 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:20:07 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:20:09 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:20:12 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * (6 * n - 6) // 2 + 1 if n > 0 else 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:20:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:20:21 - Error: Both a and b must be numerical values..
 Solution: import cmath
def angle_complex(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numerical values.')
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    angle = cmath.phase(complex(a, b))
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:20:24 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            average = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(average, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:20:25 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or not all((isinstance(t, tuple) and len(t) == 2 for t in list1)):
        raise ValueError('Input must be a list of tuples, each containing exactly two numerical values.')
    max_product = float('-inf')
    for t1 in list1:
        for t2 in list1:
            if t1 != t2:
                product = t1[0] * t2[1]
                max_product = max(max_product, abs(product))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:20:26 - Error: .
 Solution: def Diff(li1, li2):
    """
    Returns a list of elements that are in li1 but not in li2.
    
    Parameters:
    li1 (list): The first list from which to subtract elements.
    li2 (list): The second list containing elements to be removed from li1.
    
    Returns:
    list: A list containing elements from li1 that are not in li2.
    """
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:21:11 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:21:11 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:21:12 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:21:13 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:21:17 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:21:18 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:21:47 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    return n * (6 * n - 6) // 2 + 1 if n > 0 else 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:21:49 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:21:51 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(None)
            continue
        if all((isinstance(x, (int, float)) for x in inner_tuple)):
            average = sum(inner_tuple) / len(inner_tuple)
            averages.append(average)
        else:
            raise ValueError('All elements in the inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:21:53 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:21:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not (isinstance(r, (int, float)) and isinstance(h, (int, float))):
        raise ValueError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Both radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:21:57 - Error: Invalid input: b must be a real number if provided..
 Solution: import cmath
def angle_complex(a, b=0):
    if not isinstance(a, (int, float)):
        raise ValueError('Invalid input: a must be a real number.')
    if b is not None and (not isinstance(b, (int, float))):
        raise ValueError('Invalid input: b must be a real number if provided.')
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:22:10 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:22:50 - Error: .
 Solution: def count_equal_numbers(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if x == y == z:
        count = 3
    return count
def test_three_equal(x, y, z):
    return count_equal_numbers(x, y, z).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:22:51 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:22:55 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:22:58 - Error: .
 Solution: def count_rotation(arr):
    low = 0
    high = len(arr) - 1
    if arr[low] <= arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < len(arr) - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:23:00 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:23:01 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:23:04 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    non_repeated_sum = sum((key for (key, value) in count.items() if value == 1))
    return non_repeated_sum + sum((key for key in arr if count[key] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:23:09 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:23:09 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-11 15:23:10 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            total = sum(inner_tuple)
            count = len(inner_tuple)
            average = total / count
            averages.append(round(average, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:23:10 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:24:13 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:24:14 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:24:14 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:24:15 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:24:15 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:24:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:33:10 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:33:10 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:33:10 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 15:33:10 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:33:11 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:33:11 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:33:11 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:33:11 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:33:11 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:33:11 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:33:11 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 15:33:11 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:33:11 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:33:12 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:33:12 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:33:12 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:33:12 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:33:12 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 15:33:12 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:33:12 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:33:12 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:33:12 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:33:13 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:33:31 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:33:31 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:33:32 - Error: .
 Solution: def snake_to_camel(word):
    if not isinstance(word, str):
        raise ValueError('Input must be a string')
    if not word:
        return ''
    components = word.split('_')
    if any((not component.isidentifier() for component in components)):
        raise ValueError('Input string contains invalid identifiers')
    return components[0] + ''.join((component.capitalize() for component in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:33:32 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:33:33 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    c_max = max(r, g, b)
    c_min = min(r, g, b)
    delta = c_max - c_min
    if delta == 0:
        h = 0
    elif c_max == r:
        h = 60 * ((g - b) / delta % 6)
    elif c_max == g:
        h = 60 * ((b - r) / delta + 2)
    else:
        h = 60 * ((r - g) / delta + 4)
    if c_max == 0:
        s = 0
    else:
        s = delta / c_max
    v = c_max
    return (round(h), round(s * 100), round(v * 100)).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 15:33:33 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:33:34 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:33:34 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 15:33:35 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:33:35 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:33:36 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:33:36 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
import math
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:33:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:33:36 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:33:37 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0, 1]
        for i in range(2, n + 1):
            next_value = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
            jacobsthal.append(next_value)
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-11 15:33:38 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = (i + 1) * A[i - 1][j]
            elif j == i:
                A[i][j] = i * A[i - 1][j - 1]
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:33:40 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:33:41 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:42:41 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:42:41 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:42:42 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:42:42 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:42:42 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:42:42 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:42:42 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 15:42:42 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:42:43 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 15:42:43 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 15:42:43 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 15:42:43 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:42:43 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 15:42:43 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:42:43 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:42:43 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:42:43 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:42:43 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:42:43 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:42:44 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:42:44 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:42:44 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:42:44 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:43:07 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:43:07 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:43:07 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 15:43:08 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:43:08 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:43:09 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:43:10 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:43:10 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 15:43:11 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:43:12 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:43:12 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:43:12 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:43:13 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0, 1]
        for i in range(2, n + 1):
            next_value = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
            jacobsthal.append(next_value)
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-11 15:43:13 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:43:13 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:43:13 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:43:14 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:58:37 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 15:58:38 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 15:58:39 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 15:58:39 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 15:58:41 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 15:58:42 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 15:58:44 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 15:58:45 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 15:58:49 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 15:58:49 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 15:58:50 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 15:58:50 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 15:58:50 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-11 15:58:50 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 15:58:51 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-11 15:58:51 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 15:58:51 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 15:58:52 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 15:58:53 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 15:58:53 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 15:58:54 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-11 16:00:39 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 16:00:54 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 16:00:55 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 16:01:11 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:01:12 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:01:13 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 16:01:14 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:01:14 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-11 16:01:14 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:01:15 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:01:16 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:01:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:01:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:01:18 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 16:01:18 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:01:18 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:01:21 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:01:22 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:01:45 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:01:49 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 16:01:50 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:01:50 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:01:51 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:01:52 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:01:53 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 16:01:53 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = (i - 1) * A[i - 1][0]
        for j in range(1, m + 1):
            A[i][j] = (j + 1) * A[i - 1][j] + (n - i) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:01:54 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:01:54 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:01:55 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:01:55 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:01:56 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:01:56 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:01:56 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:01:58 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-11 16:02:40 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:02:41 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:02:43 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:02:43 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:02:44 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:02:45 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:02:46 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:02:47 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-11 16:02:48 - Error: .
 Solution: def last_Digit_Factorial(n):
    if n < 0:
        return None
    if n == 0 or n == 1:
        return 1
    last_digit = 1
    for i in range(2, n + 1):
        last_digit *= i
        while last_digit % 10 == 0:
            last_digit //= 10
        last_digit %= 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-11 16:02:48 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) for tup in nums if len(tup) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:02:50 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    current_diff = 0
    diff_map = {0: -1}
    for (i, char) in enumerate(string):
        if char == '0':
            current_diff += 1
        else:
            current_diff -= 1
        if current_diff in diff_map:
            max_diff = max(max_diff, i - diff_map[current_diff])
        else:
            diff_map[current_diff] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 16:02:53 - Error: .
 Solution: def eulerian_num(n, m):
    if m > n or m < 0:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = 0
            else:
                eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (i - 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:02:57 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:02:58 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 16:03:00 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:03:01 - Error: .
 Solution: def find_sum(arr):
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    total_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:03:02 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:03:47 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 16:03:48 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:03:49 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if inner_tuple:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
        else:
            averages.append(0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:03:51 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 4 == 0 or n % 4 == 1:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:03:52 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:03:53 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:03:55 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = ''.join((part.capitalize() for part in parts))
    return camel_case[0].lower() + camel_case[1:] if camel_case else ''.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:03:56 - Error: .
 Solution: def remove_odd(str1):
    if not str1:
        return ''
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:03:56 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:04:01 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-11 16:04:02 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:04:03 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """Calculate the angle (phase) of a complex number given real and imaginary parts."""
    complex_number = complex(a, b)
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:04:04 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j > 0:
                A[i][j] += (i - j) * A[i - 1][j]
            A[i][j] += (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:04:04 - Error: .
 Solution: def find_star_num(n):
    if n <= 0:
        raise ValueError('n must be a positive integer.')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:04:12 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    current_sum = 0
    sum_index_map = {0: -1}
    for i in range(len(string)):
        current_sum += 1 if string[i] == '0' else -1
        if current_sum in sum_index_map:
            max_diff = max(max_diff, i - sum_index_map[current_sum])
        else:
            sum_index_map[current_sum] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 16:04:13 - Error: words must be a list of strings.
 Solution: def long_words(n, words):
    """
    Find words that are longer than n characters from a given list of words.

    :param n: The minimum length of words to be included in the result.
    :param words: A list of words (strings).
    :return: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-11 16:04:17 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        (a, b) = (0, 1)
        for i in range(2, n + 1):
            (a, b) = (b, a + 2 * b)
        return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-11 16:04:33 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = list1[i][0] * list1[j][0]
            product2 = list1[i][1] * list1[j][1]
            max_product = max(max_product, abs(product1), abs(product2))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:05:09 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:05:10 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:05:15 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    if r == 0:
        return 0.0
    if h == 0:
        return 2 * math.pi * r ** 2
    return 2 * math.pi * r ** 2 + 2 * math.pi * r * h.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:05:17 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    counts = Counter(arr)
    return sum((num for (num, count) in counts.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:05:20 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    n = len(string)
    for i in range(n):
        count_0 = 0
        count_1 = 0
        for j in range(i, n):
            if string[j] == '0':
                count_0 += 1
            else:
                count_1 += 1
            max_diff = max(max_diff, abs(count_0 - count_1))
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 16:05:21 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:05:22 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    if n % 4 == 2:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:05:24 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:05:24 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:05:28 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0 or n == 1:
        return 0
    if arr == sorted(arr):
        return 0
    min_index = 0
    for i in range(1, n):
        if arr[i] < arr[min_index]:
            min_index = i
    return min_index.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:05:30 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        return 0.0
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:05:30 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:08:15 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = [part for part in word.split('_') if part]
    if not parts:
        return ''
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:08:17 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return bool(re.fullmatch('ab+', text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:08:20 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('Undefined angle for the complex number 0 + 0i')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:08:21 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:08:24 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative')
    return 2 * math.pi * r * (h + r).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:08:25 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0 or n == 1:
        return 0
    if arr[0] < arr[-1]:
        return 0
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            return i + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:08:30 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:08:31 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    candidates = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(candidates).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:08:32 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    counts = Counter(arr)
    return sum((key for (key, value) in counts.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:08:34 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n > 0 and m == n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            eulerian[i][j] = (i - j) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:08:35 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:08:44 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:08:44 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    star_number = n * (6 * n - 6) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:11:04 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:11:08 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    n = len(string)
    for i in range(n):
        count_0 = 0
        count_1 = 0
        for j in range(i, n):
            if string[j] == '0':
                count_0 += 1
            else:
                count_1 += 1
            max_diff = max(max_diff, abs(count_0 - count_1))
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-11 16:11:14 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    candidates = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(candidates).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:11:16 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    max_c = max(r, g, b)
    min_c = min(r, g, b)
    delta = max_c - min_c
    if max_c == 0:
        return (0, 0.0, 0.0)
    if delta == 0:
        h = 0
    elif max_c == r:
        h = 60 * ((g - b) / delta % 6)
    elif max_c == g:
        h = 60 * ((b - r) / delta + 2)
    else:
        h = 60 * ((r - g) / delta + 4)
    s = 0 if max_c == 0 else delta / max_c
    v = max_c * 100
    return (int(h), s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 16:11:19 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:11:19 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return bool(re.fullmatch('ab+', text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:11:22 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if not isinstance(z, complex):
        raise TypeError('Input must be a complex number.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:11:33 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:11:50 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:12:03 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1.0 / k for k in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:12:05 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(tup, tuple) for tup in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(None)
        elif all((isinstance(x, (int, float)) for x in tup)):
            avg = sum(tup) / len(tup)
            averages.append(avg)
        else:
            raise ValueError('All elements in the tuple must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:12:26 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low < high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return low.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:13:42 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:13:43 - Error: Input tuple must have at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 16:13:55 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = 0
    max_num = None
    for (num, count) in frequency.items():
        if count > max_freq or (count == max_freq and (max_num is None or num < max_num)):
            max_freq = count
            max_num = num
    return max_num.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:14:01 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('n must be a positive integer')
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:14:09 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise TypeError('Input must be a positive integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer greater than or equal to 1.')
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:14:14 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple) or not all((isinstance(inner, tuple) for inner in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            if not all((isinstance(x, (int, float)) for x in inner_tuple)):
                raise ValueError('All elements in inner tuples must be numeric.')
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:14:15 - Error: .
 Solution: from typing import List, Tuple
def extract_freq(test_list: List[Tuple]) -> int:
    if not isinstance(test_list, list):
        raise ValueError('Input must be a list.')
    for item in test_list:
        if not isinstance(item, tuple):
            raise ValueError('All elements in the list must be tuples.')
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 16:14:25 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:14:38 - Error: Both a and b must be numeric values..
 Solution: import cmath
def angle_complex(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError('Both a and b must be numeric values.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:14:49 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r <= 0 or h <= 0:
        return 0.0
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:15:08 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        if arr[left] <= arr[right]:
            return left
        mid = (left + right) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] > arr[next_index]:
            return next_index
        if arr[mid] < arr[prev_index]:
            return mid
        if arr[left] == arr[mid] == arr[right]:
            left += 1
            right -= 1
        elif arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:15:08 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_abs_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            tuple1 = list1[i]
            tuple2 = list1[j]
            if isinstance(tuple1, tuple) and len(tuple1) == 2 and isinstance(tuple2, tuple) and (len(tuple2) == 2):
                products = [tuple1[0] * tuple2[0], tuple1[0] * tuple2[1], tuple1[1] * tuple2[0], tuple1[1] * tuple2[1]]
                max_abs_product = max(max_abs_product, max(map(abs, products)))
    return max_abs_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:15:09 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if m == 0 or m == n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:16:31 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:16:36 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    candidates = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(candidates).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:16:51 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return bool(re.fullmatch('ab+', text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:16:55 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('Angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:16:59 - Error: .
 Solution: def Diff(li1, li2):
    return list(set((item for item in li1 if item not in set(li2)))).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:17:03 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0:
        return True
    else:
        return n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:17:04 - Error: .
 Solution: def snake_to_camel(word):
    parts = [part for part in word.split('_') if part]
    if not parts:
        return ''
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:17:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 0
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:17:36 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return None
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            tuple1 = list1[i]
            tuple2 = list1[j]
            product = 1
            for (a, b) in zip(tuple1, tuple2):
                product *= a * b
            max_product = max(max_product, abs(product))
    return max_product
def max_product_tuple(list1):
    if not list1:
        return None
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:17:40 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple):
        raise TypeError('Input must be a tuple of tuples.')
    if len(nums) == 0:
        return []
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise TypeError('Each element of the input must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
        elif all((isinstance(x, (int, float)) for x in inner_tuple)):
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
        else:
            raise ValueError('All elements in inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:17:41 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    harmonic_sum_value = sum((1.0 / i for i in range(1, n)))
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:17:56 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise TypeError('Input must be a list.')
    if not arr:
        return 0
    from collections import Counter
    counts = Counter(arr)
    unique_sum = sum((key for (key, value) in counts.items() if value == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:18:16 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    for sublist in lst:
        if isinstance(sublist, list):
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 0
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 16:18:40 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:19:25 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0 or n == 1:
        return 0
    if arr[0] < arr[-1]:
        return 0
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            return i + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:19:30 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0:
        return True
    if n % 4 != 2:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-11 16:19:33 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a+b+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:19:39 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:19:41 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:19:42 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    if a == 0 and b == 0:
        return None
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:19:42 - Error: .
 Solution: def find_star_num(n):
    if n <= 0:
        raise ValueError('Input must be a positive integer.')
    return 3 * n * n - 3 * n + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:19:43 - Error: unhashable type: 'list'.
 Solution: def Find_Max_Length(lst):
    n = len(lst)
    if n == 0:
        return 0
    max_length = 0
    start = 0
    seen = {}
    for end in range(n):
        if lst[end] in seen:
            start = max(start, seen[lst[end]] + 1)
        seen[lst[end]] = end
        max_length = max(max_length, end - start + 1)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 16:19:45 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r == 0:
        return 0.0
    if h == 0:
        return 2 * math.pi * r * r
    return 2 * math.pi * r * (h + r).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:19:50 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:19:51 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    mx = max(r, g, b)
    mn = min(r, g, b)
    df = mx - mn
    if mx == 0:
        h = 0
        s = 0
        v = 0
    elif mx == 1:
        h = 0
        s = 0
        v = 1
    else:
        s = df / mx
        if mx == r:
            h = (60 * ((g - b) / df) + 360) % 360
        elif mx == g:
            h = (60 * ((b - r) / df) + 120) % 360
        else:
            h = (60 * ((r - g) / df) + 240) % 360
        v = mx
    return (h, s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 16:19:53 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    counts = Counter(arr)
    unique_sum = sum((key for (key, value) in counts.items() if value == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:20:02 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:21:21 - Error: .
 Solution: def count_equal_numbers(x: int, y: int, z: int) -> int:
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count
def test_three_equal(x: int, y: int, z: int):
    return count_equal_numbers(x, y, z).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-11 16:21:23 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:21:25 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:21:41 - Error: .
 Solution: def harmonic_sum(n: int) -> float:
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:21:50 - Error: .
 Solution: from typing import List, Tuple
def start_withp(words: List[str]) -> Tuple[str, str]:
    p_words = [word for word in words if word.lower().startswith('p')]
    return tuple(p_words[:2]) if len(p_words) >= 2 else tuple(p_words) + (None,) * (2 - len(p_words)).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-11 16:21:51 - Error: Input tuple must have at least two elements..
 Solution: def multiply_elements(test_tup: tuple) -> tuple:
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 16:21:52 - Error: .
 Solution: from collections import Counter
from typing import List
def find_sum(arr: List[int]) -> int:
    element_count = Counter(arr)
    unique_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:21:59 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z: complex) -> float:
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:22:04 - Error: .
 Solution: from typing import List
def Diff(li1: List[int], li2: List[int]) -> List[int]:
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:22:05 - Error: .
 Solution: def find_star_num(n: int) -> int:
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:22:39 - Error: .
 Solution: def last_Digit_Factorial(n: int) -> int:
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0 or n == 1:
        return 1
    elif n < 5:
        factorials = [1, 1, 2, 6, 24]
        return factorials[n]
    else:
        return 0.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-11 16:22:59 - Error: .
 Solution: import math
def surfacearea_cylinder(r: float, h: float) -> float:
    if r <= 0 or h <= 0:
        raise ValueError('Radius and height must be positive numbers.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:23:23 - Error: .
 Solution: from typing import List
def count_rotation(arr: List[int]) -> int:
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] <= arr[-1]:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:23:51 - Error: .
 Solution: def sum_div(number: int) -> int:
    if number < 1:
        return 0
    total = 0
    for i in range(1, number // 2 + 1):
        if number % i == 0:
            total += i
    total += number
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-11 16:24:01 - Error: .
 Solution: from typing import Tuple, List
def average_tuple(nums: Tuple[Tuple[float, ...]]) -> List[float]:
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:25:51 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:25:54 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:26:04 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:26:12 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = 0
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            tuple1 = list1[i]
            tuple2 = list1[j]
            product = sum((a * b for (a, b) in zip(tuple1, tuple2)))
            max_product = max(max_product, abs(product))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:26:13 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    filtered_parts = [part for part in parts if part]
    if not filtered_parts:
        return ''
    camel_case = filtered_parts[0].lower() + ''.join((part.capitalize() for part in filtered_parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:26:27 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:26:33 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:26:38 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:26:38 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:26:48 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or all((x == arr[0] for x in arr)):
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:26:52 - Error: .
 Solution: from typing import List, Tuple, Any
def extract_freq(test_list: List[Tuple[Any]]) -> int:
    """
    This function takes a list of tuples as input and returns the number of unique tuples.
    
    Parameters:
    test_list (List[Tuple]): A list containing tuples of elements. Tuples can contain elements of varying types.
    
    Returns:
    int: The count of unique tuples in the input list.
    """
    if not isinstance(test_list, list):
        raise TypeError('Input must be a list.')
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-11 16:28:19 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:28:43 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:28:58 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:28:59 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('n must be a positive integer')
    return n * (3 * n - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:28:59 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 0
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:29:02 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 16:29:35 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            for i in range(low, high + 1):
                if i < n - 1 and arr[i] > arr[i + 1]:
                    return i + 1
            return 0
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:29:41 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    """
    Calculate the average of each inner tuple in a tuple of tuples.

    Args:
        nums (tuple): A tuple of tuples containing numerical values.

    Returns:
        list: A list of averages for each inner tuple. Returns an empty list if input is empty.

    Raises:
        ValueError: If any element in the inner tuples is not a number.
    """
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not all((isinstance(x, (int, float)) for x in inner_tuple)):
            raise ValueError('All elements in inner tuples must be numerical.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:29:48 - Error: .
 Solution: from typing import List, Tuple, Union
def max_product_tuple(list1: List[Tuple[Union[int, float], ...]]) -> Union[int, float]:
    if len(list1) < 2:
        return 0
    max_abs_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            tuple1 = list1[i]
            tuple2 = list1[j]
            product = 1
            for k in range(min(len(tuple1), len(tuple2))):
                product *= tuple1[k] * tuple2[k]
            abs_product = abs(product)
            max_abs_product = max(max_abs_product, abs_product)
    return max_abs_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:29:50 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:29:53 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:29:58 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if m < 0 or m >= n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m]
def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if m < 0 or m >= n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-11 16:30:50 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:31:45 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:31:53 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:31:53 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:32:12 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:32:18 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:32:26 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    harmonic_sum_value = sum((1.0 / i for i in range(1, n)))
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:32:33 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:32:34 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    for sublist in lst:
        if isinstance(sublist, list):
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 0
    max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 16:32:35 - Error: .
 Solution: def find_sum(arr):
    if arr is None or not isinstance(arr, list):
        raise ValueError('Input must be a list of integers.')
    if not all((isinstance(x, int) for x in arr)):
        raise TypeError('All elements in the list must be integers.')
    unique_elements = set((x for x in arr if arr.count(x) == 1))
    return sum(unique_elements).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:32:37 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:32:43 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:32:44 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple):
        raise TypeError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise TypeError('Each inner element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
        elif all((isinstance(x, (int, float)) for x in inner_tuple)):
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
        else:
            averages.append(0.0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:33:13 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for element in test_tup:
        if isinstance(element, tuple):
            result.extend(remove_nested(element))
        else:
            result.append(element)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-11 16:35:41 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = 0
    max_num = None
    for (num, freq) in frequency.items():
        if freq > max_freq or (freq == max_freq and (max_num is None or num < max_num)):
            max_freq = freq
            max_num = num
    return max_num.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:35:42 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:36:05 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:36:17 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (argument) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number a + bi.
           Returns 0 if both a and b are 0, indicating a convention for the angle of the zero complex number.
    """
    if a == 0 and b == 0:
        return 0
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:36:29 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:36:31 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:36:38 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:36:46 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:36:58 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:37:04 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    R_prime = r / 255.0
    G_prime = g / 255.0
    B_prime = b / 255.0
    Cmax = max(R_prime, G_prime, B_prime)
    Cmin = min(R_prime, G_prime, B_prime)
    Delta = Cmax - Cmin
    if Delta == 0:
        H = 0
    elif Cmax == R_prime:
        H = (60 * ((G_prime - B_prime) / Delta) + 360) % 360
    elif Cmax == G_prime:
        H = (60 * ((B_prime - R_prime) / Delta) + 120) % 360
    else:
        H = (60 * ((R_prime - G_prime) / Delta) + 240) % 360
    S = 0 if Cmax == 0 else Delta / Cmax * 100
    V = Cmax * 100
    return (int(H), int(S), int(V)).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 16:37:45 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((key for (key, value) in count.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:39:32 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:39:34 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:39:43 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple) or len(inner_tuple) == 0:
            averages.append(None)
            continue
        numeric_values = [x for x in inner_tuple if isinstance(x, (int, float))]
        if numeric_values:
            avg = sum(numeric_values) / len(numeric_values)
            averages.append(round(avg, 2))
        else:
            averages.append(None)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:39:46 - Error: .
 Solution: import cmath
import numbers
def angle_complex(a, b):
    """
    Calculate the angle (argument) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number a + bi.

    Raises:
    ValueError: If both a and b are 0, as the angle is undefined.
    TypeError: If a or b are not numeric types.
    """
    if not isinstance(a, numbers.Number) or not isinstance(b, numbers.Number):
        raise TypeError('Both a and b must be numeric types.')
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:39:49 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:40:02 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    candidates = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(candidates).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:40:06 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    tuple_length = len(list1[0])
    for tup in list1:
        if len(tup) != tuple_length or not all((isinstance(x, (int, float)) for x in tup)):
            raise ValueError('All tuples must be of the same length and contain numeric values.')
    max_abs_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            tuple1 = list1[i]
            tuple2 = list1[j]
            current_product = sum((a * b for (a, b) in zip(tuple1, tuple2)))
            max_abs_product = max(max_abs_product, abs(current_product))
    return max_abs_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:40:10 - Error: .
 Solution: def find_sum(arr):
    if not all((isinstance(x, int) for x in arr)):
        raise TypeError('All elements in the input list must be integers.')
    if not arr:
        return 0
    element_count = {}
    for x in arr:
        element_count[x] = element_count.get(x, 0) + 1
    return sum((x for x in element_count if element_count[x] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:40:27 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:40:29 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:41:24 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:42:28 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:42:58 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 16:43:01 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = 0
    max_num = None
    for (num, freq) in frequency.items():
        if freq > max_freq or (freq == max_freq and (max_num is None or num < max_num)):
            max_freq = freq
            max_num = num
    return max_num.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:43:09 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:43:09 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((key for (key, value) in count.items() if value == 1 and isinstance(key, int))).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:43:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:43:16 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:43:23 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return 0
    max_product = 0
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    if not list1:
        return 0
    max_product = float('-inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:43:27 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:43:29 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:43:31 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:43:39 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:43:44 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    seen = set()
    for item in lst:
        if isinstance(item, list):
            item_tuple = tuple(item)
            if item_tuple not in seen:
                seen.add(item_tuple)
                current_length += len(item)
            else:
                current_length = len(item)
                seen = {item_tuple}
        elif item not in seen:
            seen.add(item)
            current_length += 1
        else:
            current_length = 1
            seen = {item}
        max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-11 16:43:48 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each inner element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            if not all((isinstance(x, (int, float)) for x in inner_tuple)):
                raise ValueError('All elements in the inner tuple must be numeric.')
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:45:17 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    N = len(test_tup) - 1
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(N))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-11 16:45:20 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-11 16:45:38 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:45:38 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:45:40 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    else:
        return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:45:42 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    candidates = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(candidates).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:45:45 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:45:48 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-11 16:45:54 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:46:12 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:46:16 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each inner element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0.0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:46:21 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    if not arr:
        return 0
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:46:31 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-11 16:46:51 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return 0
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            max_product = max(max_product, max((abs(a * b) for a in list1[i] for b in list1[j])))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:48:09 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    return parts[0].lower() + ''.join((part.capitalize() for part in parts[1:] if part)).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-11 16:48:38 - Error: .
 Solution: def rgb_to_hsv(r: int, g: int, b: int) -> tuple:
    (R_prime, G_prime, B_prime) = (r / 255.0, g / 255.0, b / 255.0)
    C_max = max(R_prime, G_prime, B_prime)
    C_min = min(R_prime, G_prime, B_prime)
    delta = C_max - C_min
    if delta == 0:
        H = 0
    elif C_max == R_prime:
        H = 60 * ((G_prime - B_prime) / delta % 6)
    elif C_max == G_prime:
        H = 60 * ((B_prime - R_prime) / delta + 2)
    else:
        H = 60 * ((R_prime - G_prime) / delta + 4)
    H = H if H >= 0 else H + 360
    S = 0 if C_max == 0 else delta / C_max
    V = C_max * 100
    return (H, S, V).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-11 16:48:39 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (3 * n - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-11 16:48:44 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-11 16:48:46 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-11 16:48:49 - Error: .
 Solution: def remove_odd(str1: str) -> str:
    return ''.join((str1[i] for i in range(0, len(str1), 2))).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-11 16:48:56 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        return 0
    return round(2 * math.pi * r * (r + h), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-11 16:48:58 - Error: Both a and b must be of type float or int..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (argument) of a complex number given its real and imaginary parts.

    Parameters:
    a (float or int): The real part of the complex number.
    b (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number a + bi, or None if both a and b are zero.
    """
    if not isinstance(a, (float, int)) or not isinstance(b, (float, int)):
        raise TypeError('Both a and b must be of type float or int.')
    if a == 0 and b == 0:
        return None
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-11 16:49:01 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-11 16:49:11 - Error: .
 Solution: from collections import Counter
def max_occurrences(nums):
    if not nums:
        return None
    frequency = Counter(nums)
    return min((num for (num, freq) in frequency.items() if freq == max(frequency.values())), default=None).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-11 16:49:11 - Error: .
 Solution: def find_sum(arr):
    if arr is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if not all((isinstance(x, int) for x in arr)):
        raise ValueError('All elements in the list must be integers.')
    from collections import Counter
    count = Counter(arr)
    return sum((key for (key, value) in count.items() if value == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-11 16:49:13 - Error: .
 Solution: def average_tuple(nums: tuple) -> list:
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-11 16:49:53 - Error: .
 Solution: import re
def text_match_one(text):
    return bool(re.match('^ab+$', text)).
 Test: def check():
    assert text_match_one("ac")==False
    assert text_match_one("dc")==False
    assert text_match_one("abba")==True

2025-10-11 16:49:54 - Error: .
 Solution: def find_lists(Input: tuple) -> int:
    return sum((1 for item in Input if isinstance(item, list))).
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-11 16:49:57 - Error: .
 Solution: def merge(lst):
    first_elements = [sublist[0] for sublist in lst]
    second_elements = [sublist[1] for sublist in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-11 16:50:21 - Error: .
 Solution: def dog_age(h_age: int) -> int:
    if h_age < 0:
        return 0
    elif h_age == 0:
        return 0
    elif h_age == 1:
        return 15
    elif h_age == 2:
        return 24
    else:
        return 24 + (h_age - 2) * 5.
 Test: def check():
    assert dog_age(12)==61
    assert dog_age(15)==73
    assert dog_age(24)==109

2025-10-11 16:50:22 - Error: .
 Solution: import math
def area_tetrahedron(side):
    if not isinstance(side, (int, float)):
        return 'Invalid input'
    if side < 0:
        return 'Invalid input'
    elif side == 0:
        return 0.0
    else:
        area = math.sqrt(2) / 12 * side ** 2 * math.sqrt(6)
        return round(area, 12).
 Test: def check():
    assert area_tetrahedron(3)==15.588457268119894
    assert area_tetrahedron(20)==692.8203230275509
    assert area_tetrahedron(10)==173.20508075688772

2025-10-11 16:50:27 - Error: .
 Solution: def binomial_coefficient(n, k):
    if k > n or k < 0:
        return 0
    if k == 0 or k == n:
        return 1
    num = 1
    denom = 1
    for i in range(k):
        num *= n - i
        denom *= i + 1
    return num // denom
def sum_Of_product(n):
    if n < 2:
        return 0
    total_sum = 0
    for k in range(n):
        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)
    return total_sum.
 Test: def check():
    assert sum_Of_product(3) == 15
    assert sum_Of_product(4) == 56
    assert sum_Of_product(1) == 1

2025-10-11 16:50:30 - Error: .
 Solution: def remove_kth_element(list1, L):
    if not list1:
        return []
    if L < 0:
        L += len(list1)
    if L < 0 or L >= len(list1):
        return list1
    return list1[:L] + list1[L + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-11 16:50:37 - Error: .
 Solution: from itertools import combinations
def find_combinations(test_list):
    if not test_list:
        return []
    result = set()
    n = len(test_list)
    for r in range(1, n + 1):
        for combo in combinations(test_list, r):
            summed_tuple = tuple((sum(x) for x in zip(*combo)))
            result.add(summed_tuple)
    return sorted(result).
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-11 16:50:37 - Error: .
 Solution: def combinations_list(list1):
    if not isinstance(list1, list):
        raise ValueError('Input must be a list.')
    result = []
    n = len(list1)
    for i in range(2 ** n):
        combination = []
        for j in range(n):
            if i & 1 << j:
                combination.append(list1[j])
        result.append(combination)
    return result.
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-11 16:50:37 - Error: .
 Solution: def min_product_tuple(list1):
    if not list1:
        return None
    min_product = float('inf')
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = list1[i][0] * list1[j][0] + list1[i][1] * list1[j][1]
            if product < min_product:
                min_product = product
    return min_product if min_product != float('inf') else None.
 Test: def check():
    assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8
    assert min_product_tuple([(10,20), (15,2), (5,10)] )==30
    assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100

2025-10-11 16:50:45 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    if l < 0 or r < 0 or l > r:
        return True
    bitmask = (1 << r - l + 1) - 1 << l
    return n & bitmask == 0.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-11 16:51:06 - Error: .
 Solution: def find_Max_Num(arr):
    if not arr:
        return '0'
    for num in arr:
        if not isinstance(num, int) or num < 0 or num > 9:
            raise ValueError('Input must be a list of single-digit integers (0-9).')
    arr = list(map(str, arr))
    arr.sort(key=lambda x: x * 10, reverse=True)
    largest_num = ''.join(arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-11 16:51:08 - Error: Both steps and d must be integers..
 Solution: def min_Jumps(steps, d):
    if not isinstance(steps, int) or not isinstance(d, int):
        raise ValueError('Both steps and d must be integers.')
    if steps <= 0:
        return float('inf')
    if d == 0:
        return 0
    distance = abs(d)
    jumps = distance // steps
    if distance % steps != 0:
        jumps += 1
    return jumps.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-11 16:51:14 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    return n | mask.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-11 16:51:19 - Error: .
 Solution: def upper_ctr(s: str) -> int:
    """
    Count the number of uppercase characters in the given string.

    Parameters:
    s (str): The input string.

    Returns:
    int: The count of uppercase characters in the string.

    Raises:
    TypeError: If the input is not a string or is None.
    """
    if not isinstance(s, str):
        raise TypeError('Input must be a string.')
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-11 16:51:32 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return arr[0]
    max_product = [0] * n
    max_product[0] = arr[0]
    overall_max = arr[0]
    for i in range(1, n):
        max_product[i] = arr[i]
        for j in range(i):
            if arr[i] > arr[j]:
                max_product[i] = max(max_product[i], max_product[j] * arr[i])
        overall_max = max(overall_max, max_product[i])
    return overall_max
arr = [3, 100, 4, 5, 150, 6].
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-11 16:51:32 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-11 16:51:32 - Error: .
 Solution: import math
def polar_rect(r, theta):
    if r < 0:
        raise ValueError('Radial distance r must be non-negative.')
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return (x, y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-11 16:51:33 - Error: 'int' object is not iterable.
 Solution: def check_tuplex(tuplex, tuple1):
    """
    Check if any element from tuple1 exists in tuplex.

    Parameters:
    tuplex (tuple): A tuple of elements to search within.
    tuple1 (tuple): A tuple of elements to check for existence.

    Returns:
    bool: True if at least one element from tuple1 is found in tuplex, False otherwise.
    """
    return any((item in tuplex for item in tuple1)).
 Test: def check():
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c", "e"),'r')==True
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c", "e"),'5')==False
    assert check_tuplex(("w", 3, "r", "e", "s", "o", "u", "r", "c","e"),3)==True

2025-10-11 16:51:42 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n < 1:
        return False
    return True.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-11 16:51:57 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    for num in nums_str:
        try:
            float(num)
        except ValueError:
            raise ValueError(f"Invalid numeric string: '{num}'")
    return sorted(nums_str, key=lambda x: (float(x), x)).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-11 16:52:05 - Error: Input must be a list..
 Solution: import cmath
def convert(numbers):
    """
    Convert a list of complex numbers to polar coordinates.
    
    Parameters:
    numbers (list of complex): A list of complex numbers.
    
    Returns:
    list of tuples: A list of tuples where each tuple contains (r, ) for the corresponding complex number.
    """
    if not isinstance(numbers, list):
        raise ValueError('Input must be a list.')
    polar_coordinates = []
    for (index, number) in enumerate(numbers):
        if not isinstance(number, complex):
            raise ValueError(f'Element at index {index} is not a complex number.')
        (r, theta) = cmath.polar(number)
        polar_coordinates.append((r, theta))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-11 16:52:08 - Error: .
 Solution: def odd_Equivalent(s, n):
    length = len(s)
    n = n % length if length > 0 else 0
    unique_rotations = set()
    for i in range(length):
        rotated = s[i:] + s[:i]
        unique_rotations.add(rotated)
    odd_count = 0
    for rotation in unique_rotations:
        if rotation[-1] == '1':
            odd_count += 1
    return odd_count.
 Test: def check():
    assert odd_Equivalent("011001",6) == 3
    assert odd_Equivalent("11011",5) == 4
    assert odd_Equivalent("1010",4) == 2

2025-10-11 16:52:11 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must be of the same length.')
    return tuple((a * b for (a, b) in zip(test_tup1, test_tup2))).
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-11 16:52:18 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    if not text or not pattern:
        return None
    matches = [(m.group(), m.start()) for m in re.finditer(pattern, text)]
    return matches if matches else None.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-11 16:52:20 - Error: .
 Solution: def snake_to_camel(word: str) -> str:
    if not word:
        return ''
    parts = [part for part in word.split('_') if part]
    if not parts:
        return ''
    camel_case = parts[0].lower() + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-11 16:52:20 - Error: .
 Solution: def get_Char(strr):
    ascii_sum = sum((ord(char) for char in strr))
    mod_value = ascii_sum % 26
    result_char = chr(mod_value + ord('a') - 1) if mod_value != 0 else 'z'
    return result_char.
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-11 16:52:21 - Error: .
 Solution: def loss_amount(actual_cost: float, sale_amount: float) -> float:
    if actual_cost < 0 or sale_amount < 0:
        raise ValueError('Both actual_cost and sale_amount must be non-negative.')
    if sale_amount >= actual_cost:
        return 0.0
    return actual_cost - sale_amount.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-11 16:52:27 - Error: .
 Solution: def trim_tuple(test_list, K):
    """
    Trims each tuple in the given list of tuples by K elements from both the start and the end.

    Parameters:
    test_list (list of tuples): A list where each element is a tuple.
    K (int): The number of elements to trim from both the start and the end of each tuple.

    Returns:
    list of tuples: A new list where each tuple is trimmed by K elements from both ends.
    """
    if K < 0:
        raise ValueError('K must be a non-negative integer.')
    result = []
    for tup in test_list:
        if len(tup) <= 2 * K:
            result.append(())
        else:
            result.append(tup[K:len(tup) - K])
    return result.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-11 16:52:30 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    return re.sub('\\([^()]*\\)', '', items).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-11 16:52:43 - Error: .
 Solution: def Find_Min(lst):
    if not lst:
        return 0
    unique_elements = set((tuple(x) if isinstance(x, list) else x for x in lst))
    unique_count = len(unique_elements)
    left = 0
    min_length = float('inf')
    current_count = {}
    formed = 0
    for right in range(len(lst)):
        element = tuple(lst[right]) if isinstance(lst[right], list) else lst[right]
        current_count[element] = current_count.get(element, 0) + 1
        if current_count[element] == 1:
            formed += 1
        while formed == unique_count:
            min_length = min(min_length, right - left + 1)
            left_element = tuple(lst[left]) if isinstance(lst[left], list) else lst[left]
            current_count[left_element] -= 1
            if current_count[left_element] == 0:
                formed -= 1
            left += 1
    return min_length if min_length != float('inf') else 0.
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-11 16:52:49 - Error: .
 Solution: import re
def find_literals(text: str, pattern: str) -> tuple:
    """
    Searches for the first occurrence of the regex pattern in the given text.
    
    Parameters:
    - text (str): The string to search within.
    - pattern (str): The regex pattern to search for.
    
    Returns:
    - tuple: A tuple containing the matching substring, start index, and end index.
             If no match is found, return (None, -1, -1).
    """
    if not text or not pattern:
        return (None, -1, -1)
    match = re.search(pattern, text)
    if match:
        start_index = match.start()
        end_index = match.end() - 1
        return (match.group(), start_index, end_index)
    return (None, -1, -1).
 Test: def check():
    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)
    assert find_literals('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)
    assert find_literals('Hardest choices required strongest will', 'will') == ('will', 35, 39)

2025-10-11 16:52:52 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count01 = 0
    count10 = 0
    for (a, b) in zip(str1, str2):
        if a == '0' and b == '1':
            count01 += 1
        elif a == '1' and b == '0':
            count10 += 1
    if (count01 + count10) % 2 != 0:
        return -1
    return max(count01, count10).
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-11 16:52:57 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    n = len(arr)
    if n == 0 or index < -n or index >= n:
        return None
    effective_rotations = rotations % n
    if index < 0:
        index += n
    new_index = (index - effective_rotations + n) % n
    for (start, end) in ranges:
        if start <= new_index <= end:
            return arr[new_index]
    return None.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-11 16:52:57 - Error: .
 Solution: def check_value(d: dict, n: int) -> bool:
    if len(d) != n:
        return False
    if n == 0:
        return True
    first_value = next(iter(d.values()))
    return all((value == first_value for value in d.values())).
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-11 16:53:09 - Error: .
 Solution: def positive_count(nums):
    """
    Calculate the ratio of positive integers in the given array of integers.

    Parameters:
    nums (list of int): An array of integers.

    Returns:
    float: The ratio of positive integers to the total number of integers.
           Returns 0.0 if the array is empty or contains no positive integers.
    """
    if not nums:
        return 0.0
    total_count = len(nums)
    positive_count = sum((1 for num in nums if num > 0))
    return positive_count / total_count if total_count > 0 else 0.0.
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-11 16:53:10 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n <= 0:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-11 16:53:12 - Error: .
 Solution: def sum_of_digits(nums):
    if not isinstance(nums, list):
        raise ValueError('Input must be a list of integers.')
    result = []
    for num in nums:
        if not isinstance(num, int):
            raise ValueError(f'Invalid input: {num}. All elements must be integers.')
        digit_sum = sum((int(digit) for digit in str(abs(num))))
        result.append(digit_sum)
    return result.
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-11 16:53:16 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' cannot be zero for a parabola.")
    directrix = (4 * a * c - b ** 2) / (4 * a)
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-11 16:53:20 - Error: .
 Solution: import re
def text_starta_endb(text):
    return bool(re.search('a.*b', text)).
 Test: def check():
    assert text_starta_endb("aabbbb")
    assert not text_starta_endb("aabAbbbc")
    assert not text_starta_endb("accddbbjjj")

2025-10-11 16:53:22 - Error: concatenate_tuple() missing 1 required positional argument: 'delimiter'.
 Solution: def concatenate_tuple(test_tup, delimiter):
    if not isinstance(delimiter, str):
        raise ValueError('Delimiter must be a string.')
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    return delimiter.join(map(str, test_tup)).
 Test: def check():
    assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
    assert concatenate_tuple(("QWE", "is", 4, "RTY") ) == 'QWE-is-4-RTY'
    assert concatenate_tuple(("ZEN", "is", 4, "OP") ) == 'ZEN-is-4-OP'

2025-10-11 16:53:24 - Error: .
 Solution: def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:
    merged_dict = {}
    merged_dict.update(dict1)
    merged_dict.update(dict2)
    merged_dict.update(dict3)
    return merged_dict.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-11 16:53:25 - Error: .
 Solution: def is_newman_shanks_williams_prime(num):
    """Check if a number is a NewmanShanksWilliams prime."""
    if num < 2:
        return False
    if num in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71):
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    for i in range(5, int(num ** 0.5) + 1, 6):
        if num % i == 0 or num % (i + 2) == 0:
            return False
    return True
def newman_prime(n):
    """Return the nth NewmanShanksWilliams prime number."""
    if n < 1:
        raise ValueError('n must be a positive integer.')
    newman_shanks_williams_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
    if n <= len(newman_shanks_williams_primes):
        return newman_shanks_williams_primes[n - 1]
    count = len(newman_shanks_williams_primes)
    num = newman_shanks_williams_primes[-1] + 2
    while count < n:
        if is_newman_shanks_williams_prime(num):
            count += 1
        num += 2
    return num - 2.
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-11 16:53:36 - Error: sum() missing 1 required positional argument: 'b'.
 Solution: def sum_of_common_divisors(a, b):

    def gcd(x, y):
        while y:
            (x, y) = (y, x % y)
        return abs(x)

    def divisors(n):
        divs = set()
        for i in range(1, int(n ** 0.5) + 1):
            if n % i == 0:
                divs.add(i)
                divs.add(n // i)
        return divs
    if a == 0 and b == 0:
        return 0
    elif a == 0:
        return sum(divisors(abs(b)))
    elif b == 0:
        return sum(divisors(abs(a)))
    common_gcd = gcd(abs(a), abs(b))
    return sum(divisors(common_gcd))
def sum(a, b):
    return sum_of_common_divisors(a, b).
 Test: def check():
    assert sum(10,15) == 6
    assert sum(100,150) == 93
    assert sum(4,6) == 3

2025-10-11 16:53:37 - Error: .
 Solution: def count_bidirectional(test_list):
    seen_pairs = set()
    count = 0
    for (a, b) in test_list:
        if (b, a) in seen_pairs:
            count += 1
        seen_pairs.add((a, b))
    return count.
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-11 16:53:37 - Error: .
 Solution: def cal_sum(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 3 + 0
    P = [3, 0, 2]
    sum_perrin = sum(P)
    for i in range(3, n):
        next_perrin = P[i - 2] + P[i - 3]
        P.append(next_perrin)
        sum_perrin += next_perrin
    return sum_perrin.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-11 16:53:52 - Error: .
 Solution: from typing import List, Any
def common_element(list1: List[Any], list2: List[Any]) -> bool:
    set_list2 = set(list2)
    for element in list1:
        if element in set_list2:
            return True
    return False.
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-11 16:53:53 - Error: .
 Solution: def and_tuples(test_tup1: tuple, test_tup2: tuple) -> tuple:
    if not test_tup1 or not test_tup2:
        return ()
    min_length = min(len(test_tup1), len(test_tup2))
    result = tuple((max(test_tup1[i] - test_tup2[i], 0) for i in range(min_length)))
    return result.
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-11 16:53:56 - Error: .
 Solution: def get_ludic(n):
    if n < 1:
        return []
    ludic_numbers = []
    for i in range(1, n + 1):
        if is_ludic(i):
            ludic_numbers.append(i)
    return ludic_numbers
def is_ludic(num):
    if num < 3:
        return True
    return (num - 1) % 3 != 0.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-11 16:53:59 - Error: .
 Solution: def group_tuples(input_list):
    """
    This function takes a list of tuples and returns a list of tuples where the first element
    is common to at least two tuples. If no common first element exists, it returns an empty list.

    Parameters:
    input_list (List[Tuple[Any]]): A list of tuples where each tuple contains at least one element.

    Returns:
    List[Tuple[Any]]: A list of tuples with common first elements or an empty list if none exist.
    """
    if not input_list:
        return []
    first_elements = {}
    for tup in input_list:
        if tup:
            first_element = tup[0]
            if first_element in first_elements:
                first_elements[first_element].append(tup)
            else:
                first_elements[first_element] = [tup]
    result = []
    for tuples in first_elements.values():
        if len(tuples) > 1:
            merged_tuple = (tuples[0][0],) + tuple((item for t in tuples for item in t[1:]))
            result.append(merged_tuple)
    return result.
 Test: def check():
    assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]
    assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]
    assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]

2025-10-11 16:54:00 - Error: .
 Solution: def gcd_extended(a, b):
    if a == 0:
        return (b, 0, 1)
    (gcd, x1, y1) = gcd_extended(b % a, a)
    x = y1 - b // a * x1
    y = x1
    return (gcd, x, y)
def find_solution(a, b, n):
    if a == 0 and b == 0:
        return (0, 0) if n == 0 else None
    elif a == 0:
        return (0, n // b) if n % b == 0 else None
    elif b == 0:
        return (n // a, 0) if n % a == 0 else None
    (d, x0, y0) = gcd_extended(a, b)
    if n % d != 0:
        return None
    x = x0 * (n // d)
    y = y0 * (n // d)
    return (x, y).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-11 16:54:13 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if not isinstance(tuplex, tuple) or not tuplex:
        return None
    if m < 0 or m >= len(tuplex):
        return None
    inner_tuple = tuplex[m]
    if not isinstance(inner_tuple, tuple):
        return None
    if n < 0 or n >= len(inner_tuple):
        return None
    return inner_tuple[:n] + (50,) + inner_tuple[n + 1:].
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-11 16:54:17 - Error: Function lateralsuface_cylinder is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)
    assert math.isclose(lateralsuface_cylinder(4,5), 125.66000000000001, rel_tol=0.001)
    assert math.isclose(lateralsuface_cylinder(4,10), 251.32000000000002, rel_tol=0.001)

2025-10-11 16:54:23 - Error: .
 Solution: from typing import List, Tuple
def tuple_intersection(test_list1: List[Tuple], test_list2: List[Tuple]) -> Tuple[Tuple]:
    set1 = {tuple(sorted(t)) for t in test_list1}
    set2 = {tuple(sorted(t)) for t in test_list2}
    intersection = set1.intersection(set2)
    return tuple(sorted(intersection)).
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-11 16:54:24 - Error: Radius must be positive..
 Solution: import math
def triangle_area(r: float) -> float:
    if r <= 0:
        raise ValueError('Radius must be positive.')
    return r * r * math.sqrt(3) / 4.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-11 16:54:29 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        raise ValueError('Array must contain at least two elements.')
    max1 = max2 = float('-inf')
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return ((max1, max2), max1 * max2).
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-11 16:54:31 - Error: .
 Solution: import sys
def tuple_size(tuple_list):
    if not isinstance(tuple_list, tuple):
        raise TypeError('Input must be a tuple.')
    total_size = sys.getsizeof(tuple_list)
    for item in tuple_list:
        total_size += sys.getsizeof(item)
        if isinstance(item, (tuple, list, dict)):
            total_size += get_nested_size(item)
    return total_size
def get_nested_size(item):
    if isinstance(item, tuple):
        return sum((sys.getsizeof(sub_item) for sub_item in item))
    elif isinstance(item, list):
        return sum((sys.getsizeof(sub_item) for sub_item in item))
    elif isinstance(item, dict):
        return sum((sys.getsizeof(key) + sys.getsizeof(value) for (key, value) in item.items()))
    return 0.
 Test: def check():
    assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
    assert tuple_size((1, "Raju", 2, "Nikhil", 3, "Deepanshu") ) == sys.getsizeof((1, "Raju", 2, "Nikhil", 3, "Deepanshu"))
    assert tuple_size(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf"))  ) == sys.getsizeof(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf")))

2025-10-11 16:54:31 - Error: .
 Solution: def max_length(list1):
    if not list1:
        return []
    max_len = max((len(sublist) for sublist in list1))
    result = [sublist for sublist in list1 if len(sublist) == max_len]
    return (max_len, result).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-11 16:54:33 - Error: .
 Solution: import math
def wind_chill(v, t):
    if v < 0:
        raise ValueError('Wind velocity must be non-negative.')
    if v == 0:
        return math.ceil(t)
    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wci).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-11 16:54:36 - Error: .
 Solution: def set_left_most_unset_bit(n):
    if n == 0:
        return 1
    position = 0
    while 1 << position & n:
        position += 1
    mask = 1 << position
    return n | mask.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-11 16:54:54 - Error: .
 Solution: def find_dissimilar(test_tup1: tuple, test_tup2: tuple) -> tuple:
    unique_to_tup1 = set(test_tup1) - set(test_tup2)
    unique_to_tup2 = set(test_tup2) - set(test_tup1)
    return (tuple(unique_to_tup1), tuple(unique_to_tup2)).
 Test: def check():
    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)
    assert find_dissimilar((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)
    assert find_dissimilar((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)

2025-10-14 15:15:25 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:15:26 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:15:26 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:15:26 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:15:26 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:15:26 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:15:26 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:15:26 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:15:26 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:15:26 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:15:27 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:15:27 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:15:27 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:15:27 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:15:27 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:15:27 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:15:27 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:15:27 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:15:27 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:15:27 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:15:28 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:15:28 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:15:29 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:17:36 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:17:36 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:17:36 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:17:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:17:36 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:17:37 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:17:37 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:17:37 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:17:37 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:17:37 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:17:37 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:17:37 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:17:37 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:17:37 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:17:37 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:17:38 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:17:38 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:17:38 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:17:38 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-14 15:17:38 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:17:38 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:17:39 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:17:39 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:17:39 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:17:55 - Error: .
 Solution: def remove_odd(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:17:55 - Error: List must contain at least two distinct numbers..
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        raise ValueError('List must contain at least two distinct numbers.')
    first = second = float('inf')
    for number in numbers:
        if number < first:
            second = first
            first = number
        elif first < number < second:
            second = number
    if second == float('inf'):
        raise ValueError('List must contain at least two distinct numbers.')
    return second.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-14 15:17:55 - Error: .
 Solution: def dif_Square(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n % 2 == 0:
        return True
    elif n % 4 == 2:
        return False
    else:
        return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:17:56 - Error: Tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    N = len(test_tup)
    if N < 2:
        raise ValueError('Tuple must contain at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(N - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:17:57 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        raise ValueError('Input list cannot be empty')
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items[0] if len(max_items) == 1 else max_items.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-14 15:17:57 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:17:58 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:17:59 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:17:59 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if isinstance(z, complex):
        angle = cmath.phase(z)
        return angle
    else:
        raise ValueError('Input must be a complex number.').
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:17:59 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    element_count = {}
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('All elements in the list must be numbers.')
        element_count[num] = element_count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:17:59 - Error: The 'words' parameter must be a list or tuple..
 Solution: def long_words(n, words):
    if not isinstance(n, int) or n < 0:
        raise ValueError("The length 'n' must be a non-negative integer.")
    if not isinstance(words, (list, tuple)):
        raise ValueError("The 'words' parameter must be a list or tuple.")
    return [word for word in words if isinstance(word, str) and len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:18:00 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:18:00 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    star_number = n * (6 * n - 6) // 2 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:18:00 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if not t:
            averages.append(0)
            continue
        if not all((isinstance(x, (int, float)) for x in t)):
            raise ValueError('All elements in the inner tuples must be numbers.')
        avg = sum(t) / len(t)
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:18:04 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        raise ValueError('Input array cannot be empty')
    n = len(arr)
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:18:05 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    while n % 2 == 0:
        n //= 2
    return n > 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:18:05 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        raise ValueError('Invalid input: n and m must be non-negative integers with m <= n.')
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            if j == 0:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j - 1]
            else:
                eulerian[i][j] = (i + 1) * eulerian[i - 1][j] + i * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:18:33 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:18:35 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = ''.join((part.capitalize() for part in parts))
    return camel_case[0].lower() + camel_case[1:].
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:18:38 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """Calculate the angle (in radians) of a complex number given its real and imaginary parts."""
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:18:39 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        print(0)
        return
    total_sum = sum((round(number) for number in list1))
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:18:39 - Error: .
 Solution: def find_sum(arr):
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    return sum((num for (num, count) in counts.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:18:41 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:18:42 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(None)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:18:42 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        prev2 = prev1
        prev1 = current
    return current
n = 10.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-14 15:18:45 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:18:45 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:18:46 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:18:47 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:18:50 - Error: .
 Solution: def remove_nested(test_tup):
    if not isinstance(test_tup, tuple):
        return (test_tup,)
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-14 15:18:52 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise IndexError('k is out of bounds')

    def quickselect(left, right, index):
        if left == right:
            return arr[left]
        pivot_index = partition(left, right)
        if index == pivot_index:
            return arr[index]
        elif index < pivot_index:
            return quickselect(left, pivot_index - 1, index)
        else:
            return quickselect(pivot_index + 1, right, index)

    def partition(left, right):
        pivot = arr[right]
        i = left
        for j in range(left, right):
            if arr[j] < pivot:
                (arr[i], arr[j]) = (arr[j], arr[i])
                i += 1
        (arr[i], arr[right]) = (arr[right], arr[i])
        return i
    return quickselect(0, len(arr) - 1, k - 1)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-14 15:19:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.
    
    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.
    
    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:27:35 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:27:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:27:36 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:27:36 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:27:36 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:27:36 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:27:36 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:27:36 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:27:37 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:27:38 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:27:38 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:27:38 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:27:38 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:27:38 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:27:39 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:27:39 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:27:39 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:27:39 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:27:39 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:27:39 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:27:39 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:27:39 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:27:54 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:27:55 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:27:56 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:27:57 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:27:57 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:27:58 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:27:58 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:27:58 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:27:58 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:27:59 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:27:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:28:00 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:28:04 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:28:05 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:28:15 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:29:07 - Error: .
 Solution: def square_Sum(n):
    if n < 0:
        return 0
    return n * n * (2 * n * n - 1) // 3.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-14 15:29:18 - Error: .
 Solution: def string_to_tuple(str1):
    if isinstance(str1, str):
        return tuple(str1)
    return ().
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:29:20 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:29:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:29:29 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 0
    seen = set()
    for sublist in lst:
        sublist_tuple = tuple(sublist)
        if sublist_tuple not in seen:
            seen.add(sublist_tuple)
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
            seen = {sublist_tuple}
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-14 15:29:29 - Error: .
 Solution: import math
def surfacearea_cylinder(radius, height):
    """
    Calculate the surface area of a cylinder given its radius and height.

    Parameters:
    radius (float): The radius of the cylinder.
    height (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.

    Raises:
    ValueError: If radius or height is negative.
    TypeError: If radius or height is not a number.
    """
    if not isinstance(radius, (int, float)) or not isinstance(height, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if radius < 0 or height < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * radius * (radius + height)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:29:32 - Error: Both real_part and imaginary_part must be numeric..
 Solution: import cmath
def angle_complex(real_part, imaginary_part):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    real_part (float): The real part of the complex number.
    imaginary_part (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.

    Raises:
    ValueError: If the complex number is zero.
    TypeError: If the inputs are not numeric.
    """
    if not isinstance(real_part, (int, float)) or not isinstance(imaginary_part, (int, float)):
        raise TypeError('Both real_part and imaginary_part must be numeric.')
    if real_part == 0 and imaginary_part == 0:
        raise ValueError('The angle of the zero complex number is undefined.')
    return cmath.phase(complex(real_part, imaginary_part)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:29:37 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    if not nums:
        return averages
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            try:
                avg = sum(inner_tuple) / len(inner_tuple)
                averages.append(round(avg, 2))
            except TypeError:
                averages.append(None)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:29:39 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:29:39 - Error: .
 Solution: def extract_freq(test_list):
    """
    Extracts the number of unique tuples from the given list.

    Parameters:
    test_list (list): A list that may contain tuples.

    Returns:
    int: The count of unique tuples in the list.
    """
    unique_tuples = set()
    for item in test_list:
        if isinstance(item, tuple):
            unique_tuples.add(item)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:29:39 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:29:42 - Error: .
 Solution: def start_withp(words):
    """
    Returns the first two words from the list that start with the letter 'p'.
    
    Parameters:
    words (list): A list of words (strings).
    
    Returns:
    tuple: A tuple containing exactly two words that start with 'p', 
           or None for missing words.
    """
    filtered_words = [word for word in words if word.lower().startswith('p')]
    if len(filtered_words) < 2:
        return tuple(filtered_words) + (None,) * (2 - len(filtered_words))
    return tuple(filtered_words[:2]).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:29:42 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:29:52 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of integers from 1 to n-1.

    Parameters:
    n (int): The upper limit for the harmonic sum calculation.

    Returns:
    float: The harmonic sum of integers from 1 to n-1.

    Raises:
    ValueError: If n is less than or equal to 1.
    """
    if not isinstance(n, int) or n <= 1:
        raise ValueError('Input must be an integer greater than 1.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:30:21 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:31:34 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return bool(re.fullmatch('ab+', text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:31:44 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:31:45 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:31:45 - Error: .
 Solution: def dif_Square(n):
    """
    Check if the given number n can be represented as the difference of two squares.
    A number can be expressed as the difference of two squares if it is of the form
    n % 4 == 0 or n % 4 == 1.
    """
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:31:52 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for element in test_tup:
        if isinstance(element, tuple):
            result.extend(remove_nested(element))
        else:
            result.append(element)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-14 15:31:52 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of characters.
    
    Parameters:
    str1 (str): The input string to be converted.
    
    Returns:
    tuple: A tuple containing the characters of the string.
    """
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:31:53 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''

    def generator():
        capitalize_next = False
        for char in word:
            if char == '_':
                capitalize_next = True
            elif capitalize_next:
                yield char.upper()
                capitalize_next = False
            else:
                yield char.lower()
    return ''.join(generator()).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:31:58 - Error: .
 Solution: def is_undulating(n):
    if n < 10:
        return True
    prev1 = n % 10
    n //= 10
    prev2 = n % 10
    n //= 10
    if prev1 == prev2:
        return False
    while n > 0:
        current = n % 10
        if prev2 < prev1 < current or prev2 > prev1 > current:
            return False
        prev2 = prev1
        prev1 = current
        n //= 10
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-14 15:32:06 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:32:07 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        return None
    return sorted(arr)[k - 1].
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-14 15:32:08 - Error: float division by zero.
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    V = max(r, g, b)
    if V == 0:
        S = 0
        H = 0
    else:
        S = (V - min(r, g, b)) / V
        if V == r:
            H = (g - b) / (V - min(r, g, b))
        elif V == g:
            H = 2.0 + (b - r) / (V - min(r, g, b))
        else:
            H = 4.0 + (r - g) / (V - min(r, g, b))
        H *= 60
        if H < 0:
            H += 360
    return (H, S, V).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-14 15:32:09 - Error: .
 Solution: def remove_odd(str1):
    if not str1:
        return ''
    return ''.join((char for char in str1 if ord(char) % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:32:15 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:32:22 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for t in nums:
        if len(t) == 0:
            averages.append(0)
        else:
            avg = sum(t) / len(t)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:32:27 - Error: .
 Solution: def second_smallest(numbers):
    if not isinstance(numbers, list):
        return None
    if len(numbers) < 2:
        return None
    for x in numbers:
        if not isinstance(x, (int, float)):
            return None
    if len(numbers) == 2:
        return max(numbers)
    min1 = float('inf')
    min2 = float('inf')
    for number in numbers:
        if number < min1:
            min2 = min1
            min1 = number
        elif min1 < number < min2:
            min2 = number
    return min2 if min2 != float('inf') else None.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-14 15:32:32 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    n = len(s)
    count = 0
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count
s = '123'.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-14 15:32:33 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:32:37 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        prev2 = prev1
        prev1 = current
    return current
n = 10.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-14 15:32:40 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:32:58 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1] if j > 0 else 0
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:34:51 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:34:51 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:34:51 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:34:51 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-14 15:34:51 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:34:51 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:34:51 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:34:52 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:34:52 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:34:52 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:34:52 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:34:52 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:34:52 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:34:52 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:34:52 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:34:52 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:34:53 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:34:53 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:34:53 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:34:53 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:34:53 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:34:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:34:57 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:35:09 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:35:10 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:35:11 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:35:12 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:35:12 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:35:12 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:35:12 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:35:13 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:35:13 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:35:13 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:35:14 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:35:14 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:35:15 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:35:18 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, n // 2 + 1):
        if (n - i * (i + 1) // 2) % (i + 1) == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:35:19 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:35:20 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:35:47 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:35:54 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:35:57 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:35:58 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:35:59 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:36:00 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:36:00 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:36:02 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:36:18 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:37:26 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:37:26 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:37:26 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:37:26 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:37:26 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:37:26 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:37:26 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:37:26 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:37:27 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:37:27 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:37:27 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:37:34 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:37:34 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:37:35 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:37:35 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:37:35 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:37:35 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:37:35 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:37:35 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:37:35 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:37:35 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:37:35 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:37:35 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:37:48 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:37:49 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:37:49 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:37:49 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:37:49 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:37:49 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:37:50 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:37:50 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:37:50 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:37:51 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:37:52 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:37:52 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:37:54 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:37:55 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n > 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:37:58 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:38:18 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:38:19 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:38:20 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:38:21 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:38:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:38:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:38:25 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:38:27 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:38:27 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:38:27 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:38:27 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:38:28 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:38:29 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:38:30 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:38:34 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if (i - 1) % 2 == 0 and (n // i - 1) % 2 == 0:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:38:36 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:38:55 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-14 15:38:55 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:38:55 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:38:55 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:38:55 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:38:55 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:38:55 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:38:55 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:38:56 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:38:56 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:38:56 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:38:56 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:38:56 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:38:56 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:38:57 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:38:57 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:38:57 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-14 15:38:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:38:58 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:38:58 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:38:59 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:38:59 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:39:00 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:39:49 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((word.capitalize() for word in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:39:49 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:39:51 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:39:51 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:40:04 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:40:04 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:40:04 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:40:05 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    number = abs(number)
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:40:10 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:40:18 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:40:41 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:40:41 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:40:42 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:40:42 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:40:43 - Error: .
 Solution: import re
def start_withp(words):
    if not isinstance(words, list):
        return 'Input must be a list.'
    p_words = [word for word in words if isinstance(word, str) and word.lower().startswith('p')]
    if len(p_words) < 2:
        return "Not enough words starting with 'p'."
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:40:43 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:40:44 - Error: .
 Solution: def extract_freq(test_list):
    if not isinstance(test_list, list):
        raise ValueError('Input must be a list')
    unique_tuples = set()
    for item in test_list:
        if isinstance(item, tuple):
            unique_tuples.add(item)
        else:
            raise ValueError('All items in the list must be tuples')
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-14 15:40:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:40:45 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n == 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:40:46 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:40:46 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if n == 0:
        return 0
    if m == 0:
        return 0
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(m + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1] if j > 0 else (i - j) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:40:48 - Error: Input must be a tuple with at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) < 2:
        raise ValueError('Input must be a tuple with at least two elements.')
    return tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:40:48 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:40:48 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0] * (n + 1)
        jacobsthal[0] = 0
        jacobsthal[1] = 1
        for i in range(2, n + 1):
            jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-14 15:40:49 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-14 15:40:49 - Error: .
 Solution: def average_tuple(nums):
    if not nums or not all((isinstance(t, tuple) for t in nums)):
        return []
    averages = []
    for t in nums:
        if not t:
            averages.append(0)
        else:
            avg = sum(t) / len(t)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:40:49 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:40:49 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:40:50 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return (6 * n * n - 6 * n + 2) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:40:50 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-14 15:40:52 - Error: words must be a list of strings.
 Solution: def long_words(n, words):
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer')
    if not isinstance(words, list):
        raise ValueError('words must be a list of strings')
    return [word for word in words if isinstance(word, str) and len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:40:52 - Error: Both a and b must be integers or floats..
 Solution: import cmath
def angle_complex(a, b):
    if isinstance(a, (int, float)) and isinstance(b, (int, float)):
        complex_number = complex(a, b)
        angle = cmath.phase(complex_number)
        return angle
    else:
        raise ValueError('Both a and b must be integers or floats.').
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:40:52 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:40:52 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-14 15:43:13 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:43:17 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:43:21 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:43:23 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:43:26 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1))
    return unique_sum if unique_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:43:27 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:43:40 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    sum_h = 0.0
    for i in range(1, n):
        sum_h += 1 / i
    return sum_h.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:43:44 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    number = abs(number)
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:43:45 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:43:45 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:44:36 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:44:37 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:44:38 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:44:39 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:44:44 - Error: .
 Solution: def dif_Square(n):
    return n % 2 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:44:46 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:44:49 - Error: .
 Solution: def is_undulating(n):
    str_n = str(abs(n))
    if len(str_n) < 2:
        return True
    prev_digit = str_n[0]
    direction = None
    for i in range(1, len(str_n)):
        current_digit = str_n[i]
        if current_digit == prev_digit:
            return False
        current_direction = 'up' if current_digit > prev_digit else 'down'
        if direction is None:
            direction = current_direction
        elif direction == current_direction:
            return False
        prev_digit = current_digit
        direction = 'down' if current_direction == 'up' else 'up'
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-14 15:44:50 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:44:51 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        A[i][0] = 1
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:44:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:44:55 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-14 15:44:57 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:44:59 - Error: words must be a list or tuple.
 Solution: def long_words(n, words):
    if not isinstance(n, int):
        raise ValueError('n must be an integer')
    if not isinstance(words, (list, tuple)):
        raise ValueError('words must be a list or tuple')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:45:00 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:45:05 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:45:22 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((word.capitalize() for word in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:46:30 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:46:31 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:46:33 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:46:35 - Error: .
 Solution: def sum_div(number):
    if number == 0:
        return 0
    number = abs(number)
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:46:36 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:46:36 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:46:38 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:46:42 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:46:45 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:46:45 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:46:53 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    result = []
    for i in range(len(test_tup) - 1):
        product = test_tup[i] * test_tup[i + 1]
        result.append(product)
    return tuple(result).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:48:20 - Error: .
 Solution: def remove_odd(str1):
    if str1 is None:
        return None
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:48:26 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if inner_tuple:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(avg)
        else:
            averages.append(0.0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:48:28 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum if total_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:48:30 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:48:33 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = [part for part in word.split('_') if part]
    if not parts:
        return ''
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:48:33 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    if not all((isinstance(x, (int, float)) for x in test_tup)):
        raise TypeError('All elements in the tuple must be numeric.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:48:37 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:48:41 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:48:46 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified tuples from the given tuple, including nested tuples.

    Parameters:
    test_tup (tuple): The original tuple from which to remove elements.
    to_remove (tuple): The tuple of elements to be removed.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    to_remove_set = set(to_remove)

    def filter_tuples(tup):
        result = []
        for item in tup:
            if isinstance(item, tuple):
                if item not in to_remove_set:
                    result.append(filter_tuples(item))
            elif item not in to_remove_set:
                result.append(item)
        return tuple(result)
    return filter_tuples(test_tup).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-14 15:48:58 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:49:01 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:49:08 - Error: .
 Solution: def start_withp(words):
    """
    Returns a list of up to two words from the input list that start with the letter 'p'.
    
    Parameters:
    words (list): A list of words (strings).
    
    Returns:
    list: A list containing up to two words that start with 'p'. 
          If no such words exist, an empty list is returned.
    
    Notes:
    - The function is case-insensitive and will consider words starting with 'P' or 'p'.
    - If the input list is empty, the function will return an empty list.
    - If fewer than two words start with 'p', the function will return whatever is found (0, 1, or 2 words).
    - Duplicates will be included if they start with 'p'.
    """
    result = []
    for phrase in words:
        for word in phrase.split():
            if word.lower().startswith('p'):
                result.append(word)
                if len(result) == 2:
                    return result
    return result.
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-14 15:49:13 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:49:16 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-14 15:49:17 - Error: .
 Solution: def test_three_equal(x, y, z):
    if x == y == z:
        return 3
    elif x == y or y == z or x == z:
        return 1
    return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:49:20 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    seen = set()
    for item in lst:
        if isinstance(item, list):
            item_tuple = tuple(item)
            if item_tuple not in seen:
                seen.add(item_tuple)
                current_length += len(item)
            else:
                current_length = len(item)
                seen = {item_tuple}
        elif item not in seen:
            seen.add(item)
            current_length += 1
        else:
            current_length = 1
            seen = {item}
        max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-14 15:49:28 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:50:59 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    if not all((c.islower() or c == '_' for c in word)):
        raise ValueError('Input must be a valid snake case string (lowercase letters and underscores only).')
    if word.startswith('_') or word.endswith('_') or '__' in word:
        raise ValueError('Input must not have leading, trailing, or consecutive underscores.')
    split_words = word.split('_')
    if len(split_words) == 1:
        return split_words[0]
    camel_case = split_words[0] + ''.join((word.capitalize() for word in split_words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:51:00 - Error: .
 Solution: def remove_odd(input_string):
    return input_string[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:51:05 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:51:07 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    count = {}
    for num in arr:
        if not isinstance(num, (int, str)):
            raise ValueError('All elements must be integers or strings.')
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:51:09 - Error: .
 Solution: def find_star_num(n):
    """
    Calculate the n-th star number.
    
    A star number is given by the formula: n * (3 * n - 1) // 2.
    
    Parameters:
    n (int): A positive integer representing the position of the star number.
    
    Returns:
    int: The n-th star number.
    
    Raises:
    ValueError: If n is not a positive integer.
    """
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    star_number = n * (3 * n - 1) // 2
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-14 15:51:10 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for num_tuple in nums:
        if not isinstance(num_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(num_tuple) == 0:
            averages.append(None)
        else:
            try:
                avg = round(sum(num_tuple) / len(num_tuple), 2)
                averages.append(avg)
            except TypeError:
                raise ValueError('All elements in the inner tuples must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:51:11 - Error: .
 Solution: def sum_div(number: int) -> int:
    if number < 1:
        return 0
    total = 0
    for i in range(1, int(number ** 0.5) + 1):
        if number % i == 0:
            total += i
            if i != number // i:
                total += number // i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:51:15 - Error: Both a and b must be numbers..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle of a complex number.
    
    Parameters:
    a (float): Real part of the complex number.
    b (float): Imaginary part of the complex number.
    
    Returns:
    float: Angle of the complex number in radians.
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numbers.')
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:51:15 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder (must be non-negative).
    h (float): The height of the cylinder (must be non-negative).

    Returns:
    float: The surface area of the cylinder, rounded to two decimal places.

    Raises:
    ValueError: If radius or height is negative.
    TypeError: If radius or height is not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:52:09 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of its characters.

    Parameters:
    str1 (str): The input string to be converted.

    Returns:
    tuple: A tuple containing the characters of the input string.
    """
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:52:16 - Error: .
 Solution: from collections import Counter
def Diff(li1, li2):
    """
    Returns the difference between two lists, maintaining duplicates.
    
    Parameters:
    li1 (list): The first list.
    li2 (list): The second list.
    
    Returns:
    list: A list containing elements that are in li1 but not in li2.
    """
    li2_count = Counter(li2)
    result = []
    for item in li1:
        if li2_count[item] > 0:
            li2_count[item] -= 1
        else:
            result.append(item)
    return result.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:52:28 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:54:11 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-14 15:54:12 - Error: .
 Solution: def string_to_tuple(str1: str) -> tuple:
    """
    Convert a given string to a tuple of its characters.

    Args:
    str1 (str): The input string to be converted.

    Returns:
    tuple: A tuple containing each character of the string.
           Returns an empty tuple if the input string is empty.
    """
    return tuple(str1) if str1 is not None else ().
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-14 15:54:13 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-14 15:54:14 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:54:14 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-14 15:54:14 - Error: Function swap_List is not defined in the solution..
 Solution: .
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-14 15:54:15 - Error: Input must be a tuple with at least 2 numeric elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) < 2:
        raise ValueError('Input must be a tuple with at least 2 numeric elements.')
    if not all((isinstance(x, (int, float)) for x in test_tup)):
        raise TypeError('All elements of the input tuple must be numeric (int or float).')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-14 15:54:16 - Error: .
 Solution: def Diff(li1, li2):
    set_li2 = set(li2)
    return list({item for item in li1 if item not in set_li2}).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-14 15:54:17 - Error: .
 Solution: def dif_Square(n):
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-14 15:54:17 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-14 15:54:18 - Error: .
 Solution: def sum_div(number: int) -> int:
    if number < 1:
        return 0
    total_sum = 0
    for i in range(1, number // 2 + 1):
        if number % i == 0:
            total_sum += i
    total_sum += number
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-14 15:54:19 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-14 15:54:20 - Error: .
 Solution: import cmath
def angle_complex(a: float, b: float) -> float:
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle in radians of the complex number a + bi.

    Raises:
    ValueError: If both a and b are zero, as the angle is undefined.
    """
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:54:20 - Error: .
 Solution: from typing import Tuple, List, Union
def average_tuple(nums: Tuple[Tuple[Union[int, float], ...], ...]) -> List[Union[float, None]]:
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-14 15:54:21 - Error: Function Find_Max_Length is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-14 15:54:26 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-14 15:54:34 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = re.compile('^a(b+)$')
    return bool(pattern.match(text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:54:34 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count if count < 3 else 3.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:54:34 - Error: The second argument must be a list of words..
 Solution: def long_words(n, words):
    if not isinstance(words, list):
        raise ValueError('The second argument must be a list of words.')
    if n < 0:
        raise ValueError('The length n must be a non-negative integer.')
    return [word for word in words if isinstance(word, str) and len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-14 15:54:35 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = [w for w in word.split('_') if w]
    if not words:
        return ''
    camel_case = words[0] + ''.join((w.capitalize() for w in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:54:35 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-14 15:54:36 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:54:37 - Error: .
 Solution: import math
def surfacearea_cylinder(r: float, h: float) -> float:
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-14 15:54:38 - Error: Function area_polygon is not defined in the solution..
 Solution: from math import tan, pi.
 Test: def check():
    assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)
    assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)
    assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)

2025-10-14 15:54:38 - Error: Function find_Odd_Pair is not defined in the solution..
 Solution: from typing import List.
 Test: def check():
    assert find_Odd_Pair([5,4,7,2,1],5) == 6
    assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12
    assert find_Odd_Pair([1,2,3],3) == 2

2025-10-14 15:54:40 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-14 15:54:42 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((key for (key, value) in count.items() if value == 1))
    return unique_sum if unique_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:54:44 - Error: .
 Solution: def is_undulating(n):
    str_n = str(abs(n))
    if len(str_n) < 2:
        return True
    previous = str_n[0]
    is_increasing = None
    for i in range(1, len(str_n)):
        current = str_n[i]
        if current == previous:
            return False
        if is_increasing is None:
            is_increasing = current > previous
        else:
            if is_increasing and current < previous or (not is_increasing and current > previous):
                return False
            is_increasing = not is_increasing
        previous = current
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-14 15:55:19 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((word.capitalize() for word in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-14 15:55:21 - Error: .
 Solution: def remove_odd(str1):
    if not isinstance(str1, str):
        return ''
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-14 15:55:22 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-14 15:55:22 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-14 15:55:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-14 15:55:25 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((key for (key, value) in count.items() if value == 1)) + sum((key for key in arr if count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-14 15:55:29 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    try:
        return cmath.phase(complex(a, b))
    except TypeError:
        raise TypeError('Inputs must be real numbers.').
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-14 15:55:31 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-14 15:55:31 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    start = 0
    seen = set()
    for end in range(len(lst)):
        while tuple(lst[end]) in seen:
            seen.remove(tuple(lst[start]))
            start += 1
        seen.add(tuple(lst[end]))
        max_length = max(max_length, end - start + 1)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-15 14:19:13 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 14:19:14 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 14:19:14 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:19:14 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-15 14:19:14 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:19:14 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-15 14:19:15 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 14:19:16 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:19:16 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 14:19:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:19:18 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:19:21 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:19:22 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 14:19:22 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:19:22 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 14:19:23 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:19:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 14:19:23 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:19:24 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 14:19:24 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:19:25 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 14:19:26 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 14:19:53 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-15 14:19:53 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:19:53 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 14:19:53 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:19:54 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 14:19:54 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:19:55 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:19:55 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:19:55 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    for k in range(1, n):
        if (n - k * (k + 1) // 2) % k == 0 and (n - k * (k + 1) // 2) // k > 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 14:19:55 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 14:19:55 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 14:19:56 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:19:58 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 14:20:07 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 14:20:09 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:20:09 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-15 14:20:09 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:20:10 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:20:10 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:20:10 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 14:20:10 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 14:20:11 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 14:20:41 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:20:41 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 14:20:41 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:20:42 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 14:20:42 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-15 14:20:42 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:20:42 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:20:42 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 14:20:42 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 14:20:42 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 14:20:52 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 14:20:57 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:20:57 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:20:57 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-15 14:20:58 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:20:58 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 14:20:58 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 14:20:58 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:20:59 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:20:59 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:21:00 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 14:21:00 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 14:22:41 - Error: Function square_Sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-15 14:22:49 - Error: Function opposite_Signs is not defined in the solution..
 Solution: .
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-15 14:22:50 - Error: .
 Solution: def remove_nested(test_tup):
    result = []

    def flatten(tup):
        for item in tup:
            if isinstance(item, tuple):
                flatten(item)
            else:
                result.append(item)
    flatten(test_tup)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-15 14:22:52 - Error: Function find_Odd_Pair is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Odd_Pair([5,4,7,2,1],5) == 6
    assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12
    assert find_Odd_Pair([1,2,3],3) == 2

2025-10-15 14:22:58 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:22:58 - Error: Function Split is not defined in the solution..
 Solution: .
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-15 14:22:58 - Error: Function find_Parity is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-15 14:22:58 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: .
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-15 14:22:58 - Error: .
 Solution: def string_to_tuple(str1):
    if not str1:
        return ()
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 14:22:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for k in range(1, n):
        harmonic_sum_value += 1 / k
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:22:59 - Error: .
 Solution: def text_match_zero_one(text):
    if not text or text[0] != 'a':
        return False
    has_a = True
    has_b_after_a = False
    for char in text[1:]:
        if char == 'b':
            has_b_after_a = True
        elif char == 'a':
            has_b_after_a = False
    return has_b_after_a.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:22:59 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:23:00 - Error: .
 Solution: def bell_number(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        prev = dp[0]
        dp[0] = 0
        for j in range(1, i + 1):
            current = dp[j]
            dp[j] = j * current + prev
            prev = current
    return dp[n].
 Test: def check():
    assert bell_number(2)==2
    assert bell_number(10)==115975
    assert bell_number(56)==6775685320645824322581483068371419745979053216268760300

2025-10-15 14:23:01 - Error: .
 Solution: def is_polite(n):
    while n > 0 and n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 14:23:02 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for j in range(min(k, len(nums2))):
        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if i + 1 < len(nums1):
            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 14:23:06 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:23:08 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 14:23:14 - Error: .
 Solution: def start_withp(words):
    if len(words) < 2:
        return ()
    found_words = []
    for word in words:
        if word.lower().startswith('p'):
            found_words.append(word)
            if len(found_words) == 2:
                return tuple(found_words)
    return ().
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 14:23:54 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(0, len(str1), 2))).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:24:02 - Error: median_trapezium() takes 2 positional arguments but 3 were given.
 Solution: def median_trapezium(base1, base2):
    return (base1 + base2) / 2.0.
 Test: def check():
    assert median_trapezium(15,25,35)==20
    assert median_trapezium(10,20,30)==15
    assert median_trapezium(6,9,4)==7.5

2025-10-15 14:24:02 - Error: .
 Solution: def long_words(n, words):
    if not words or n < 0:
        return words if words else []
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:24:02 - Error: Function find_Volume is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-15 14:24:09 - Error: .
 Solution: def Diff(li1, li2):
    set_li2 = set(li2)
    difference = [item for item in li1 if item not in set_li2]
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-15 14:24:10 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    unique_sum = sum((x for x in count if count[x] == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:24:11 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 14:24:12 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1 or arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:24:12 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    (a, b) = (0, 1)
    for i in range(2, n + 1):
        (a, b) = (b, a + 2 * b)
    return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-15 14:24:18 - Error: unhashable type: 'list'.
 Solution: def Find_Max_Length(lst):
    n = len(lst)
    if n == 0:
        return 0
    max_length = 0
    start = 0
    seen = {}
    for end in range(n):
        if lst[end] in seen:
            start = max(start, seen[lst[end]] + 1)
        seen[lst[end]] = end
        current_length = end - start + 1
        max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-15 14:24:19 - Error: .
 Solution: def sum_div(n):
    if n < 1:
        return 0
    total_sum = 0
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            total_sum += i
            if i != n // i:
                total_sum += n // i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 14:24:19 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-15 14:24:26 - Error: Function swap_List is not defined in the solution..
 Solution: .
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-15 14:25:23 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = [part for part in word.split('_') if part]
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:25:30 - Error: .
 Solution: def remove_odd(str1):
    if not str1:
        return ''
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:25:54 - Error: .
 Solution: def Diff(li1, li2):
    if not li1:
        return []
    if not li2:
        return li1
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-15 14:26:26 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    if n % 4 == 2:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 14:27:14 - Error: .
 Solution: def find_star_num(n):
    if n <= 0:
        return 0
    return n * (2 * n - 1) * (n + 1) // 6.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 14:27:15 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:27:15 - Error: Input must be a list of strings..
 Solution: def long_words(n, words):
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('Input must be a list of strings.')
    if not isinstance(n, int) or n < 0:
        raise ValueError('Length n must be a non-negative integer.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:27:15 - Error: .
 Solution: def is_undulating(n):
    digits = str(abs(n))
    if len(digits) < 2:
        return True
    previous_digit = digits[0]
    is_increasing = None
    for current_digit in digits[1:]:
        if current_digit == previous_digit:
            return False
        if is_increasing is None:
            is_increasing = current_digit > previous_digit
        elif (current_digit > previous_digit) == is_increasing:
            return False
        previous_digit = current_digit
        is_increasing = not is_increasing
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-15 14:27:23 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative values.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:27:46 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1) if str1 is not None else ().
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 14:27:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:27:48 - Error: .
 Solution: import cmath
import math
def angle_complex(a, b):
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    complex_number = complex(a, b)
    return cmath.phase(complex_number).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:27:55 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:30:03 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:30:03 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = [part for part in word.split('_') if part]
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:30:52 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    return n != 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 14:30:52 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, min(i, m) + 1):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 14:30:58 - Error: Input must be a list of words..
 Solution: def long_words(n, words):
    if not isinstance(words, list):
        raise ValueError('Input must be a list of words.')
    if not all((isinstance(word, str) for word in words)):
        raise ValueError('All elements in the list must be strings.')
    if not isinstance(n, int) or n < 0:
        raise ValueError('Length n must be a non-negative integer.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 14:31:00 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z: complex) -> float:
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 14:31:00 - Error: Function surfacearea_cylinder is not defined in the solution..
 Solution: import math.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 14:31:00 - Error: Function is_polite is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 14:31:06 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:31:06 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-15 14:31:16 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(inner, tuple) for inner in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 14:31:16 - Error: Function start_withp is not defined in the solution..
 Solution: .
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 14:31:23 - Error: .
 Solution: from collections import Counter
from typing import List, Union
def find_sum(arr: List[Union[int, float]]) -> float:
    if not arr:
        return 0.0
    counts = Counter(arr)
    non_repeated_sum = sum((num for (num, count) in counts.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:31:25 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 14:32:33 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n <= 1:
        return 0.0
    harmonic_sum_value = sum((1 / i for i in range(1, n)))
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:34:03 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 14:34:20 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    if count == 2:
        return 2
    return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 14:34:53 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if n == 0 or m < 0 or m > n:
        return 0
    E = [[0] * (n + 1) for _ in range(n + 1)]
    E[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            E[i][j] = (i - 1) * E[i - 1][j] + (j + 1) * E[i - 1][j - 1]
    return E[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 14:35:31 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((component.capitalize() for component in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 14:35:33 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 14:35:34 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 14:35:40 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 14:35:41 - Error: .
 Solution: import heapq
def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-15 14:35:58 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the base of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder, rounded to two decimal places.
    
    Raises:
    ValueError: If radius or height is negative or not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 16:51:40 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 16:51:40 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-15 16:51:41 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 16:51:41 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 16:51:41 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 16:51:42 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 16:51:42 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 16:51:42 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 16:51:42 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 16:51:42 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 16:51:42 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return False
    return True
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 16:51:43 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 16:51:43 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 16:51:45 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 16:51:45 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 16:51:45 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-15 16:51:45 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-15 16:51:46 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 16:51:46 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 16:51:46 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 16:51:46 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 16:51:46 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 16:51:47 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 16:54:56 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-15 16:54:57 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-15 16:54:57 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-15 16:54:58 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 16:54:58 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-15 16:54:58 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-15 16:54:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 16:54:58 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 16:54:58 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 16:54:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 16:55:00 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 16:55:00 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-15 16:55:00 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 16:55:00 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-15 16:55:00 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-15 16:55:01 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 16:55:01 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 16:55:01 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 16:55:02 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-15 16:55:02 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-15 16:55:03 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-15 16:55:03 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-15 16:55:04 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-15 16:57:33 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-15 16:57:34 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case_words = []
    for (i, w) in enumerate(words):
        if w:
            if i == 0:
                camel_case_words.append(w.lower())
            else:
                camel_case_words.append(w.capitalize())
    return ''.join(camel_case_words).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-15 16:57:50 - Error: .
 Solution: def sum_div(number):
    if not isinstance(number, int):
        raise TypeError('Input must be an integer.')
    if number <= 0:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-15 16:57:51 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-15 16:57:56 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-15 16:58:12 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-15 16:58:14 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-15 16:58:15 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n <= 1:
        return 0.0
    sum_harmonic = 0.0
    for i in range(1, n):
        sum_harmonic += 1 / i
    return sum_harmonic.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-15 16:58:26 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-15 16:58:30 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < len(arr) - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-15 16:59:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Both radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-15 17:01:33 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:23:32 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:23:32 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:23:32 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:23:33 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:23:33 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:23:33 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:23:33 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 09:23:33 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:23:33 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:23:33 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 09:23:33 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 09:23:34 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:23:34 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:23:34 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 09:23:34 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:23:35 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 09:23:35 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:23:35 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:23:36 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 09:23:36 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:23:36 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:23:37 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i % 2 == 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:23:37 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:23:55 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:23:55 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:23:55 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:23:55 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:23:57 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:23:57 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:24:01 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:24:02 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:24:02 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:24:04 - Error: .
 Solution: def get_max_sum(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 09:24:04 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:24:04 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:24:04 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:24:06 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:24:09 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:24:10 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:25:09 - Error: .
 Solution: def is_divisible_by_11(n):
    return n % 11 == 0
def is_Diff(n):
    return not is_divisible_by_11(n).
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 09:25:11 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:25:17 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Returns the angle (phase) of a complex number in radians.
    
    Parameters:
    z (complex): The complex number.
    
    Returns:
    float: The angle of the complex number in radians.
    """
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:25:18 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:25:19 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum if total_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:25:25 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the base of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    return 2 * math.pi * r * (h + r).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:25:31 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    elif count == 2:
        return 2
    else:
        return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:25:33 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:25:34 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:25:37 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:25:42 - Error: .
 Solution: def remove_nested(test_tup):
    flat_list = []
    for item in test_tup:
        if isinstance(item, tuple):
            flat_list.extend(remove_nested(item))
        else:
            flat_list.append(item)
    return tuple(flat_list).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 09:25:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:25:48 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 09:25:50 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    direction = None
    for i in range(1, len(s)):
        if s[i] > s[i - 1]:
            if direction is None:
                direction = 'up'
            elif direction == 'down':
                return False
            direction = 'up'
        elif s[i] < s[i - 1]:
            if direction is None:
                direction = 'down'
            elif direction == 'up':
                return False
            direction = 'down'
        else:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-16 09:25:58 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m] if 0 <= m <= n else 0.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:27:20 - Error: Input must be a tuple with at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) < 2:
        raise ValueError('Input must be a tuple with at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-16 09:27:29 - Error: .
 Solution: def square_Sum(n):
    return n ** 2 * (2 * n - 1) * (2 * n + 1) // 3
n = 5.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-16 09:27:35 - Error: .
 Solution: def round_and_sum(list1):
    if not isinstance(list1, list):
        print('Input must be a list.')
        return
    if not list1:
        print(0)
        return
    total_sum = 0
    for num in list1:
        if not isinstance(num, (int, float)):
            print('All elements in the list must be numbers.')
            return
        total_sum += round(num)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 09:27:36 - Error: .
 Solution: def find_star_num(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('n must be a positive integer.')
    star_number = n * (2 * n - 1) * (2 * n - 2) // 6 + 1
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:27:40 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    if not isinstance(nums, tuple) or not all((isinstance(tup, tuple) for tup in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    for tup in nums:
        if not tup:
            averages.append(0)
        else:
            averages.append(sum(tup) / len(tup))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:27:41 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum if total_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:27:47 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:27:50 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((component.capitalize() for component in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:27:53 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = 0
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            for a in list1[i]:
                for b in list1[j]:
                    max_product = max(max_product, abs(a * b))
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:27:57 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:27:57 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified elements from the given tuple.

    Parameters:
    test_tup (tuple): The original tuple from which to remove elements.
    to_remove (tuple): A tuple containing elements to be removed.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    if not isinstance(test_tup, tuple) or not isinstance(to_remove, tuple):
        raise ValueError('Both inputs must be tuples.')
    to_remove_set = set(to_remove)
    result = []
    for item in test_tup:
        if item not in to_remove_set:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 09:27:57 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:28:01 - Error: Both real and imaginary parts must be numbers..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.

    Raises:
    ValueError: If the complex number is zero (both parts are zero).
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError('Both real and imaginary parts must be numbers.')
    if a == 0 and b == 0:
        raise ValueError('The complex number cannot be zero.')
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:28:15 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    surface_area = lateral_surface_area + 2 * base_area
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:28:19 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer greater than 0.')
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:28:27 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0:
        return 0
    elif n == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        prev2 = prev1
        prev1 = current
    return current
n = 10.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 09:28:35 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:28:52 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j]
            elif j == i:
                eulerian[i][j] = (i - 1) * eulerian[i - 1][j - 1] + 1
            else:
                eulerian[i][j] = (i - 1) * (eulerian[i - 1][j - 1] + eulerian[i - 1][j])
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:29:49 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:29:55 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:30:17 - Error: .
 Solution: def square_Sum(n):
    if n <= 0:
        return 0
    return n * n * (2 * n * n - 1) // 3.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-16 09:30:17 - Error: Both real and imaginary parts must be numeric values..
 Solution: import cmath
import math
def angle_complex(real, imaginary):
    if not isinstance(real, (int, float)) or not isinstance(imaginary, (int, float)):
        raise ValueError('Both real and imaginary parts must be numeric values.')
    z = complex(real, imaginary)
    return cmath.phase(z) if z != 0 else None.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:30:18 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    difference = list(set(li1) ^ set(li2))
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 09:30:20 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list) or not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input must be a list of integers.')
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    unique_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return unique_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:30:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    if r == 0 or h == 0:
        return 0.0
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:30:27 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:30:36 - Error: .
 Solution: def remove_nested(test_tup):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 09:30:39 - Error: .
 Solution: def count_rotation(arr):
    if not isinstance(arr, list) or not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input must be a list of integers.')
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        if arr[left] <= arr[right]:
            return left
        mid = (left + right) // 2
        if (mid == 0 or arr[mid] < arr[mid - 1]) and (mid == n - 1 or arr[mid] < arr[mid + 1]):
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:30:48 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:30:50 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not isinstance(tup, tuple):
            raise ValueError('Each element must be a tuple.')
        if tup:
            avg = sum(tup) / len(tup)
            averages.append(avg)
        else:
            averages.append(0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:31:18 - Error: .
 Solution: def common_element(list1, list2):
    set1 = set(list1)
    for element in list2:
        if element in set1:
            return True
    return False.
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-16 09:31:23 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n < 1:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-16 09:31:24 - Error: .
 Solution: def check_Consecutive(l):
    if len(l) < 2:
        return False
    unique_numbers = set(l)
    min_num = min(unique_numbers)
    max_num = max(unique_numbers)
    return max_num - min_num == len(unique_numbers) - 1.
 Test: def check():
    assert check_Consecutive([1,2,3,4,5]) == True
    assert check_Consecutive([1,2,3,5,6]) == False
    assert check_Consecutive([1,2,1]) == False

2025-10-16 09:31:46 - Error: .
 Solution: def group_tuples(input_list):
    if not isinstance(input_list, list) or not all((isinstance(t, tuple) for t in input_list)):
        raise ValueError('Input must be a list of tuples.')
    if not input_list:
        return None
    grouped = []
    current_group = []
    for t in input_list:
        if not current_group or t[0] == current_group[0][0]:
            current_group.append(t)
        else:
            grouped.append(tuple((x[0] for x in current_group)))
            current_group = [t]
    if current_group:
        grouped.append(tuple((x[0] for x in current_group)))
    return grouped.
 Test: def check():
    assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]
    assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]
    assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]

2025-10-16 09:31:46 - Error: .
 Solution: def find_lists(input_tuple):
    return sum((1 for item in input_tuple if isinstance(item, list))).
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-16 09:31:47 - Error: .
 Solution: def triangle_area(r):
    if r <= 0:
        return None
    area = 1 / 2 * (2 * r) * r
    return area.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-16 09:31:49 - Error: count_Pairs() takes 1 positional argument but 2 were given.
 Solution: def count_Pairs(arr):
    if not isinstance(arr, list) or not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input must be a list of integers.')
    n = len(arr)
    if n < 2:
        return 0
    frequency = {}
    for num in arr:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1
    total_pairs = n * (n - 1) // 2
    identical_pairs = sum((count * (count - 1) // 2 for count in frequency.values()))
    return total_pairs - identical_pairs.
 Test: def check():
    assert count_Pairs([1,2,1],3) == 2
    assert count_Pairs([1,1,1,1],4) == 0
    assert count_Pairs([1,2,3,4,5],5) == 10

2025-10-16 09:31:51 - Error: .
 Solution: import re
def text_starta_endb(text):
    pattern = re.compile('a.*b')
    return bool(pattern.search(text)).
 Test: def check():
    assert text_starta_endb("aabbbb")
    assert not text_starta_endb("aabAbbbc")
    assert not text_starta_endb("accddbbjjj")

2025-10-16 09:31:54 - Error: .
 Solution: import re
def find_adverbs(text):
    if not isinstance(text, str):
        raise ValueError('Input must be a string.')
    pattern = '\\b\\w+ly\\b'
    matches = re.finditer(pattern, text)
    for match in matches:
        return f'{match.start()}-{match.end() - 1}: {match.group(0)}'
    return None
text = 'Clearly, he has no excuse for such behavior.'.
 Test: def check():
    assert find_adverbs("Clearly, he has no excuse for such behavior.") == '0-7: Clearly'
    assert find_adverbs("Please handle the situation carefuly") == '28-36: carefuly'
    assert find_adverbs("Complete the task quickly") == '18-25: quickly'

2025-10-16 09:31:55 - Error: .
 Solution: def combinations_list(input_list):
    if not isinstance(input_list, list):
        raise ValueError('Input must be a list.')
    results = [[]]

    def backtrack(start, path):
        for i in range(start, len(input_list)):
            results.append(path + [input_list[i]])
            backtrack(i + 1, path + [input_list[i]])
    backtrack(0, [])
    return results.
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-16 09:31:56 - Error: .
 Solution: import math
def wind_chill(v, t):
    if v < 0:
        raise ValueError('Wind velocity must be non-negative.')
    if t < -100 or t > 50:
        raise ValueError('Temperature must be between -100C and 50C.')
    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wci).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-16 09:32:03 - Error: .
 Solution: def find_Max_Num(arr):
    if not isinstance(arr, list) or not all((isinstance(x, int) for x in arr)):
        raise ValueError('Input must be a list of integers.')
    if not arr:
        return '0'
    arr = [str(x) for x in arr]
    arr.sort(key=lambda x: x * 10, reverse=True)
    largest_num = ''.join(arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-16 09:32:03 - Error: .
 Solution: def surface_Area(b, s):
    """
    Calculate the surface area of a square pyramid given the base edge and height.

    Parameters:
    b (float): The length of the base edge of the pyramid.
    s (float): The height of the pyramid.

    Returns:
    float: The total surface area of the pyramid.

    Raises:
    ValueError: If base edge or height is negative.
    """
    if b < 0 or s < 0:
        raise ValueError('Base edge and height must be non-negative.')
    if b == 0 or s == 0:
        return 0.0
    base_area = b * b
    slant_height = (s ** 2 + (b / 2) ** 2) ** 0.5
    lateral_area = 2 * b * slant_height
    total_surface_area = base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-16 09:32:08 - Error: .
 Solution: def comb_sort(nums):
    if not isinstance(nums, list):
        raise ValueError('Input must be a list.')
    n = len(nums)
    if n == 0:
        return nums
    if n == 1:
        return nums
    gap = n
    shrink = 1.3
    sorted = False
    while not sorted:
        gap = int(gap / shrink)
        if gap < 1:
            gap = 1
        sorted = True
        for i in range(n - gap):
            if nums[i] > nums[i + gap]:
                (nums[i], nums[i + gap]) = (nums[i + gap], nums[i])
                sorted = False
    return nums.
 Test: def check():
    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
    assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]
    assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]

2025-10-16 09:32:12 - Error: .
 Solution: def get_coordinates(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) != 2:
        raise ValueError('Input must be a tuple of two integers.')
    (x, y) = test_tup
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    adjacent_coordinates = []
    for (dx, dy) in directions:
        new_x = x + dx
        new_y = y + dy
        adjacent_coordinates.append([new_x, new_y])
    return adjacent_coordinates.
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-16 09:32:18 - Error: .
 Solution: def is_newman_shanks_williams_prime(p):
    if p < 5:
        return False
    if p % 6 != 1 and p % 6 != 5:
        return False
    for i in range(5, int(p ** 0.5) + 1, 6):
        if p % i == 0 or p % (i + 2) == 0:
            return False
    return True
def newman_prime(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    count = 0
    candidate = 5
    while count < n:
        if is_newman_shanks_williams_prime(candidate):
            count += 1
            if count == n:
                return candidate
        candidate += 2
    return None.
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-16 09:32:21 - Error: .
 Solution: def merge_dictionaries_three(dict1, dict2, dict3):
    merged_dict = {}
    merged_dict.update(dict1)
    merged_dict.update(dict2)
    merged_dict.update(dict3)
    return merged_dict
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
dict3 = {'d': 5}.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-16 09:32:22 - Error: .
 Solution: def min_product_tuple(list1):
    if not isinstance(list1, list):
        raise ValueError('Input must be a list.')
    if len(list1) < 2:
        return None
    min_product = float('inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1]
            if product < min_product:
                min_product = product
    return min_product if min_product != float('inf') else None.
 Test: def check():
    assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8
    assert min_product_tuple([(10,20), (15,2), (5,10)] )==30
    assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100

2025-10-16 09:32:27 - Error: .
 Solution: def geometric_sum(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0:
        return 0.0
    return 1 / 2 ** n + geometric_sum(n - 1).
 Test: def check():
    assert geometric_sum(7) == 1.9921875
    assert geometric_sum(4) == 1.9375
    assert geometric_sum(8) == 1.99609375

2025-10-16 09:32:28 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        raise ValueError('Array must contain at least two elements.')
    max1 = max2 = float('-inf')
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return (max2, max1).
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-16 09:32:30 - Error: .
 Solution: def find_dissimilar(test_tup1, test_tup2):
    set1 = set(test_tup1)
    set2 = set(test_tup2)
    dissimilar_from_tup1 = set1 - set2
    dissimilar_from_tup2 = set2 - set1
    result = dissimilar_from_tup1.union(dissimilar_from_tup2)
    return tuple(sorted(result)).
 Test: def check():
    assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)
    assert find_dissimilar((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)
    assert find_dissimilar((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)

2025-10-16 09:32:40 - Error: .
 Solution: def remove_kth_element(list1, k):
    if not isinstance(list1, list):
        raise ValueError('Input must be a list.')
    if k < 0:
        raise ValueError('Index k cannot be negative.')
    if k >= len(list1):
        raise ValueError('Index k is out of bounds.')
    return list1[:k] + list1[k + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-16 09:32:45 - Error: .
 Solution: def set_left_most_unset_bit(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n == 0:
        return 1
    bit_length = n.bit_length()
    for i in range(bit_length, 32):
        if n & 1 << i == 0:
            n |= 1 << i
            return n
    return n | 1 << bit_length.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-16 09:32:45 - Error: name 'defaultdict' is not defined.
 Solution: def max_aggregate(stdata):
    if not stdata:
        return 0
    aggregate = defaultdict(int)
    for (key, value) in stdata:
        aggregate[key] += value
    max_key = max(aggregate, key=aggregate.get)
    return (max_key, aggregate[max_key]).
 Test: def check():
    assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)
    assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)
    assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)

2025-10-16 09:32:48 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if not all((isinstance(i, (int, float)) for i in (a, b, c))):
        raise ValueError("Coefficients 'a', 'b', and 'c' must be numbers.")
    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero for a parabola.")
    x_vertex = -b / (2 * a)
    y_vertex = a * x_vertex ** 2 + b * x_vertex + c
    p = 1 / (4 * abs(a))
    directrix = y_vertex - p if a > 0 else y_vertex + p
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-16 09:32:55 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n < 1:
        return False
    powers_of_2 = []
    power = 1
    while power <= n:
        powers_of_2.append(power)
        power *= 2

    def backtrack(index, current_sum):
        if current_sum == n:
            return True
        if current_sum > n or index >= len(powers_of_2):
            return False
        if backtrack(index + 1, current_sum + powers_of_2[index]):
            return True
        return backtrack(index + 1, current_sum)
    return backtrack(0, 0).
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-16 09:32:55 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    if not isinstance(actual_cost, (int, float)) or not isinstance(sale_amount, (int, float)):
        raise ValueError('Both actual_cost and sale_amount must be numeric values.')
    if actual_cost < 0 or sale_amount < 0:
        raise ValueError('Both actual_cost and sale_amount must be non-negative.')
    loss = actual_cost - sale_amount
    return loss if loss > 0 else 0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-16 09:33:00 - Error: .
 Solution: def min_Jumps(steps, d):
    if not isinstance(steps, int) or not isinstance(d, int):
        return 'Invalid input: steps and d should be integers'
    if steps <= 0:
        return 'Invalid input: steps must be a positive integer'
    if d < 0:
        return 'Invalid input: d must be a non-negative integer'
    if d == 0:
        return 0
    jumps = d // steps
    if d % steps != 0:
        jumps += 1
    return jumps.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-16 09:33:01 - Error: .
 Solution: def extended_gcd(a, b):
    """Return gcd of a and b, and coefficients x, y such that ax + by = gcd(a, b)."""
    if b == 0:
        return (a, 1, 0)
    (gcd, x1, y1) = extended_gcd(b, a % b)
    x = y1
    y = x1 - a // b * y1
    return (gcd, x, y)
def find_solution(a, b, n):
    """Return integers x and y such that ax + by = n, or None if no solution exists."""
    if not all((isinstance(i, int) for i in (a, b, n))):
        raise ValueError('All inputs must be integers.')
    (gcd, x0, y0) = extended_gcd(a, b)
    if n % gcd != 0:
        return None
    x = x0 * (n // gcd)
    y = y0 * (n // gcd)
    return (x, y).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-16 09:33:02 - Error: .
 Solution: def find_Rotations(s: str) -> int:
    if not s:
        return 0
    n = len(s)
    doubled_s = s + s
    index = doubled_s.find(s, 1)
    if index == -1 or index >= n:
        return 0
    return index.
 Test: def check():
    assert find_Rotations("aaaa") == 1
    assert find_Rotations("ab") == 2
    assert find_Rotations("abc") == 3

2025-10-16 09:33:04 - Error: .
 Solution: def merge(lst):
    if not lst:
        return [[], []]
    first_elements = [x[0] for x in lst]
    second_elements = [x[1] for x in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-16 09:33:06 - Error: .
 Solution: def count_vowels(test_str):
    if not isinstance(test_str, str):
        raise ValueError('Input must be a string.')
    vowels = set('aeiouAEIOU')
    count = 0
    n = len(test_str)
    for i in range(n):
        if i > 0 and test_str[i - 1] in vowels or (i < n - 1 and test_str[i + 1] in vowels):
            count += 1
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-16 09:33:13 - Error: .
 Solution: def count_bidirectional(test_list):
    seen = set()
    count = 0
    for (a, b) in test_list:
        if (b, a) in seen:
            count += 1
        seen.add((a, b))
    return count
test_list = [(1, 2), (2, 1), (3, 4), (4, 3), (5, 5)].
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-16 09:33:13 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count_0_1 = 0
    count_1_0 = 0
    for (a, b) in zip(str1, str2):
        if a == '0' and b == '1':
            count_0_1 += 1
        elif a == '1' and b == '0':
            count_1_0 += 1
    return max(count_0_1, count_1_0).
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-16 09:33:14 - Error: .
 Solution: import sys
def tuple_size(tuple_list):
    """Calculate the total size in bytes of a given tuple and its contents."""
    if not isinstance(tuple_list, tuple):
        raise TypeError('Input must be a tuple.')
    total_size = sys.getsizeof(tuple_list)
    for item in tuple_list:
        total_size += sys.getsizeof(item)
    return total_size.
 Test: def check():
    assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
    assert tuple_size((1, "Raju", 2, "Nikhil", 3, "Deepanshu") ) == sys.getsizeof((1, "Raju", 2, "Nikhil", 3, "Deepanshu"))
    assert tuple_size(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf"))  ) == sys.getsizeof(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf")))

2025-10-16 09:33:14 - Error: .
 Solution: def min_k(test_list, K):
    if not test_list or K <= 0:
        return []
    sorted_list = sorted(test_list)
    return sorted_list[:K].
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-16 09:33:18 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    count = 0
    for (a, b) in zip(nums1, nums2):
        if a == b:
            count += 1
    return count.
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-16 09:33:20 - Error: .
 Solution: def count_first_elements(test_tup):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    result = []
    for (i, element) in enumerate(test_tup):
        count_before = sum((1 for j in range(i) if test_tup[j] == element))
        result.append(count_before)
    return result.
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-16 09:33:25 - Error: .
 Solution: def even_bit_set_number(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    mask = 2863311530
    result = n | mask
    return result.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-16 09:33:26 - Error: Input must be a list or tuple of complex numbers..
 Solution: import cmath
def convert(numbers):
    if numbers is None:
        raise ValueError('Input cannot be None.')
    if not isinstance(numbers, (list, tuple)):
        raise ValueError('Input must be a list or tuple of complex numbers.')
    if len(numbers) == 0:
        return []
    polar_coordinates = []
    for number in numbers:
        if not isinstance(number, complex):
            raise ValueError('All elements must be complex numbers.')
        polar_coordinates.append(cmath.polar(number))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-16 09:33:33 - Error: find_combinations() missing 1 required positional argument: 'target_sum'.
 Solution: from itertools import combinations
def find_combinations(tuples_list, target_sum):
    result = []

    def backtrack(start, current_combination, current_sum):
        if current_sum == target_sum:
            result.append(tuple(current_combination))
            return
        if current_sum > target_sum:
            return
        for i in range(start, len(tuples_list)):
            current_combination.append(tuples_list[i])
            backtrack(i + 1, current_combination, current_sum + sum(tuples_list[i]))
            current_combination.pop()
    backtrack(0, [], 0)
    return result
tuples_list = [(1, 2), (3, 4), (5, 6)]
target_sum = 10.
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-16 09:33:42 - Error: .
 Solution: def sort_sublists(input_list):
    for sublist in input_list:
        sublist.sort()
    return input_list
input_list = [['banana', 'apple', 'cherry'], ['dog', 'cat'], ['zebra', 'ant', 'monkey']].
 Test: def check():
    assert sort_sublists((["green", "orange"], ["black", "white"], ["white", "black", "orange"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]
    assert sort_sublists(([" red ","green" ],["blue "," black"],[" orange","brown"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]
    assert sort_sublists((["zilver","gold"], ["magnesium","aluminium"], ["steel", "bronze"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]

2025-10-16 09:33:44 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    if l < 0 or r < 0 or l > r:
        raise ValueError('Invalid range: l and r must be non-negative and l must be less than or equal to r.')
    mask = (1 << r - l + 1) - 1 << l
    return n & mask == 0.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-16 09:33:56 - Error: .
 Solution: def max_sum_increasing_subseq(a, n, index, k):
    if n == 0 or index < 0 or k >= n or (k <= index):
        return 0
    dp = [0] * n
    for j in range(index + 1):
        dp[j] = a[j]
        for m in range(j):
            if a[m] < a[j]:
                dp[j] = max(dp[j], dp[m] + a[j])
    max_sum_up_to_i = max(dp[:index + 1])
    max_sum_with_k = 0
    for j in range(index + 1):
        if a[j] < a[k]:
            max_sum_with_k = max(max_sum_with_k, dp[j] + a[k])
    return max(max_sum_up_to_i, max_sum_with_k)
a = [1, 101, 2, 3, 100, 4, 5]
n = len(a)
index = 4
k = 6.
 Test: def check():
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7
    assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71

2025-10-16 09:34:00 - Error: .
 Solution: from typing import List
def positive_count(nums: List[int]) -> float:
    """
    Calculate the ratio of positive numbers in a list of integers.

    Parameters:
    nums (List[int]): A list of integers.

    Returns:
    float: The ratio of positive numbers to the total count of numbers.
           Returns 0.0 if the list is empty.
    """
    if not nums:
        return 0.0
    positive_count = sum((1 for num in nums if num > 0))
    total_count = len(nums)
    return positive_count / total_count.
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-16 09:34:06 - Error: Function check_occurences is not defined in the solution..
 Solution: from collections import Counter.
 Test: def check():
    assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}
    assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}
    assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}

2025-10-16 09:34:10 - Error: Function find_Element is not defined in the solution..
 Solution: .
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-16 09:34:16 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if not isinstance(tuplex, tuple):
        raise ValueError('Input must be a tuple.')
    if not isinstance(m, int) or not isinstance(n, int):
        raise ValueError('Indices m and n must be integers.')
    if not tuplex:
        return ()
    m = max(0, m)
    n = min(len(tuplex), n)
    if m > n:
        return ()
    result = tuplex[m:n]
    if n > len(tuplex):
        result += (50,)
    return result.
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-16 09:34:21 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits[i + 1:] = reversed(digits[i + 1:])
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-16 09:34:24 - Error: Function Find_Min is not defined in the solution..
 Solution: .
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-16 09:34:31 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    for num in nums_str:
        try:
            float(num)
        except ValueError:
            raise ValueError(f"Invalid numeric string: '{num}'")
    return sorted(nums_str, key=lambda x: float(x)).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-16 09:34:33 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):
        raise TypeError('Both inputs must be tuples')
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Tuples must be of the same length')
    if len(test_tup1) == 0:
        return ()
    result = tuple((a * b for (a, b) in zip(test_tup1, test_tup2)))
    return result.
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-16 09:34:34 - Error: Function is_num_decagonal is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_num_decagonal(3) == 27
    assert is_num_decagonal(7) == 175
    assert is_num_decagonal(10) == 370

2025-10-16 09:34:34 - Error: unsupported operand type(s) for +: 'int' and 'tuple'.
 Solution: def maximize_elements(test_tup1, test_tup2):
    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):
        raise ValueError('Both inputs must be tuples.')
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must be of the same length.')
    if not test_tup1 or not test_tup2:
        return 0
    max_sum = sum((max(a, b) for (a, b) in zip(test_tup1, test_tup2)))
    return max_sum.
 Test: def check():
    assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))
    assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))
    assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))

2025-10-16 09:34:34 - Error: .
 Solution: def trim_tuple(test_list, K):
    if not isinstance(test_list, list) or not all((isinstance(t, tuple) for t in test_list)):
        raise ValueError('Input must be a list of tuples.')
    if not isinstance(K, (int, float)):
        raise ValueError('K must be a number.')
    trimmed_list = []
    for t in test_list:
        trimmed_tuple = tuple((x for x in t if x > K))
        trimmed_list.append(trimmed_tuple)
    return trimmed_list.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-16 09:34:35 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    if not isinstance(text, str) or not isinstance(pattern, str):
        raise ValueError('Both text and pattern must be strings.')
    if not text or not pattern or len(pattern) > len(text):
        return None
    matches = [(match.group(), match.start()) for match in re.finditer(re.escape(pattern), text)]
    return matches if matches else None.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-16 09:34:36 - Error: .
 Solution: def tuple_intersection(test_list1, test_list2):
    if not isinstance(test_list1, list) or not isinstance(test_list2, list):
        raise ValueError('Both inputs must be lists.')
    set1 = set(test_list1)
    set2 = set(test_list2)
    intersection = set1.intersection(set2)
    return tuple(intersection).
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-16 09:34:38 - Error: .
 Solution: def max_difference(test_list):
    if not test_list:
        return None
    overall_min = float('inf')
    overall_max = float('-inf')
    for tup in test_list:
        if not tup:
            raise ValueError('Tuples must not be empty.')
        local_min = min(tup)
        local_max = max(tup)
        overall_min = min(overall_min, local_min)
        overall_max = max(overall_max, local_max)
    return overall_max - overall_min.
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-16 09:34:43 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-16 09:34:44 - Error: .
 Solution: import math
def polar_rect(r, theta):
    """
    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).
    
    Parameters:
    r (float): The radius (distance from origin). Must be non-negative.
    theta (float): The angle in radians.
    
    Returns:
    tuple: A tuple (x, y) representing the rectangular coordinates.
    
    Raises:
    ValueError: If r is negative.
    """
    if r < 0:
        raise ValueError('Radius (r) must be non-negative.')
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return (x, y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-16 09:34:48 - Error: Input must be a string.
 Solution: def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    result = []
    depth = 0
    for char in items:
        if char == '(':
            depth += 1
        elif char == ')':
            depth -= 1
        elif depth == 0:
            result.append(char)
    return ''.join(result).strip()
input_string = 'This is a test (remove this) string (and this too (nested)).'
result = remove_parenthesis(input_string).
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-16 09:34:48 - Error: .
 Solution: def max_length(list1):
    if not list1:
        return None
    max_length = 0
    max_lists = []
    for sublist in list1:
        current_length = len(sublist)
        if current_length > max_length:
            max_length = current_length
            max_lists = [sublist]
        elif current_length == max_length:
            max_lists.append(sublist)
    return (max_length, max_lists).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-16 09:34:49 - Error: .
 Solution: def upper_ctr(s: str) -> int:
    if not isinstance(s, str):
        raise ValueError('Input must be a string')
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-16 09:34:52 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] * arr[i])
    return max(dp)
def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] * arr[i])
    return max(dp) if dp else 0.
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-16 09:34:52 - Error: .
 Solution: def count_no_of_ways(n, k):
    if n == 0:
        return 1
    if n == 1:
        return k
    if k == 1:
        return 0 if n > 2 else 1
    dp = [0] * (n + 1)
    dp[1] = k
    dp[2] = k * k
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] * (k - 1) + dp[i - 2] * 1
    return dp[n].
 Test: def check():
    assert count_no_of_ways(2, 4) == 16
    assert count_no_of_ways(3, 2) == 6
    assert count_no_of_ways(4, 4) == 228

2025-10-16 09:34:53 - Error: .
 Solution: def is_prime(num):
    """Check if a number is prime."""
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
def digit_sum(num):
    """Calculate the sum of digits of a number."""
    return sum((int(digit) for digit in str(num)))
def get_ludic(n):
    """Get all lucid numbers less than or equal to n."""
    if n < 1:
        return []
    lucid_numbers = []
    max_digit_sum = 9 * len(str(n))
    prime_status = [is_prime(i) for i in range(max_digit_sum + 1)]
    for i in range(1, n + 1):
        if prime_status[digit_sum(i)]:
            lucid_numbers.append(i)
    return lucid_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-16 09:34:58 - Error: .
 Solution: def get_Char(input_str):
    if not isinstance(input_str, str):
        raise ValueError('Input must be a string.')
    if not input_str:
        return 'a'
    total_ascii = sum((ord(char) for char in input_str if 0 <= ord(char) <= 127))
    result_index = total_ascii % 26
    return chr(result_index + ord('a')).
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-16 09:35:10 - Error: .
 Solution: def sum_of_digits(nums):
    if not isinstance(nums, list):
        raise ValueError('Input must be a list.')
    if not all((isinstance(num, int) for num in nums)):
        raise ValueError('All elements in the list must be integers.')

    def digit_sum(n):
        return sum((int(digit) for digit in str(abs(n))))
    return [digit_sum(num) for num in nums].
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-16 09:35:12 - Error: closest_num() missing 1 required positional argument: 'N'.
 Solution: def closest_num(arr, N):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if not all((isinstance(x, (int, float)) for x in arr)):
        raise ValueError('All elements in the array must be numbers.')
    closest = None
    for num in arr:
        if num < N:
            if closest is None or num > closest:
                closest = num
    return closest.
 Test: def check():
    assert closest_num(11) == 10
    assert closest_num(7) == 6
    assert closest_num(12) == 11

2025-10-16 09:35:14 - Error: .
 Solution: def and_tuples(test_tup1, test_tup2):
    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):
        raise ValueError('Both inputs must be tuples.')
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must be of the same length.')
    result = tuple((a - b for (a, b) in zip(test_tup1, test_tup2)))
    return result.
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-16 09:35:16 - Error: check_value() takes 1 positional argument but 2 were given.
 Solution: def check_value(d):
    if not isinstance(d, dict):
        raise ValueError('Input must be a dictionary.')
    if not d:
        return True
    first_value = next(iter(d.values()))
    return all((value == first_value for value in d.values())).
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-16 09:41:20 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:41:20 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:41:22 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:41:22 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 09:41:22 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:41:22 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return n == 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:41:22 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:41:24 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:41:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:41:25 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:41:25 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:41:25 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:41:26 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 09:41:26 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 09:41:26 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:41:26 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:41:26 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:41:27 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 09:41:28 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-16 09:41:28 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:41:28 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 09:41:30 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 09:41:35 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 09:42:25 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:42:40 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:42:40 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:42:41 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:42:41 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:42:43 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:42:44 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:42:44 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:42:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:42:47 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:42:47 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:42:49 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    count = 0
    for i in range(1, n + 1):
        if n % i == 0 and i % 2 == 1:
            count += 1
    return count < 2
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:42:49 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:42:49 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:42:52 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:42:54 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:44:07 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:44:07 - Error: .
 Solution: def dif_Square(n):
    if not isinstance(n, int):
        raise ValueError('Input must be an integer.')
    if n < 0:
        return False
    if n == 0:
        return True
    if n == 1:
        return True
    if n == 2:
        return False
    return n % 2 == 0 or n % 2 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:44:08 - Error: .
 Solution: def unique_product(list_data):
    if not isinstance(list_data, list):
        raise ValueError('Input must be a list.')
    unique_numbers = set(list_data)
    product = 1
    has_unique = False
    for number in unique_numbers:
        if not isinstance(number, int):
            raise ValueError('All elements in the list must be integers.')
        if number != 0:
            product *= number
            has_unique = True
    return product if has_unique else 0.
 Test: def check():
    assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000
    assert unique_product([1, 2, 3, 1,]) == 6
    assert unique_product([7, 8, 9, 0, 1, 1]) == 0

2025-10-16 09:44:15 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:44:19 - Error: words must be a list of strings..
 Solution: def long_words(n, words):
    """
    Find words longer than n characters from a given list of words.

    :param n: An integer representing the minimum length of words to include.
    :param words: A list of strings (words).
    :return: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer.')
    if not isinstance(words, list):
        raise ValueError('words must be a list of strings.')
    for word in words:
        if not isinstance(word, str):
            raise ValueError('All elements in words must be strings.')
    return [word for word in words if len(word) > n]
n = 4.
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 09:44:21 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    count = {}
    for num in arr:
        if not isinstance(num, int):
            raise ValueError('All elements in the list must be integers.')
        count[num] = count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:44:22 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 09:44:24 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer.')
    return n * (3 * n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:44:33 - Error: No second smallest element found (all elements may be the same)..
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        raise ValueError('List must contain at least two distinct elements.')
    first = float('inf')
    second = float('inf')
    for number in numbers:
        if number < first:
            second = first
            first = number
        elif first < number < second:
            second = number
    if second == float('inf'):
        raise ValueError('No second smallest element found (all elements may be the same).')
    return second.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-16 09:44:35 - Error: .
 Solution: def snake_to_camel(word):
    if not isinstance(word, str):
        raise ValueError('Input must be a string.')
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:44:40 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:44:43 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(tup) / len(tup) for tup in nums if len(tup) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:44:48 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string.')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:44:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Radius and height must be numbers.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:45:14 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (left, right) = (0, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:45:19 - Error: .
 Solution: def kth_element(arr, k):
    if not arr or k < 1 or k > len(arr):
        raise ValueError('Invalid input: array is empty or k is out of bounds.')

    def partition(arr, low, high):
        pivot_value = arr[high]
        store_index = low
        for i in range(low, high):
            if arr[i] < pivot_value:
                (arr[store_index], arr[i]) = (arr[i], arr[store_index])
                store_index += 1
        (arr[store_index], arr[high]) = (arr[high], arr[store_index])
        return store_index

    def quickselect(arr, low, high, k):
        if low == high:
            return arr[low]
        pivot_index = partition(arr, low, high)
        if k == pivot_index:
            return arr[k]
        elif k < pivot_index:
            return quickselect(arr, low, pivot_index - 1, k)
        else:
            return quickselect(arr, pivot_index + 1, high, k)
    k_index = k - 1
    return quickselect(arr, 0, len(arr) - 1, k_index)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 09:54:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:54:44 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:54:44 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 09:54:44 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:54:44 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:54:44 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:54:44 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 09:54:45 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:54:45 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:54:45 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:54:46 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:54:46 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:54:46 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 09:54:46 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:54:47 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 09:54:47 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:54:47 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:54:48 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return 'Match'
    else:
        return 'No Match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:54:49 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:54:49 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 09:54:50 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:54:50 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 09:54:50 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:55:04 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:55:05 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:55:07 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:55:09 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:55:09 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:55:11 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:55:12 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:55:12 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:55:13 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:55:13 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:55:14 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:55:17 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    count = 0
    for i in range(1, n + 1):
        if n % i == 0 and i % 2 == 1:
            count += 1
    return count > 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:55:19 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product
def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:55:19 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:55:27 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:56:17 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:56:17 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:56:17 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:56:19 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:56:21 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:56:21 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:56:22 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:56:22 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:56:23 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:56:24 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:56:27 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 09:56:33 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:56:35 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:56:37 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:56:38 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:56:41 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:57:07 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 09:57:09 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:57:09 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:57:09 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:57:09 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (n * 2 - 1) // 2.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:57:10 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 09:57:10 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:57:11 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:57:11 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:57:12 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        return None
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0] * (n + 1)
        jacobsthal[0] = 0
        jacobsthal[1] = 1
        for i in range(2, n + 1):
            jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 09:57:15 - Error: .
 Solution: def find_Parity(x):
    return 'Odd' if x % 2 != 0 else 'Even'.
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-16 09:57:15 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:57:16 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 09:57:16 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:57:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_surface_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:57:17 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return 'Matched'
    else:
        return 'Not Matched'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:57:18 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set((tuple(item) for item in test_list))
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 09:57:19 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:57:20 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:57:20 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:57:20 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:57:20 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if re.match('^[pP]', word)]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 09:57:27 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(m + 1):
            if j == 0:
                A[i][j] = (i - 1) * A[i - 1][j] + 1
            elif j == i:
                A[i][j] = (i - 1) * A[i - 1][j - 1]
            else:
                A[i][j] = (i - j) * A[i - 1][j] + j * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:57:52 - Error: Function is_Diff is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 09:57:53 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: import re.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 09:57:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 09:57:54 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 09:57:57 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 09:57:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 09:57:58 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 09:57:59 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 09:57:59 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 09:57:59 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 09:57:59 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 09:58:03 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 09:58:03 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 09:58:05 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 09:58:06 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 09:58:06 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 09:58:08 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 09:58:17 - Error: .
 Solution: def common_element(list1, list2):
    return any((elem in list1 for elem in list2)).
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-16 09:58:19 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-16 09:58:20 - Error: .
 Solution: def replace_spaces(text):
    return text.replace(' ', '_').replace('_', ' ').
 Test: def check():
    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'
    assert replace_spaces('The_Avengers') == 'The Avengers'
    assert replace_spaces('Fast and Furious') == 'Fast_and_Furious'

2025-10-16 09:58:20 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    return tuple((a * b for (a, b) in zip(test_tup1, test_tup2))).
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-16 09:58:22 - Error: Input must be a list of lists..
 Solution: def extract_singly(test_list):
    if not isinstance(test_list, list) or not all((isinstance(sublist, list) for sublist in test_list)):
        raise ValueError('Input must be a list of lists.')
    return set((num for sublist in test_list for num in sublist if isinstance(num, (int, float)))).
 Test: def check():
    assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])
    assert set(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) == set([1, 2, 3, 4, 7, 8])
    assert set(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) == set([7, 8, 9, 10, 11, 12])

2025-10-16 09:58:22 - Error: .
 Solution: def trim_tuple(test_list, K):
    return [t[K:] if len(t) > K else () for t in test_list].
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-16 09:58:23 - Error: invalid literal for int() with base 10: '['.
 Solution: def sum_of_digits(nums):

    def digit_sum(n):
        return sum((int(digit) for digit in str(n)))
    return sum((digit_sum(num) for num in nums)).
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-16 09:58:23 - Error: .
 Solution: import re
def remove_lowercase(str1):
    return re.sub('\\b[a-z]+\\b', '', str1).replace('  ', ' ').strip().
 Test: def check():
    assert remove_lowercase("PYTHon")==('PYTH')
    assert remove_lowercase("FInD")==('FID')
    assert remove_lowercase("STRinG")==('STRG')

2025-10-16 09:58:24 - Error: .
 Solution: def area_tetrahedron(side):
    return side ** 2 * math.sqrt(2) / 4.
 Test: def check():
    assert area_tetrahedron(3)==15.588457268119894
    assert area_tetrahedron(20)==692.8203230275509
    assert area_tetrahedron(10)==173.20508075688772

2025-10-16 09:58:24 - Error: .
 Solution: def get_Char(strr):
    total_ascii = sum((ord(char) for char in strr))
    index = total_ascii % 26
    return chr(index + ord('a')) if index != 0 else 'z'.
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-16 09:58:25 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    return re.sub('\\(.*?\\)', '', items).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-16 09:58:25 - Error: .
 Solution: import math
def polar_rect(r, theta):
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return (x, y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-16 09:58:25 - Error: .
 Solution: import re
def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-16 09:58:25 - Error: .
 Solution: from itertools import chain, combinations
def combinations_list(list1):
    return [list(combo) for r in range(len(list1) + 1) for combo in combinations(list1, r)].
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-16 09:58:26 - Error: .
 Solution: import math
def wind_chill(v, t):
    if v < 0 or t < -50 or t > 10:
        return 'Invalid input'
    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wci).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-16 09:58:26 - Error: .
 Solution: def max_product(arr):
    n = len(arr)
    if n == 0:
        return 0
    max_prod = [0] * n
    for i in range(n):
        max_prod[i] = arr[i]
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])
    return max(max_prod) if max_prod else 0.
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-16 09:58:27 - Error: Function is_octagonal is not defined in the solution..
 Solution: .
 Test: def check():
    assert is_octagonal(5) == 65
    assert is_octagonal(10) == 280
    assert is_octagonal(15) == 645

2025-10-16 09:58:27 - Error: .
 Solution: def find_Max_Num(arr):
    arr = list(map(str, arr))
    arr.sort(key=lambda x: x * 10, reverse=True)
    return ''.join(arr).
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-16 09:58:28 - Error: .
 Solution: def merge(lst):
    first_elements = [sublist[0] for sublist in lst]
    second_elements = [sublist[1] for sublist in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-16 09:58:28 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    mask = (1 << r - l + 1) - 1 << l
    return n & mask == 0.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-16 09:58:28 - Error: Function sequence is not defined in the solution..
 Solution: .
 Test: def check():
    assert sequence(10) == 6
    assert sequence(2) == 1
    assert sequence(3) == 2

2025-10-16 09:58:29 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n <= 0:
        return False
    return n & n - 1 == 0 or (n > 3 and n - 3 & n - 4) == 0.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-16 09:58:30 - Error: .
 Solution: def count_vowels(test_str):
    vowels = set('aeiouAEIOU')
    count = 0
    for i in range(len(test_str)):
        if i > 0 and test_str[i - 1] in vowels or (i < len(test_str) - 1 and test_str[i + 1] in vowels):
            count += 1
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-16 09:58:30 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    return n | mask.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-16 09:58:30 - Error: .
 Solution: from itertools import combinations
def find_combinations(test_list):
    result = set()
    for r in range(1, len(test_list) + 1):
        for combo in combinations(test_list, r):
            sum_tuple = tuple((sum(x) for x in zip(*combo)))
            result.add(sum_tuple)
    return sorted(result).
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-16 09:58:30 - Error: .
 Solution: def and_tuples(test_tup1, test_tup2):
    elementwise_and = tuple((a & b for (a, b) in zip(test_tup1, test_tup2)))
    tuple_and = tuple((a & b for (a, b) in zip(test_tup1, test_tup2)))
    return (elementwise_and, tuple_and).
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-16 09:58:31 - Error: .
 Solution: def dog_age(h_age):
    if h_age < 0:
        return 'Age cannot be negative'
    elif h_age == 1:
        return 15
    elif h_age == 2:
        return 24
    else:
        return 24 + (h_age - 2) * 5.
 Test: def check():
    assert dog_age(12)==61
    assert dog_age(15)==73
    assert dog_age(24)==109

2025-10-16 09:58:31 - Error: .
 Solution: import math
def triangle_area(r):
    if r <= 0:
        return None
    return r * r * math.sqrt(3) / 4.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-16 09:58:33 - Error: '<=' not supported between instances of 'tuple' and 'int'.
 Solution: def min_Jumps(steps, d):
    if d == 0:
        return 0
    if steps <= 0:
        return float('inf') if d != 0 else 0
    jumps = 0
    position = 0
    while abs(position) < abs(d):
        position += steps
        jumps += 1
    if position > d:
        return jumps + 1
    return jumps.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-16 09:58:33 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        return None
    max1 = max(arr[0], arr[1])
    max2 = min(arr[0], arr[1])
    for i in range(2, len(arr)):
        if arr[i] > max1:
            max2 = max1
            max1 = arr[i]
        elif arr[i] > max2:
            max2 = arr[i]
    return (max2, max1).
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-16 09:58:33 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' cannot be zero for a parabola.")
    vertex_x = -b / (2 * a)
    vertex_y = (4 * a * c - b ** 2) / (4 * a)
    directrix = vertex_y - 1 / (4 * a)
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-16 09:58:34 - Error: .
 Solution: def get_total_number_of_sequences(m, n):
    if n == 0:
        return 1
    if m < 1:
        return 0
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, m + 1):
        dp[1][i] = 1
    for length in range(2, n + 1):
        for last in range(1, m + 1):
            start = max(1, (last + 1) // 2)
            end = last
            if start <= end:
                dp[length][last] = sum((dp[length - 1][i] for i in range(start, end + 1)))
    return sum((dp[n][i] for i in range(1, m + 1))).
 Test: def check():
    assert get_total_number_of_sequences(10, 4) == 4
    assert get_total_number_of_sequences(5, 2) == 6
    assert get_total_number_of_sequences(16, 3) == 84

2025-10-16 09:58:34 - Error: .
 Solution: def tuple_intersection(test_list1, test_list2):
    set1 = set(test_list1)
    set2 = set(test_list2)
    intersection = set1.intersection(set2)
    return tuple(sorted(intersection)).
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-16 09:58:35 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    if sale_amount < actual_cost:
        return actual_cost - sale_amount
    return 0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-16 09:58:35 - Error: .
 Solution: def decagonal_number(n):
    return n * (4 * n - 3)
def is_num_decagonal(n):
    if n < 1:
        return False
    k = 1
    while True:
        decagonal = decagonal_number(k)
        if decagonal == n:
            return True
        elif decagonal > n:
            return False
        k += 1.
 Test: def check():
    assert is_num_decagonal(3) == 27
    assert is_num_decagonal(7) == 175
    assert is_num_decagonal(10) == 370

2025-10-16 09:58:35 - Error: check_value() takes 1 positional argument but 2 were given.
 Solution: def check_value(d):
    if not d:
        return True
    first_value = next(iter(d.values()))
    return all((value == first_value for value in d.values())).
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-16 09:58:37 - Error: .
 Solution: def get_ludic(n):
    if n < 1:
        return []
    ludic_numbers = []
    candidates = list(range(1, n + 1))
    while candidates:
        ludic_number = candidates[0]
        ludic_numbers.append(ludic_number)
        candidates = candidates[1:]
        candidates = [x for x in candidates if (x - ludic_number) % ludic_number != 0]
    return ludic_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-16 09:58:38 - Error: .
 Solution: def re_arrange_array(arr, n):
    if n <= 0 or n > len(arr):
        return arr
    negative = []
    positive = []
    for x in arr[:n]:
        if x < 0:
            negative.append(x)
        else:
            positive.append(x)
    return negative + positive + arr[n:].
 Test: def check():
    assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]
    assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]
    assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]

2025-10-16 09:58:38 - Error: .
 Solution: def find_lists(Input):
    count = 0
    for item in Input:
        if isinstance(item, list):
            count += 1
    return count.
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-16 09:58:38 - Error: .
 Solution: def count_bidirectional(test_list):
    count = 0
    seen = set()
    for (a, b) in test_list:
        if (b, a) in seen:
            count += 1
        seen.add((a, b))
    return count.
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-16 09:58:39 - Error: .
 Solution: def check_Consecutive(l):
    if not l:
        return False
    l = sorted(set(l))
    return all((l[i] + 1 == l[i + 1] for i in range(len(l) - 1))).
 Test: def check():
    assert check_Consecutive([1,2,3,4,5]) == True
    assert check_Consecutive([1,2,3,5,6]) == False
    assert check_Consecutive([1,2,1]) == False

2025-10-16 09:58:40 - Error: .
 Solution: def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    (g, x1, y1) = extended_gcd(b, a % b)
    x = y1
    y = x1 - a // b * y1
    return (g, x, y)
def find_solution(a, b, n):
    (g, x0, y0) = extended_gcd(a, b)
    if n % g != 0:
        return None
    x0 *= n // g
    y0 *= n // g
    return (x0, y0).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-16 09:58:42 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if m < 0 or m >= len(tuplex):
        return None
    if n < 0 or n >= len(tuplex[m]):
        return None
    result = list(tuplex[m])
    result[n] = 50
    return tuple(result).
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-16 09:58:42 - Error: .
 Solution: def remove_kth_element(list1, k):
    if k < 0 or k >= len(list1):
        return list1
    return list1[:k] + list1[k + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-16 09:58:42 - Error: concatenate_tuple() missing 1 required positional argument: 'delimiter'.
 Solution: def concatenate_tuple(test_tup, delimiter):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple')
    return delimiter.join(map(str, test_tup)).
 Test: def check():
    assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
    assert concatenate_tuple(("QWE", "is", 4, "RTY") ) == 'QWE-is-4-RTY'
    assert concatenate_tuple(("ZEN", "is", 4, "OP") ) == 'ZEN-is-4-OP'

2025-10-16 09:58:43 - Error: .
 Solution: def comb_sort(nums):
    gap = len(nums)
    shrink = 1.3
    sorted = False
    while not sorted:
        gap = int(gap / shrink)
        if gap < 1:
            gap = 1
        sorted = True
        for i in range(len(nums) - gap):
            if nums[i] > nums[i + gap]:
                (nums[i], nums[i + gap]) = (nums[i + gap], nums[i])
                sorted = False
    return nums.
 Test: def check():
    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
    assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]
    assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]

2025-10-16 09:58:44 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count_0_str1 = str1.count('0')
    count_0_str2 = str2.count('0')
    if count_0_str1 != count_0_str2:
        return -1
    count_swaps = 0
    mismatch_0_to_1 = 0
    mismatch_1_to_0 = 0
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            if str1[i] == '0':
                mismatch_0_to_1 += 1
            else:
                mismatch_1_to_0 += 1
    count_swaps = max(mismatch_0_to_1, mismatch_1_to_0)
    return count_swaps.
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-16 09:58:45 - Error: .
 Solution: def max_difference(test_list):
    if not test_list or len(test_list) < 2:
        return 0
    max_x = max(test_list, key=lambda x: x[0])[0]
    min_x = min(test_list, key=lambda x: x[0])[0]
    max_y = max(test_list, key=lambda x: x[1])[1]
    min_y = min(test_list, key=lambda x: x[1])[1]
    return max(max_x - min_x, max_y - min_y).
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-16 09:58:46 - Error: .
 Solution: def count_Pairs(arr, n):
    unique_elements = set(arr)
    count = 0
    unique_count = len(unique_elements)
    if unique_count < 2:
        return 0
    count = unique_count * (unique_count - 1) // 2
    return count
def count_Pairs(arr, n):
    unique_elements = set(arr)
    return len(unique_elements) * (len(unique_elements) - 1) // 2 if len(unique_elements) > 1 else 0.
 Test: def check():
    assert count_Pairs([1,2,1],3) == 2
    assert count_Pairs([1,1,1,1],4) == 0
    assert count_Pairs([1,2,3,4,5],5) == 10

2025-10-16 09:58:47 - Error: .
 Solution: def perrin(n):
    if n == 0:
        return 3
    elif n == 1:
        return 0
    elif n == 2:
        return 2
    else:
        p = [3, 0, 2]
        for i in range(3, n + 1):
            p.append(p[i - 2] + p[i - 1])
        return p[n]
def cal_sum(n):
    total = 0
    for i in range(n + 1):
        total += perrin(i)
    return total.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-16 09:58:48 - Error: .
 Solution: import math
def sum_of_divisors(n):
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-16 09:58:48 - Error: Function sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert sum(10,15) == 6
    assert sum(100,150) == 93
    assert sum(4,6) == 3

2025-10-16 09:58:48 - Error: .
 Solution: import math
def next_Perfect_Square(N):
    root = math.ceil(math.sqrt(N))
    return root * root.
 Test: def check():
    assert next_Perfect_Square(35) == 36
    assert next_Perfect_Square(6) == 9
    assert next_Perfect_Square(9) == 16

2025-10-16 09:58:49 - Error: .
 Solution: def positive_count(nums):
    if not nums:
        return 0.0
    positive_numbers = sum((1 for num in nums if num > 0))
    return positive_numbers / len(nums).
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-16 09:58:49 - Error: '<=' not supported between instances of 'list' and 'int'.
 Solution: def find_Element(arr, ranges, rotations, index):
    n = len(arr)
    if n == 0:
        return None
    rotations = rotations % n
    new_index = (index - rotations + n) % n
    if len(ranges) == 2 and ranges[0] <= new_index <= ranges[1]:
        return arr[new_index]
    else:
        return None.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-16 09:58:50 - Error: Input must be a list or tuple of complex numbers..
 Solution: import cmath
def convert(numbers):
    if not isinstance(numbers, (list, tuple)):
        raise ValueError('Input must be a list or tuple of complex numbers.')
    polar_coordinates = []
    for number in numbers:
        if not isinstance(number, complex):
            raise ValueError('All elements in the input must be complex numbers.')
        polar_coordinates.append(cmath.polar(number))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-16 09:58:50 - Error: .
 Solution: def set_left_most_unset_bit(n):
    position = 0
    while 1 << position <= n:
        position += 1
    return n | 1 << position - 1.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-16 09:58:51 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    matches = [(m.group(), m.start()) for m in re.finditer(pattern, text)]
    return matches if matches else None.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-16 09:58:53 - Error: .
 Solution: def group_tuples(input_list):
    if not input_list:
        return None
    first_elements = [t[0] for t in input_list]
    common_first_element = set(first_elements)
    if len(common_first_element) == 1:
        common_element = next(iter(common_first_element))
        return [(common_element,) + t[1:] for t in input_list]
    return input_list.
 Test: def check():
    assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]
    assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]
    assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]

2025-10-16 09:58:53 - Error: .
 Solution: from collections import Counter
def check_occurences(test_list):
    counts = Counter(test_list)
    result = {key: value for (key, value) in counts.items()}
    return result.
 Test: def check():
    assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}
    assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}
    assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}

2025-10-16 09:58:53 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    return sorted(nums_str, key=lambda x: int(x)).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-16 09:58:54 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    count = sum((1 for (a, b) in zip(nums1, nums2) if a == b))
    return count.
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-16 09:58:56 - Error: .
 Solution: def min_product_tuple(list1):
    if len(list1) < 2:
        return None
    min_product = float('inf')
    min_pair = None
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = list1[i][0] * list1[i][1] + list1[j][0] * list1[j][1]
            if product < min_product:
                min_product = product
                min_pair = (list1[i], list1[j])
    return (min_pair, min_product).
 Test: def check():
    assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8
    assert min_product_tuple([(10,20), (15,2), (5,10)] )==30
    assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100

2025-10-16 09:58:58 - Error: .
 Solution: def min_k(test_list, K):
    return sorted(test_list)[:K].
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-16 09:59:01 - Error: .
 Solution: import math
def surface_Area(b, h):
    base_area = b * b
    slant_height = math.sqrt((b / 2) ** 2 + h ** 2)
    lateral_area = 2 * b * slant_height
    total_surface_area = base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-16 09:59:02 - Error: .
 Solution: def upper_ctr(s):
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-16 09:59:12 - Error: .
 Solution: def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
def newman_shanks_williams_primes(limit):
    primes = []
    n = 2
    while len(primes) < limit:
        if is_prime(n):
            if n == 2 or n == 3 or n == 5 or (n % 6 == 1) or (n % 6 == 5):
                primes.append(n)
        n += 1
    return primes
def newman_prime(n):
    if n < 1:
        return None
    primes = newman_shanks_williams_primes(n)
    return primes[n - 1].
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-16 09:59:22 - Error: .
 Solution: def count_first_elements(test_tup):
    result = {}
    for (index, value) in enumerate(test_tup):
        if isinstance(value, tuple):
            result[value] = index
    return result.get((4, 6), 0).
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-16 10:12:15 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:12:15 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 10:12:15 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 10:12:15 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:12:15 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:12:16 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:12:16 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 10:12:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:12:16 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:12:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:12:16 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:12:16 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:12:17 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:12:17 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:12:17 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:12:17 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:12:17 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:12:18 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 10:12:18 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
        if i > 1 and s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-16 10:12:18 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:12:18 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:12:18 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:12:19 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 10:12:20 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:12:36 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:12:36 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:12:36 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:12:36 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:12:37 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:12:37 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:12:40 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:12:41 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:12:43 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:12:45 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) * (n + 1) // 6.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:12:46 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:12:47 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:12:47 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:12:48 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:12:50 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:18:01 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:18:03 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 10:18:03 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 10:18:03 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:18:04 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:18:04 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:18:04 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:18:04 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:18:04 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:18:05 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:18:05 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:18:05 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:18:05 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 10:18:05 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:18:06 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:18:06 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 10:18:06 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:18:06 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 10:18:06 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:18:07 - Error: .
 Solution: def find_sum(arr):
    element_count = {}
    for num in arr:
        if num in element_count:
            element_count[num] += 1
        else:
            element_count[num] = 1
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:18:07 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:18:08 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:18:08 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:18:24 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:18:26 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:18:26 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:18:27 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:18:28 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:18:29 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    if re.match(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:18:29 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:18:31 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return min(max_items).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-16 10:18:36 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:18:36 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:18:36 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:18:37 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    n = len(list1)
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:18:38 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_area = lateral_area + 2 * base_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:18:43 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:18:43 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:18:45 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:18:46 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:27:44 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 10:27:44 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:27:44 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:27:44 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:27:44 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:27:45 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 10:27:45 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:27:45 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:27:45 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 10:27:45 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:27:45 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:27:46 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:27:46 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:27:46 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:27:46 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:27:46 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:27:46 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:27:46 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:27:47 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 10:27:47 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 10:27:48 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:27:48 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 10:27:49 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:28:09 - Error: .
 Solution: def snake_to_camel(word):
    if not isinstance(word, str):
        raise ValueError('Input must be a string')
    components = word.split('_')
    if not components:
        return ''
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:28:09 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:28:10 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:28:11 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:28:14 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:28:15 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:28:15 - Error: Function test_three_equal is not defined in the solution..
 Solution: .
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:28:17 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:28:17 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:28:18 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:28:18 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 0
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:28:20 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:28:20 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:28:21 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:28:29 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:35:16 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 10:35:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:35:17 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 10:35:17 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:35:17 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:35:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:35:18 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:35:18 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:35:18 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:35:18 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 10:35:18 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 10:35:19 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:35:19 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:35:19 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:35:19 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:35:19 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:35:19 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:35:20 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:35:20 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 10:35:20 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:35:20 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:35:20 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:35:23 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 10:35:42 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 10:35:43 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 10:35:43 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 10:35:43 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 10:35:45 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:35:47 - Error: .
 Solution: def dif_Square(n):
    return n >= 0 and (n % 4 == 0 or n % 4 == 1).
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:35:48 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:35:48 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:35:48 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 10:35:50 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:35:50 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:35:50 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 10:35:51 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 10:35:54 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 10:35:55 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 10:35:58 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 10:36:00 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 10:36:01 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 10:36:33 - Error: name 'collections' is not defined.
 Solution: def freq_count(list1):
    return dict(collections.Counter(list1)).
 Test: def check():
    assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})
    assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})
    assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})

2025-10-16 10:36:33 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 10:36:33 - Error: Function _sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert _sum([1, 2, 3]) == 6
    assert _sum([15, 12, 13, 10]) == 50
    assert _sum([0, 1, 2]) == 3

2025-10-16 10:36:34 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 10:36:36 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 10:36:37 - Error: .
 Solution: import re
def text_match_zero_one(text):
    return re.fullmatch('a+b+', text) is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 10:36:38 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    return sum((key for (key, count) in Counter(arr).items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 10:36:38 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 10:36:38 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:06:06 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 11:06:06 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 11:06:07 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 11:06:07 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 11:06:07 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 11:06:07 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 11:06:07 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 11:06:07 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 11:06:08 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 11:06:08 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:06:08 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 11:06:08 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 11:06:08 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 11:06:09 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_val, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 11:06:09 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 11:06:09 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 11:06:09 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 11:06:09 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 11:06:09 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 11:06:09 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 11:06:10 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 11:06:10 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 11:06:11 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 11:06:25 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 11:06:25 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 11:06:27 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 11:06:28 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 11:06:28 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:06:28 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 11:06:30 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 11:06:30 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 11:06:31 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 11:06:31 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 11:06:32 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n > 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 11:06:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 11:06:34 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 11:06:35 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 11:06:38 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 11:06:40 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 11:08:01 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (h + r)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 11:08:05 - Error: .
 Solution: def extract_freq(test_list):
    """
    Extracts the number of unique tuples from the given list.

    Parameters:
    test_list (list of tuples): The input list containing tuples.

    Returns:
    int: The number of unique tuples in the list.
    """
    if not isinstance(test_list, list):
        raise ValueError('Input must be a list.')
    if not all((isinstance(i, tuple) for i in test_list)):
        raise ValueError('All elements in the list must be tuples.')
    if not test_list:
        return 0
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 11:08:06 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 11:08:08 - Error: .
 Solution: def is_polite(n):
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 11:08:13 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 11:08:14 - Error: .
 Solution: def Diff(li1, li2):
    """
    Returns the elements that are in li1 but not in li2.
    
    Parameters:
    li1 (list): The first list.
    li2 (list): The second list.
    
    Returns:
    list: A list containing elements in li1 that are not in li2.
    """
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 11:08:16 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) if len(tup) > 0 else 0 for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 11:08:18 - Error: words must be a list of strings..
 Solution: def long_words(n, words):
    """
    Find words that are longer than n characters from a given list of words.

    Parameters:
    n (int): The minimum length of words to be included in the result.
    words (list of str): The list of words to filter.

    Returns:
    list of str: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer.')
    if not isinstance(words, list):
        raise ValueError('words must be a list of strings.')
    if not all((isinstance(word, str) for word in words)):
        raise ValueError('All elements in words must be strings.')
    result = [word for word in words if len(word) > n]
    return result.
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 11:08:19 - Error: Function count_rotation is not defined in the solution..
 Solution: .
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 11:08:19 - Error: Input tuple must contain at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must contain at least two elements.')
    result = []
    for i in range(len(test_tup) - 1):
        product = test_tup[i] * test_tup[i + 1]
        result.append(product)
    return tuple(result).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-16 11:08:22 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:08:39 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 11:08:45 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    E = [[0] * (m + 1) for _ in range(n + 1)]
    E[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, m + 1):
            if j == 0:
                E[i][j] = (i - 1) * E[i - 1][j] // i
            else:
                E[i][j] = (j * E[i][j - 1] + (i - 1) * E[i - 1][j]) // i
    return E[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 11:08:51 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Calculate the angle (argument) of a complex number.

    Parameters:
    z (complex): A complex number.

    Returns:
    float: The angle in radians, or None if the input is zero.
    """
    if not isinstance(z, complex):
        raise TypeError('Input must be a complex number.')
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 11:08:56 - Error: .
 Solution: import heapq
import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 11:08:58 - Error: .
 Solution: import heapq
def harmonic_sum(n):
    if n < 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 11:10:25 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case_parts = [parts[0]] + [part.capitalize() for part in parts[1:] if part]
    camel_case_string = ''.join(camel_case_parts)
    return camel_case_string.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:10:26 - Error: .
 Solution: def remove_odd(str1):
    if str1 is None:
        raise ValueError('Input string cannot be None')
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 11:10:38 - Error: .
 Solution: def string_to_tuple(str1):
    """
    Convert a given string to a tuple of its characters.

    Parameters:
    str1 (str): The input string to be converted.

    Returns:
    tuple: A tuple containing each character of the input string.
    """
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 11:10:39 - Error: Input must be a tuple with at least two elements..
 Solution: def multiply_elements(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) < 2:
        raise ValueError('Input must be a tuple with at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-16 11:10:41 - Error: .
 Solution: import cmath
def angle_complex(real, imag):
    """
    Calculate the angle (phase) of a complex number given its real and imaginary parts.

    Parameters:
    real (float): The real part of the complex number.
    imag (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    complex_number = complex(real, imag)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 11:10:41 - Error: .
 Solution: def find_sum(arr):
    count_dict = {}
    for num in arr:
        count_dict[num] = count_dict.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in count_dict.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 11:10:46 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified tuples from the given tuple.

    Parameters:
    test_tup (tuple): The original tuple from which to remove elements.
    to_remove (tuple): The tuple of elements to be removed.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    filtered_list = [item for item in test_tup if item not in to_remove]
    return tuple(filtered_list).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 11:10:48 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1.0 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 11:10:49 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer.')
    star_number = n * (3 * n - 2)
    return star_number.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 11:10:50 - Error: words must be a list of strings..
 Solution: def long_words(n, words):
    """
    Find words that are longer than n characters from a given list of words.

    Parameters:
    n (int): The minimum length of words to be included in the result.
    words (list of str): The list of words to be processed.

    Returns:
    list of str: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer.')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 11:10:52 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    jacobsthal = [0] * (n + 1)
    jacobsthal[0] = 0
    jacobsthal[1] = 1
    for i in range(2, n + 1):
        jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
    return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 11:10:52 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    if n == 0 or arr[low] <= arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 11:10:55 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (h + r)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 11:10:56 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = i - 1
        for j in range(1, i + 1):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - 1 - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 11:11:14 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 11:11:22 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    set_li2 = set(li2)
    difference = [item for item in li1 if item not in set_li2]
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 11:11:26 - Error: .
 Solution: def extract_freq(test_list):
    if not isinstance(test_list, list):
        raise ValueError('Input must be a list.')
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 11:11:27 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for num_tuple in nums:
        if len(num_tuple) > 0:
            average = sum(num_tuple) / len(num_tuple)
        else:
            average = 0
        averages.append(average)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 11:11:36 - Error: .
 Solution: def is_polite(n):
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 11:12:58 - Error: .
 Solution: def square_Sum(n):
    if n <= 0:
        return 0
    return n * n * (2 * n * n - 1) // 3.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-16 11:12:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 11:13:05 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = [sum(tup) / len(tup) for tup in nums]
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 11:13:18 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum if total_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 11:13:33 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 11:13:35 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 11:13:41 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    return n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 11:13:45 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 11:13:49 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 11:13:56 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer.')
    return n * (6 * n - 6) // 2 + 1 if n > 0 else 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 11:13:57 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 11:13:58 - Error: .
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        return 'List must contain at least two distinct elements.'
    first = float('inf')
    second = float('inf')
    for number in numbers:
        if number < first:
            second = first
            first = number
        elif first < number < second:
            second = number
    if second == float('inf'):
        return 'No second smallest number (all elements may be the same).'
    return second.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-16 11:14:07 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove all occurrences of specified elements from a tuple.

    Parameters:
    test_tup (tuple): The input tuple from which elements will be removed.
    to_remove (tuple): A tuple of elements to be removed from the input tuple.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    if not test_tup:
        return ()
    remove_set = set(to_remove)
    filtered_list = [item for item in test_tup if item not in remove_set]
    return tuple(filtered_list).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 11:14:08 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1:
        return None
    max_product = float('-inf')
    for tup in list1:
        if len(tup) == 2:
            product = tup[0] * tup[1]
            max_product = max(max_product, product, key=abs)
    return max_product if max_product != float('-inf') else None.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 11:14:21 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 11:15:15 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    """
    Calculate the loss amount on a sale.
    
    Parameters:
    actual_cost (float): The actual cost of the item.
    sale_amount (float): The amount at which the item was sold.
    
    Returns:
    float: The loss amount if there is a loss, otherwise returns 0.
    """
    if sale_amount < actual_cost:
        return actual_cost - sale_amount
    return 0.0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-16 11:15:19 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        return None
    max1 = max2 = float('-inf')
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2 and num != max1:
            max2 = num
    return (max2, max1) if max2 != float('-inf') else None
arr = [1, 2, 3, 4, 7, 0, 8, 4].
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-16 11:15:21 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    if not nums_str:
        return []
    return sorted(nums_str, key=lambda x: (int(x), x)).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-16 11:15:22 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    next_bigger_number = int(''.join(digits))
    return next_bigger_number.
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-16 11:15:31 - Error: .
 Solution: def trim_tuple(test_list, K):
    trimmed_list = []
    for tup in test_list:
        trimmed_tup = tuple((x for x in tup if x > K))
        trimmed_list.append(trimmed_tup if trimmed_tup else (K,))
    return trimmed_list
test_list = [(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)]
K = 2.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-16 11:15:33 - Error: .
 Solution: def remove_kth_element(list1, k):
    if not list1:
        return []
    if k < 0 or k >= len(list1):
        raise IndexError('k is out of bounds')
    return list1[:k] + list1[k + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-16 11:15:39 - Error: .
 Solution: import re
def text_starta_endb(text):
    pattern = 'a.*b'
    match = re.search(pattern, text)
    return match is not None.
 Test: def check():
    assert text_starta_endb("aabbbb")
    assert not text_starta_endb("aabAbbbc")
    assert not text_starta_endb("accddbbjjj")

2025-10-16 11:15:40 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    if not text or not pattern:
        return None
    matches = [(m.start(), m.group()) for m in re.finditer(re.escape(pattern), text)]
    if not matches:
        return None
    return [(match, start, start + len(match)) for (start, match) in matches]
text = 'python programming, python language'
pattern = 'python'.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-16 11:15:56 - Error: .
 Solution: def check_value(d, n):
    if not d:
        return True
    return len(set(d.values())) == 1 and len(d) == n.
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-16 11:15:59 - Error: .
 Solution: def find_lists(input_tuple):
    list_count = 0
    for element in input_tuple:
        if isinstance(element, list):
            list_count += 1
    return list_count.
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-16 11:16:01 - Error: closest_num() missing 1 required positional argument: 'N'.
 Solution: def closest_num(arr, N):
    if not arr:
        return None
    closest = None
    for num in arr:
        if num < N:
            if closest is None or num > closest:
                closest = num
    return closest
arr = [5, 3, 8, 1, 4]
N = 6.
 Test: def check():
    assert closest_num(11) == 10
    assert closest_num(7) == 6
    assert closest_num(12) == 11

2025-10-16 11:16:02 - Error: .
 Solution: def upper_ctr(s: str) -> int:
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-16 11:16:02 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-16 11:16:06 - Error: .
 Solution: def count_first_elements(test_tup):
    result = []
    for (index, element) in enumerate(test_tup):
        count = 0
        for e in test_tup[:index]:
            if e == element:
                count += 1
        result.append(count)
    return result
def count_first_elements(test_tup):
    result = []

    def flatten(tup):
        for item in tup:
            if isinstance(item, tuple):
                yield from flatten(item)
            else:
                yield item
    flat_tup = list(flatten(test_tup))
    for (index, element) in enumerate(flat_tup):
        count = 0
        for e in flat_tup[:index]:
            if e == element:
                count += 1
        result.append(count)
    return result.
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-16 11:16:07 - Error: .
 Solution: def common_element(list1, list2):
    if not list1 or not list2:
        return False
    elements_set = set(list1)
    for element in list2:
        if element in elements_set:
            return True
    return False.
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-16 11:16:09 - Error: .
 Solution: def and_tuples(test_tup1, test_tup2):
    if not test_tup1 or not test_tup2:
        return ((), ())
    elementwise = tuple((max(0, a - b) for (a, b) in zip(test_tup1, test_tup2)))
    tuplewise = tuple((a - b for a in test_tup1 for b in test_tup2))
    return (elementwise, tuplewise).
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-16 11:16:10 - Error: bad operand type for abs(): 'list'.
 Solution: def sum_of_digits(nums):
    result = []
    for num in nums:
        digit_sum = sum((int(digit) for digit in str(abs(num))))
        result.append(digit_sum)
    return sum(result).
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-16 11:16:14 - Error: .
 Solution: import math
def surface_Area(b, s):
    if b <= 0 or s <= 0:
        raise ValueError('Base edge and height must be positive numbers.')
    base_area = b * b
    l = math.sqrt((b / 2) ** 2 + s ** 2)
    triangular_area = b * l / 2
    total_triangular_area = 4 * triangular_area
    total_surface_area = base_area + total_triangular_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-16 11:16:19 - Error: .
 Solution: def cal_sum(n):
    if n == 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 6
    (p0, p1) = (3, 0)
    total_sum = p0 + p1
    for i in range(2, n):
        p_next = p0 + p1
        total_sum += p_next
        (p0, p1) = (p1, p_next)
    return total_sum.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-16 11:16:32 - Error: .
 Solution: def geometric_sum(n):
    if n <= 0:
        return 0
    return 1 / 2 ** n + geometric_sum(n - 1).
 Test: def check():
    assert geometric_sum(7) == 1.9921875
    assert geometric_sum(4) == 1.9375
    assert geometric_sum(8) == 1.99609375

2025-10-16 11:16:32 - Error: .
 Solution: def get_Char(strr):
    if not strr:
        return 'A'
    ascii_sum = sum((ord(char) for char in strr))
    result_index = ascii_sum % 26
    result_char = chr(result_index + ord('A'))
    return result_char.
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-16 11:16:41 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(s):
    if not isinstance(s, str):
        raise ValueError('Input must be a string')
    return re.sub('\\([^()]*\\)', '', s).
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-16 11:16:47 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] * arr[i])
        if dp[i] == 1:
            dp[i] = arr[i]
    return max(dp).
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-16 11:16:57 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n <= 0:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    sum1 = sum_of_divisors(num1)
    sum2 = sum_of_divisors(num2)
    return sum1 == sum2.
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-16 11:16:58 - Error: .
 Solution: def merge_dictionaries_three(dict1, dict2, dict3):
    merged_dict = {**dict1, **dict2, **dict3}
    return merged_dict
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
dict3 = {'d': 5}.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-16 11:17:01 - Error: .
 Solution: import sys
def tuple_size(tuple_list):
    if not isinstance(tuple_list, tuple):
        raise ValueError('Input must be a tuple.')
    total_size = sys.getsizeof(tuple_list)
    for item in tuple_list:
        total_size += sys.getsizeof(item)
        if isinstance(item, tuple):
            total_size += tuple_size(item)
    return total_size.
 Test: def check():
    assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
    assert tuple_size((1, "Raju", 2, "Nikhil", 3, "Deepanshu") ) == sys.getsizeof((1, "Raju", 2, "Nikhil", 3, "Deepanshu"))
    assert tuple_size(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf"))  ) == sys.getsizeof(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf")))

2025-10-16 11:17:02 - Error: .
 Solution: def get_coordinates(test_tup):
    (x, y) = test_tup
    adjacent_offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    adjacent_coordinates = [[x + dx, y + dy] for (dx, dy) in adjacent_offsets]
    return adjacent_coordinates + [[x, y]].
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-16 11:17:24 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Tuples must be of the same length')
    result = tuple((a * b for (a, b) in zip(test_tup1, test_tup2)))
    return result.
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-16 11:17:28 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    if not arr:
        return None
    n = len(arr)
    rotations = rotations % n
    effective_index = (index - rotations + n) % n
    for r in ranges:
        if r[0] <= effective_index <= r[1]:
            return arr[effective_index]
    return None
arr = [1, 2, 3, 4, 5]
ranges = [[0, 2], [0, 3]]
rotations = 2
index = 1.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-16 11:17:28 - Error: Input must be a complex number or a list of complex numbers..
 Solution: import cmath
def convert(numbers):
    if isinstance(numbers, complex):
        numbers = [numbers]
    elif not isinstance(numbers, list):
        raise ValueError('Input must be a complex number or a list of complex numbers.')
    polar_coordinates = []
    for number in numbers:
        if isinstance(number, complex):
            magnitude = abs(number)
            angle = cmath.phase(number)
            polar_coordinates.append((magnitude, angle))
        else:
            raise ValueError('All elements in the list must be complex numbers.')
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-16 11:17:33 - Error: .
 Solution: import math
def polar_rect(r, theta):
    """
    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).
    
    Parameters:
    r (float): The radius (distance from origin).
    theta (float): The angle in radians.
    
    Returns:
    tuple: A tuple (x, y) representing the rectangular coordinates.
    """
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return (x, y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-16 11:17:36 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    count = 0
    for i in range(len(nums1)):
        if nums1[i] == nums2[i]:
            count += 1
    return count.
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-16 11:17:44 - Error: .
 Solution: import math
def wind_chill(v, t):
    if v < 0 or t < -100 or t > 100:
        raise ValueError('Wind velocity must be non-negative and temperature must be within realistic limits.')
    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wci).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-16 11:17:49 - Error: .
 Solution: def set_left_most_unset_bit(n):
    bit_length = n.bit_length()
    mask = 1 << bit_length
    if n == (1 << bit_length) - 1:
        return n + mask
    for i in range(bit_length - 1, -1, -1):
        if n & 1 << i == 0:
            return n | 1 << i
    return n.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-16 11:17:56 - Error: .
 Solution: def merge_sorted_list(num1, num2, num3):
    merged_list = []
    (i, j, k) = (0, 0, 0)
    while i < len(num1) or j < len(num2) or k < len(num3):
        val1 = num1[i] if i < len(num1) else float('inf')
        val2 = num2[j] if j < len(num2) else float('inf')
        val3 = num3[k] if k < len(num3) else float('inf')
        if val1 <= val2 and val1 <= val3:
            merged_list.append(val1)
            i += 1
        elif val2 <= val1 and val2 <= val3:
            merged_list.append(val2)
            j += 1
        else:
            merged_list.append(val3)
            k += 1
    return merged_list
num1 = [25, 24, 15, 4, 5, 29, 110]
num2 = [19, 20, 11, 56, 25, 233, 154]
num3 = [24, 26, 54, 48].
 Test: def check():
    assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]
    assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]
    assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]

2025-10-16 11:18:02 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n <= 0:
        return False
    return True.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-16 11:18:02 - Error: .
 Solution: import math
def area_tetrahedron(side):
    if side <= 0:
        return 0
    area = math.sqrt(2) * side ** 2
    return area / 2.
 Test: def check():
    assert area_tetrahedron(3)==15.588457268119894
    assert area_tetrahedron(20)==692.8203230275509
    assert area_tetrahedron(10)==173.20508075688772

2025-10-16 11:18:21 - Error: .
 Solution: def min_k(test_list, K):
    if not test_list or K <= 0:
        return []
    sorted_list = sorted(test_list, key=lambda x: x[0])
    return sorted_list[:K]
test_list = [(5, 'A'), (1, 'B'), (3, 'C'), (2, 'D'), (4, 'E')]
K = 3
test_list = [(10, 'A'), (20, 'B'), (30, 'C')]
K = 2
test_list = [(1, 'A'), (1, 'B'), (1, 'C')]
K = 2
test_list = []
K = 1
test_list = [(5, 'A')]
K = 1.
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-16 11:18:21 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    result = n | mask
    return result.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-16 11:18:22 - Error: .
 Solution: def combinations_list(list1):

    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(list1)):
            backtrack(i + 1, path + [list1[i]])
    result = []
    backtrack(0, [])
    return result
def combinations_list(lst):
    result = []

    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(lst)):
            backtrack(i + 1, path + [lst[i]])
    backtrack(0, [])
    return result.
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-16 11:18:28 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    if l < 0 or r < 0 or l > r:
        raise ValueError('Invalid range: l and r must be non-negative and l must be less than or equal to r.')
    mask = (1 << r - l + 1) - 1 << l
    return n & mask == 0
n = 4
l = 1
r = 2.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-16 11:18:29 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero for a parabola.")
    p = 1 / (4 * abs(a))
    directrix = -(1 / (4 * a)) + c
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-16 11:18:32 - Error: .
 Solution: import re
def find_literals(text, pattern):
    regex = re.compile(pattern)
    match = regex.search(text)
    if match:
        start_index = match.start()
        end_index = match.end() - 1
        return (match.group(), start_index, end_index)
    else:
        return (None, None, None).
 Test: def check():
    assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)
    assert find_literals('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)
    assert find_literals('Hardest choices required strongest will', 'will') == ('will', 35, 39)

2025-10-16 11:18:34 - Error: .
 Solution: def count_bidirectional(test_list):
    count_map = {}
    for item in test_list:
        sorted_item = tuple(sorted(item))
        if sorted_item in count_map:
            count_map[sorted_item] += 1
        else:
            count_map[sorted_item] = 1
    bidirectional_count = 0
    for count in count_map.values():
        bidirectional_count += count // 2
    return bidirectional_count
test_list = [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)].
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-16 11:18:34 - Error: .
 Solution: def dog_age(h_age):
    """
    Calculate a dog's age in dog's years based on the human age.
    
    Parameters:
    h_age (int): The age of the dog in human years.
    
    Returns:
    int: The equivalent age in dog's years.
    """
    if h_age < 0:
        raise ValueError('Age cannot be negative.')
    elif h_age == 1:
        return 15
    elif h_age == 2:
        return 24
    else:
        return 24 + (h_age - 2) * 5.
 Test: def check():
    assert dog_age(12)==61
    assert dog_age(15)==73
    assert dog_age(24)==109

2025-10-16 11:18:35 - Error: .
 Solution: from itertools import combinations
def find_combinations(test_list):
    result = set()
    if not test_list:
        return []
    for r in range(1, len(test_list) + 1):
        for combo in combinations(test_list, r):
            combo_sum = tuple((sum(x) for x in zip(*combo)))
            result.add(combo_sum)
    return sorted(result)
test_list = [(2, 4), (6, 7), (5, 1), (6, 10)].
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-16 11:18:38 - Error: .
 Solution: def find_Max_Num(arr):
    if not arr:
        return '0'
    arr_str = list(map(str, arr))
    arr_str.sort(key=lambda x: x * 10, reverse=True)
    largest_num = ''.join(arr_str)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-16 11:18:39 - Error: .
 Solution: def max_sum_increasing_subseq(a, n, index, k):
    if n == 0 or index < 0 or k >= n or (index >= k):
        return 0
    dp = [0] * n
    for i in range(index + 1):
        dp[i] = a[i]
        for j in range(i):
            if a[j] < a[i]:
                dp[i] = max(dp[i], dp[j] + a[i])
    max_sum = dp[index]
    for i in range(index + 1, k + 1):
        if a[i] > a[index]:
            max_sum = max(max_sum, dp[index] + a[i])
    return max_sum
a = [1, 101, 2, 3, 100, 4, 5]
n = len(a)
index = 4
k = 6.
 Test: def check():
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7
    assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71

2025-10-16 11:18:40 - Error: .
 Solution: def merge(lst):
    first_elements = []
    second_elements = []
    for sublist in lst:
        first_elements.append(sublist[0])
        second_elements.append(sublist[1])
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-16 11:18:46 - Error: must be real number, not str.
 Solution: def zero_count(nums):
    if not nums:
        return 'undefined'
    zero_count = 0
    non_zero_count = 0
    for num in nums:
        if num == 0:
            zero_count += 1
        else:
            non_zero_count += 1
    if non_zero_count == 0:
        return '1:0'
    elif zero_count == 0:
        return '0:1'
    return f'{zero_count}:{non_zero_count} (ratio: {zero_count / non_zero_count:.2f})'.
 Test: def check():
    assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)
    assert math.isclose(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.00, rel_tol=0.001)
    assert math.isclose(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.00, rel_tol=0.001)

2025-10-16 11:18:53 - Error: name 'defaultdict' is not defined.
 Solution: def max_aggregate(stdata):
    aggregate = defaultdict(int)
    for (key, value) in stdata:
        aggregate[key] += value
    max_key = max(aggregate, key=aggregate.get, default=None)
    max_value = aggregate[max_key] if max_key is not None else 0
    return (max_key, max_value).
 Test: def check():
    assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)
    assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)
    assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)

2025-10-16 11:19:10 - Error: .
 Solution: def find_First_Missing(array):
    if len(array) == 0:
        return 1
    expected_number = 1
    for num in array:
        if num == expected_number:
            expected_number += 1
        elif num > expected_number:
            break
    return expected_number.
 Test: def check():
    assert find_First_Missing([0,1,2,3]) == 4
    assert find_First_Missing([0,1,2,6,9]) == 3
    assert find_First_Missing([2,3,5,8,9]) == 0

2025-10-16 11:19:18 - Error: Radius must be a positive number..
 Solution: def triangle_area(r):
    if r <= 0:
        raise ValueError('Radius must be a positive number.')
    base = 2 * r
    height = r
    area = 0.5 * base * height
    return area.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-16 11:19:19 - Error: '<=' not supported between instances of 'tuple' and 'int'.
 Solution: def min_Jumps(steps, d):
    if steps <= 0:
        return 0 if d == 0 else float('inf')
    jump_count = 0
    current_position = 0
    while abs(current_position) < abs(d):
        jump_count += 1
        if current_position < d:
            current_position += steps
        else:
            current_position -= steps
    if current_position != d:
        overshoot = abs(current_position - d)
        if overshoot % steps == 0:
            jump_count += overshoot // steps
        else:
            jump_count = float('inf')
    return jump_count if current_position == d else float('inf').
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-16 11:19:22 - Error: .
 Solution: def comb_sort(nums):

    def get_next_gap(gap):
        gap = gap * 10 // 13
        return max(gap, 1)
    n = len(nums)
    gap = n
    sorted = False
    while not sorted:
        gap = get_next_gap(gap)
        sorted = True
        for i in range(n - gap):
            if nums[i] > nums[i + gap]:
                (nums[i], nums[i + gap]) = (nums[i + gap], nums[i])
                sorted = False
    return nums.
 Test: def check():
    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
    assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]
    assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]

2025-10-16 11:19:23 - Error: .
 Solution: def get_ludic(n):
    if n < 1:
        return []
    lucid_numbers = []
    current = 1
    while current <= n:
        lucid_numbers.append(current)
        current += sum((int(digit) for digit in str(current))) + 1
    return lucid_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-16 11:19:24 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count_0_to_1 = 0
    count_1_to_0 = 0
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            if str1[i] == '0':
                count_0_to_1 += 1
            else:
                count_1_to_0 += 1
    return max(count_0_to_1, count_1_to_0)
str1 = '1100'
str2 = '1010'.
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-16 11:19:28 - Error: .
 Solution: def max_difference(test_list):
    if len(test_list) < 2:
        return 0
    max_diff = float('-inf')
    for i in range(len(test_list)):
        for j in range(i + 1, len(test_list)):
            diff = abs(max(max(test_list[i]), max(test_list[j])) - min(min(test_list[i]), min(test_list[j])))
            max_diff = max(max_diff, diff)
    return max_diff.
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-16 11:19:29 - Error: .
 Solution: import math
def count_divisors(n):
    if n <= 0:
        return 0
    count = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            count += 1
            if i != n // i:
                count += 1
    return count.
 Test: def check():
    assert count_divisors(10)
    assert not count_divisors(100)
    assert count_divisors(125)

2025-10-16 11:19:30 - Error: unhashable type: 'list'.
 Solution: def Find_Min(lst):
    if not lst:
        return []
    element_count = {}
    left = 0
    min_length = float('inf')
    min_sublist = []
    unique_elements = set(lst)
    for right in range(len(lst)):
        element_count[lst[right]] = element_count.get(lst[right], 0) + 1
        while len(element_count) == len(unique_elements):
            current_length = right - left + 1
            if current_length < min_length:
                min_length = current_length
                min_sublist = lst[left:right + 1]
            element_count[lst[left]] -= 1
            if element_count[lst[left]] == 0:
                del element_count[lst[left]]
            left += 1
    return min_sublist if min_length != float('inf') else [].
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-16 11:19:32 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if not tuplex:
        return ()
    if m < 0:
        m = 0
    if n > len(tuplex):
        n = len(tuplex)
    result = list(tuplex[m:n])
    if len(result) < n - m:
        result.extend([50] * (n - m - len(result)))
    return tuple(result).
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-16 11:19:41 - Error: count_Pairs() takes 1 positional argument but 2 were given.
 Solution: def count_Pairs(arr):
    if len(arr) < 2:
        return 0
    count_map = {}
    for num in arr:
        if num in count_map:
            count_map[num] += 1
        else:
            count_map[num] = 1
    total_elements = len(arr)
    total_pairs = total_elements * (total_elements - 1) // 2
    equal_pairs = 0
    for count in count_map.values():
        if count > 1:
            equal_pairs += count * (count - 1) // 2
    return total_pairs - equal_pairs
arr = [1, 2, 3, 1, 2].
 Test: def check():
    assert count_Pairs([1,2,1],3) == 2
    assert count_Pairs([1,1,1,1],4) == 0
    assert count_Pairs([1,2,3,4,5],5) == 10

2025-10-16 11:19:44 - Error: concatenate_tuple() missing 1 required positional argument: 'delimiter'.
 Solution: def concatenate_tuple(test_tup, delimiter):
    if not test_tup:
        return ''
    return delimiter.join(map(str, test_tup)).
 Test: def check():
    assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
    assert concatenate_tuple(("QWE", "is", 4, "RTY") ) == 'QWE-is-4-RTY'
    assert concatenate_tuple(("ZEN", "is", 4, "OP") ) == 'ZEN-is-4-OP'

2025-10-16 11:19:45 - Error: .
 Solution: def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    (gcd, x1, y1) = extended_gcd(b, a % b)
    x = y1
    y = x1 - a // b * y1
    return (gcd, x, y)
def find_solution(a, b, n):
    (gcd, x, y) = extended_gcd(a, b)
    if n % gcd != 0:
        return None
    x *= n // gcd
    y *= n // gcd
    return (x, y).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-16 11:20:01 - Error: .
 Solution: def re_arrange_array(arr, n):
    if n <= 0 or not arr:
        return arr
    n = min(n, len(arr))
    negative = []
    positive = []
    for i in range(n):
        if arr[i] < 0:
            negative.append(arr[i])
        else:
            positive.append(arr[i])
    arr[:n] = negative + positive
    return arr
arr = [-1, 2, -3, 4, 5, 6, -7, 8, 9]
n = 9.
 Test: def check():
    assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]
    assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]
    assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]

2025-10-16 11:20:06 - Error: Function sum is not defined in the solution..
 Solution: .
 Test: def check():
    assert sum(10,15) == 6
    assert sum(100,150) == 93
    assert sum(4,6) == 3

2025-10-16 11:20:08 - Error: .
 Solution: def is_prime(num):
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True
def newman_prime(n):
    if n < 1:
        return None
    count = 0
    candidate = 5
    while count < n:
        if is_prime(candidate):
            count += 1
            if count == n:
                return candidate
        candidate += 2
    return None
n = 5.
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-16 16:05:06 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 16:05:06 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:05:07 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 16:05:07 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 16:05:08 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:05:08 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 16:05:09 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 16:05:09 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:05:10 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 16:05:10 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:05:10 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:05:10 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:05:13 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:05:13 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 16:05:13 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:05:32 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 16:05:35 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:05:36 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 16:05:37 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 16:05:39 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 16:05:40 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    while n % 2 == 0:
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 16:05:41 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:06:01 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:06:02 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 16:06:19 - Error: .
 Solution: def snake_to_camel(word):
    if not isinstance(word, str):
        raise ValueError('Input must be a string')
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:06:21 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    return n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 16:06:24 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:06:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:06:33 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:06:34 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    angle_radians = cmath.phase(z)
    angle_degrees = angle_radians * (180 / cmath.pi)
    return angle_degrees.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:06:44 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 16:07:11 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = max(frequency.values())
    max_items = [num for (num, freq) in frequency.items() if freq == max_freq]
    return max_items if len(max_items) > 1 else max_items[0].
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-16 16:07:11 - Error: .
 Solution: def string_to_tuple(str1):
    if not isinstance(str1, str):
        raise ValueError('Input must be a string')
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 16:07:11 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 16:07:16 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for tup in nums:
        if not tup:
            averages.append(0)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:07:17 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:07:19 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:07:23 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1]) * abs(list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 16:07:23 - Error: .
 Solution: def get_max_sum(n, memo={}):
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    else:
        memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
        return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 16:07:35 - Error: words must be a list of strings.
 Solution: def long_words(n, words):
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 16:07:37 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        (a, b) = (0, 1)
        for _ in range(2, n + 1):
            (a, b) = (b, a + 2 * b)
        return b.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 16:07:41 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:07:44 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:07:47 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:09:28 - Error: maximum recursion depth exceeded in comparison.
 Solution: def opposite_Signs(x, y):
    if x == 0 or y == 0:
        return False
    if x > 0 and y < 0 or (x < 0 and y > 0):
        return True
    return opposite_Signs(abs(x), abs(y)).
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-16 16:09:51 - Error: .
 Solution: def remove_odd(str1):
    stack = []
    for index in range(len(str1)):
        if index % 2 == 0:
            stack.append(str1[index])
    return ''.join(stack).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:10:23 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    stack = []
    current_part = ''
    for char in word:
        if char == '_':
            if current_part:
                stack.append(current_part)
                current_part = ''
        else:
            current_part += char
    if current_part:
        stack.append(current_part)
    camel_case = ''
    for (i, part) in enumerate(stack):
        if i == 0:
            camel_case += part.lower()
        else:
            camel_case += part.capitalize()
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:10:45 - Error: .
 Solution: def swap_List(newList):
    if len(newList) <= 1:
        return newList

    def recursive_swap(lst, start, end):
        if start >= end:
            return lst
        (lst[start], lst[end]) = (lst[end], lst[start])
        return recursive_swap(lst, start + 1, end - 1)
    return recursive_swap(newList, 0, len(newList) - 1).
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-16 16:11:10 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 16:11:22 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    if r == 0 or h == 0:
        return 0.0
    base_area = math.pi * r ** 2
    curved_surface_area = 2 * math.pi * r * h
    return 2 * base_area + curved_surface_area
r = 10
h = 5.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:11:58 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:12:13 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    return sum((num for num in count if count[num] == 1))
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:12:14 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if n == 0 or m < 0 or m > n:
        return 0
    if m == 0 or m == n:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:12:15 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return harmonic_sum(n - 1) + 1 / n.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:12:16 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):
    if startnum > endnum:
        return []

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits))
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-16 16:12:25 - Error: .
 Solution: def count_equal_numbers(x, y, z):
    return 3 if x == y == z else 2 if x == y or y == z or x == z else 0
def test_three_equal(x, y, z):
    result = count_equal_numbers(x, y, z)
    print(f'Count of equal numbers among {x}, {y}, {z}: {result}').
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:12:26 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:12:31 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if not isinstance(z, complex):
        raise ValueError('Input must be a complex number.')
    if z == 0:
        raise ValueError('Angle is undefined for the complex number 0 + 0i')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:12:57 - Error: .
 Solution: def count_rotation(arr):

    def binary_search_rotations(start, end):
        if start > end:
            return 0
        if start == end:
            return start
        if arr[start] <= arr[end]:
            return start
        mid = (start + end) // 2
        if mid < end and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > start and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[start]:
            return binary_search_rotations(mid + 1, end)
        else:
            return binary_search_rotations(start, mid - 1)
    n = len(arr)
    if n == 0:
        return 0
    return binary_search_rotations(0, n - 1)
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:13:30 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:14:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:14:45 - Error: .
 Solution: def eulerian_num(n, m):
    E = [[0] * (m + 1) for _ in range(n + 1)]
    E[0][0] = 1
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            E[i][j] = (i - j) * E[i - 1][j] + (j + 1) * E[i - 1][j - 1]
    return E[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:14:50 - Error: .
 Solution: from collections import defaultdict, deque
import heapq
def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:14:52 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) if len(tup) > 0 else 0 for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:15:01 - Error: Function minimum is not defined in the solution..
 Solution: from collections import defaultdict, deque
import heapq.
 Test: def check():
    assert minimum(1,2) == 1
    assert minimum(-5,-4) == -5
    assert minimum(0,0) == 0

2025-10-16 16:15:09 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:15:15 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    n = len(list1)
    if n < 2:
        return 0
    for i in range(n):
        for j in range(i + 1, n):
            product = abs(list1[i][0] * list1[j][0])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 16:15:23 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified tuples from the given tuple.

    Parameters:
    test_tup (tuple): The original tuple from which to remove elements.
    to_remove (tuple): A tuple containing elements to be removed.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    return tuple((item for item in test_tup if item not in to_remove)).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 16:15:27 - Error: unhashable type: 'list'.
 Solution: def Find_Max_Length(lst):
    max_length = 0
    seen = set()
    left = 0
    for right in range(len(lst)):
        while lst[right] in seen:
            seen.remove(lst[left])
            left += 1
        seen.add(lst[right])
        max_length = max(max_length, right - left + 1)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-16 16:15:37 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if x == y == z:
        count = 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:15:47 - Error: .
 Solution: def is_polite(n):
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 16:15:55 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (argument) of a complex number represented by its real and imaginary parts.

    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.

    Returns:
    float: The angle in radians.
    """
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:15:57 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    if n == 0:
        return 0
    if arr[low] <= arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:16:58 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:17:24 - Error: .
 Solution: def is_undulating(n):
    str_n = str(n)
    if len(str_n) < 3:
        return False
    direction = None
    for i in range(len(str_n) - 1):
        if str_n[i] < str_n[i + 1]:
            if direction is None:
                direction = 'up'
            elif direction == 'down':
                return False
            direction = 'up'
        elif str_n[i] > str_n[i + 1]:
            if direction is None:
                direction = 'down'
            elif direction == 'up':
                return False
            direction = 'down'
        else:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-16 16:17:27 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * (h + r), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:17:47 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise ValueError('k is out of bounds')

    def quickselect(left, right, k_smallest):
        if left == right:
            return arr[left]
        pivot_index = partition(left, right)
        if k_smallest == pivot_index:
            return arr[k_smallest]
        elif k_smallest < pivot_index:
            return quickselect(left, pivot_index - 1, k_smallest)
        else:
            return quickselect(pivot_index + 1, right, k_smallest)

    def partition(left, right):
        pivot = arr[right]
        i = left
        for j in range(left, right):
            if arr[j] < pivot:
                (arr[i], arr[j]) = (arr[j], arr[i])
                i += 1
        (arr[i], arr[right]) = (arr[right], arr[i])
        return i
    return quickselect(0, len(arr) - 1, k - 1)
arr = [3, 2, 1, 5, 6, 4]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 16:19:26 - Error: .
 Solution: def eulerian_num(n, m):
    E = [[0] * (n + 1) for _ in range(n + 1)]
    E[0][0] = 1
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            E[i][j] = (i - j) * E[i - 1][j] + (j + 1) * E[i - 1][j - 1]
    return E[n][m] if m <= n else 0.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:20:13 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:20:27 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [3, 4, 5, 1, 2].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:20:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:21:13 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_item = None
    max_count = 0
    for (item, count) in frequency.items():
        if count > max_count or (count == max_count and (max_item is None or item < max_item)):
            max_count = count
            max_item = item
    return max_item.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-16 16:21:38 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    prev2 = 0
    prev1 = 1
    for i in range(2, n + 1):
        current = prev2 + 2 * prev1
        (prev2, prev1) = (prev1, current)
    return current
n = 10.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 16:21:40 - Error: .
 Solution: def average_tuple(nums):
    """
    Calculate the average of each tuple in a tuple of tuples.

    Args:
    nums (tuple of tuples): A tuple containing tuples of numeric values.

    Returns:
    list: A list of averages for each tuple. Returns None for empty tuples.
    """
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for tup in nums:
        if not isinstance(tup, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(tup) == 0:
            averages.append(None)
        elif all((isinstance(x, (int, float)) for x in tup)):
            avg = sum(tup) / len(tup)
            averages.append(avg)
        else:
            raise ValueError('All elements in the tuple must be numeric.')
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:22:04 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:22:18 - Error: Both real and imaginary parts must be numeric values..
 Solution: import cmath
def angle_complex(real, imag):
    """
    Calculate the angle (argument) of a complex number given its real and imaginary parts.

    Parameters:
    real (float): The real part of the complex number.
    imag (float): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    """
    if not isinstance(real, (int, float)) or not isinstance(imag, (int, float)):
        raise ValueError('Both real and imaginary parts must be numeric values.')
    complex_number = complex(real, imag)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:22:25 - Error: .
 Solution: from collections import Counter
from typing import List, Union
def find_sum(arr: List[Union[int, float]]) -> float:
    """
    Find the sum of non-repeated elements in a list.

    Parameters:
    arr (List[Union[int, float]]): A list of integers or floats.

    Returns:
    float: The sum of non-repeated elements.
    """
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:23:22 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) + abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 16:23:23 - Error: .
 Solution: def harmonic_sum(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:25:42 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        print(0)
        return
    total_sum = sum((round(num) for num in list1))
    length = len(list1)
    result = total_sum * length
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 16:25:56 - Error: .
 Solution: def remove_odd(str1):
    result = []
    for index in range(len(str1)):
        if index % 2 == 0:
            result.append(str1[index])
    return ''.join(result)
result = remove_odd('abcdefg').
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:26:14 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    camel_case = []
    length = len(word)
    i = 0
    while i < length:
        if word[i] == '_':
            i += 1
            if i < length:
                camel_case.append(word[i].upper())
        elif len(camel_case) == 0:
            camel_case.append(word[i])
        else:
            camel_case.append(word[i])
        i += 1
    return ''.join(camel_case).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:27:11 - Error: .
 Solution: def kth_element(arr, k):
    if not arr or k < 1 or k > len(arr):
        return None

    def partition(arr, low, high):
        pivot_value = arr[high]
        store_index = low
        for i in range(low, high):
            if arr[i] < pivot_value:
                (arr[store_index], arr[i]) = (arr[i], arr[store_index])
                store_index += 1
        (arr[store_index], arr[high]) = (arr[high], arr[store_index])
        return store_index

    def quickselect(arr, low, high, k):
        if low == high:
            return arr[low]
        pivot_index = partition(arr, low, high)
        if k == pivot_index:
            return arr[k]
        elif k < pivot_index:
            return quickselect(arr, low, pivot_index - 1, k)
        else:
            return quickselect(arr, pivot_index + 1, high, k)
    return quickselect(arr, 0, len(arr) - 1, k - 1)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 16:27:16 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:27:19 - Error: .
 Solution: def find_star_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer.')
    return n * (2 * n - 1) + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:27:19 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return re.fullmatch(pattern, text) is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 16:27:20 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for inner_tuple in nums:
        if not inner_tuple:
            averages.append(0)
            continue
        avg = sum(inner_tuple) / len(inner_tuple)
        averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:27:23 - Error: .
 Solution: def find_length(string):
    if not string:
        return 0
    max_diff = 0
    current_diff = 0
    diff_index = {0: -1}
    for i in range(len(string)):
        current_diff += 1 if string[i] == '0' else -1
        if current_diff in diff_index:
            max_diff = max(max_diff, i - diff_index[current_diff])
        else:
            diff_index[current_diff] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-16 16:27:49 - Error: .
 Solution: import cmath
def angle_complex(real, imag):
    if real == 0 and imag == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    complex_number = complex(real, imag)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:28:19 - Error: .
 Solution: def eulerian_num(n, m):
    A = [[0] * (m + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, min(i, m + 1)):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:28:27 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    total = 0.0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:28:31 - Error: .
 Solution: def find_sum(arr):
    if not arr:
        return 0
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, value) in count.items() if value == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:28:37 - Error: .
 Solution: def string_to_tuple(str1):
    if str1 is None:
        return ()
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 16:28:37 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0, 1]
        for i in range(2, n + 1):
            next_value = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
            jacobsthal.append(next_value)
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 16:28:49 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:29:52 - Error: .
 Solution: def Diff(li1, li2):
    return [item for item in li1 if item not in li2] + [item for item in li2 if item not in li1].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:33:06 - Error: .
 Solution: def remove_odd(str1):
    result = []
    for char in str1:
        if ord(char) % 2 == 0:
            result.append(char)
    return ''.join(result).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:33:06 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0]
    for part in parts[1:]:
        if part:
            camel_case += part.capitalize()
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:33:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_surface_area = 2 * math.pi * r * h
    top_bottom_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_surface_area + top_bottom_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:33:27 - Error: .
 Solution: def find_sum(arr):
    """
    Returns the sum of non-repeated elements in the given list.
    
    Parameters:
    arr (list): A list of numbers.
    
    Returns:
    int: The sum of non-repeated elements.
    """
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('All elements must be numbers.')
    count_map = {}
    for num in arr:
        count_map[num] = count_map.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in count_map.items() if count == 1))
    return non_repeated_sum
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:34:02 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    if n % 2 == 0:
        return True
    if n % 4 == 2:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 16:34:03 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][0] * list1[j][1])
            product3 = abs(list1[i][1] * list1[j][0])
            product4 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 16:34:05 - Error: .
 Solution: from typing import Tuple, List, Optional
def average_tuple(nums: Tuple[Tuple[float, ...], ...]) -> List[Optional[float]]:
    """
    Calculate the average of each tuple in a tuple of tuples.

    Args:
        nums (Tuple[Tuple[float, ...], ...]): A tuple containing tuples of numbers.

    Returns:
        List[Optional[float]]: A list of averages for each tuple, or None for empty tuples.
    """
    averages = []
    for tup in nums:
        if not isinstance(tup, tuple):
            raise ValueError('Each element must be a tuple.')
        avg = sum(tup) / len(tup) if len(tup) > 0 else None
        averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:34:50 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    elif count == 2:
        return 2
    else:
        return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:34:59 - Error: .
 Solution: def is_polite(n):
    while n > 0 and n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 16:35:57 - Error: .
 Solution: def count_rotation(arr):
    (left, right) = (0, len(arr) - 1)
    if arr[left] <= arr[right]:
        return 0
    while left <= right:
        mid = (left + right) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < len(arr) - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:36:02 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m >= n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = (i + 1) * A[i - 1][j]
            elif j == i:
                A[i][j] = A[i - 1][j - 1]
            else:
                A[i][j] = (i - j + 1) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:36:18 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:36:35 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('Input must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:37:05 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / k for k in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:38:12 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle of the complex number in radians.
    
    Raises:
    ValueError: If the complex number is 0 + 0j, as the angle is undefined.
    """
    if a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:38:34 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise ValueError('k is out of bounds')

    def quickselect(left, right, k):
        if left == right:
            return arr[left]
        pivot_index = partition(left, right)
        if k == pivot_index:
            return arr[k]
        elif k < pivot_index:
            return quickselect(left, pivot_index - 1, k)
        else:
            return quickselect(pivot_index + 1, right, k)

    def partition(left, right):
        pivot = arr[right]
        i = left
        for j in range(left, right):
            if arr[j] < pivot:
                (arr[i], arr[j]) = (arr[j], arr[i])
                i += 1
        (arr[i], arr[right]) = (arr[right], arr[i])
        return i
    return quickselect(0, len(arr) - 1, k - 1)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 16:39:44 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:39:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:39:45 - Error: .
 Solution: def square_Sum(n):
    return n ** 2 * (2 * n - 1) * (2 * n + 1) // 3.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-16 16:39:51 - Error: name 'defaultdict' is not defined.
 Solution: def count_Substrings(s):
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-16 16:39:58 - Error: .
 Solution: def test_three_equal(x, y, z):
    return sum([x == y, y == z, x == z]).
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:40:02 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 16:40:19 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            eulerian[i][j] = (i - j) * eulerian[i - 1][j] + (j + 1) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 16:40:57 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:41:03 - Error: .
 Solution: def dif_Square(n):
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 16:41:13 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:41:19 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:41:23 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:41:46 - Error: .
 Solution: def find_length(string):
    max_diff = 0
    current_diff = 0
    diff_map = {0: -1}
    for (i, char) in enumerate(string):
        current_diff += 1 if char == '0' else -1
        if current_diff in diff_map:
            max_diff = max(max_diff, i - diff_map[current_diff])
        else:
            diff_map[current_diff] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-16 16:41:54 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (left, right) = (0, len(arr) - 1)
    while left <= right:
        if arr[left] <= arr[right]:
            return left
        mid = (left + right) // 2
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:42:56 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 16:43:11 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:45:11 - Error: Input tuple must have at least 2 elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least 2 elements.')
    return tuple((a * b for (a, b) in zip(test_tup, test_tup[1:]))).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-16 16:45:20 - Error: .
 Solution: def remove_odd(str1):
    return str1[::2].
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:46:02 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:46:09 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    count = 0
    n = len(s)
    prefix_sum = 0
    sum_count = defaultdict(int)
    sum_count[0] = 1
    for i in range(n):
        prefix_sum += int(s[i])
        count += sum_count[prefix_sum - (i + 1)]
        sum_count[prefix_sum] += 1
    return count.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-16 16:46:10 - Error: .
 Solution: def harmonic_sum(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError('Input must be a positive integer.')
    return sum((1.0 / k for k in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:46:12 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] == arr[mid] == arr[high]:
            low += 1
            high -= 1
        elif arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:46:46 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    return words[0] + ''.join((word.capitalize() for word in words[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:46:47 - Error: .
 Solution: def find_sum(arr):
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:46:51 - Error: .
 Solution: import cmath
def angle_complex(a, b=None):
    """
    Calculate the angle (in radians) of a complex number represented by its real and imaginary parts.

    Parameters:
    a (float or complex): The real part of the complex number or a complex number itself.
    b (float, optional): The imaginary part of the complex number. If a is a complex number, b is ignored.

    Returns:
    float: The angle in radians.

    Raises:
    ValueError: If both a and b are zero, as the angle is undefined.
    """
    if isinstance(a, complex):
        return cmath.phase(a)
    elif b is None:
        raise ValueError('Both a and b cannot be None.')
    elif a == 0 and b == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    else:
        return cmath.phase(complex(a, b)).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:47:17 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    if len(nums) == 0:
        return []
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0)
            continue
        if not all((isinstance(x, (int, float)) for x in inner_tuple)):
            raise ValueError('All elements in inner tuples must be numeric.')
        average = sum(inner_tuple) / len(inner_tuple)
        averages.append(average)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:47:27 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder (must be positive).
    h (float): The height of the cylinder (must be positive).

    Returns:
    float: The surface area of the cylinder.
    
    Raises:
    ValueError: If radius or height is not positive.
    TypeError: If radius or height is not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise TypeError('Radius and height must be numbers.')
    if r <= 0 or h <= 0:
        raise ValueError('Radius and height must be positive numbers.')
    surface_area = 2 * math.pi * r * (h + r)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:50:51 - Error: .
 Solution: from collections import defaultdict
def count_Substrings(s):
    count = 0
    n = len(s)
    prefix_count = defaultdict(int)
    prefix_count[0] = 1
    current_sum = 0
    for i in range(n):
        current_sum += int(s[i])
        count += prefix_count[current_sum - (i + 1)]
        prefix_count[current_sum] += 1
    return count
s = '123'.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-16 16:51:01 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0:
        return True
    if n % 4 != 2:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 16:51:03 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    words = word.split('_')
    camel_case = words[0] + ''.join((word.capitalize() for word in words[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 16:51:06 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (low, high) = (0, len(arr) - 1)
    if arr[low] < arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if (mid == 0 or arr[mid] < arr[mid - 1]) and (mid == len(arr) - 1 or arr[mid] < arr[mid + 1]):
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return low
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 16:51:20 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 16:51:24 - Error: .
 Solution: def harmonic_sum(n):
    """Calculate the harmonic sum of n-1.

    Args:
        n (int): A positive integer.

    Returns:
        float: The harmonic sum of n-1, or 0.0 if n <= 1.

    Raises:
        TypeError: If n is not an integer.
    """
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n <= 1:
        return 0.0
    return sum((1.0 / k for k in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 16:51:29 - Error: .
 Solution: def Diff(li1, li2):
    """
    Returns the difference between two lists.
    
    The difference is defined as elements that are in li1 but not in li2,
    and elements that are in li2 but not in li1. Duplicates in li1 will be retained in the output.
    
    Parameters:
    li1 (list): The first list.
    li2 (list): The second list.
    
    Returns:
    list: A list containing the difference between the two lists.
    """
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    diff_li1 = [item for item in li1 if item not in li2]
    diff_li2 = [item for item in li2 if item not in li1]
    return diff_li1 + diff_li2.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 16:51:30 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 16:51:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r <= 0 or h <= 0:
        raise ValueError('Both radius and height must be positive numbers.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 16:51:59 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    if len(nums) == 0:
        return []
    averages = []
    for inner_tuple in nums:
        if len(inner_tuple) == 0:
            averages.append(None)
        else:
            if not all((isinstance(x, (int, float)) for x in inner_tuple)):
                raise TypeError('All elements in inner tuples must be numeric.')
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 16:52:10 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0i.')
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 16:52:11 - Error: .
 Solution: from collections import Counter
def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    element_count = Counter(arr)
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 16:52:46 - Error: .
 Solution: def common_element(list1, list2):
    return bool(set(list1).intersection(list2)).
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-16 16:53:15 - Error: .
 Solution: from functools import cmp_to_key
def compare(x, y):
    return (y + x > x + y) - (y + x < x + y)
def find_Max_Num(arr):
    if not arr:
        return '0'
    arr = list(map(str, arr))
    arr.sort(key=cmp_to_key(compare))
    largest_num = ''.join(arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-16 16:53:16 - Error: .
 Solution: def geometric_sum(n):
    if n <= 0:
        raise ValueError('Input must be a positive integer.')
    if n == 1:
        return 1
    return 1 / 2 ** (n - 1) + geometric_sum(n - 1).
 Test: def check():
    assert geometric_sum(7) == 1.9921875
    assert geometric_sum(4) == 1.9375
    assert geometric_sum(8) == 1.99609375

2025-10-16 16:53:20 - Error: .
 Solution: import math
def wind_chill(v, t):
    if v < 0:
        raise ValueError('Wind velocity must be non-negative.')
    if v == 0:
        return t
    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16
    return math.ceil(wci).
 Test: def check():
    assert wind_chill(120,35)==40
    assert wind_chill(40,20)==19
    assert wind_chill(10,8)==6

2025-10-16 16:53:25 - Error: .
 Solution: def triangle_area(r):
    if r <= 0:
        return None
    return r * r / 2.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-16 16:53:26 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero for a parabola.")
    V_x = -b / (2 * a)
    V_y = a * V_x ** 2 + b * V_x + c
    p = 1 / (4 * abs(a))
    directrix = V_y - p
    return directrix
def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero for a parabola.")
    V_x = -b / (2 * a)
    directrix = 1 / (4 * a) + (c - b ** 2 / (4 * a))
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-16 16:53:33 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n < 1:
        return False
    powers = set()
    power = 1
    while power <= n:
        powers.add(power)
        power *= 2
    for p in powers:
        if n - p in powers:
            return True
    return False.
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-16 16:53:38 - Error: Input must be a dictionary.
 Solution: def my_dict(dict1: any) -> bool:
    """
    Check if the provided input is an empty dictionary.

    Parameters:
    dict1 (any): The input to check.

    Returns:
    bool: True if dict1 is an empty dictionary, False otherwise.

    Raises:
    ValueError: If dict1 is not a dictionary.
    """
    if not isinstance(dict1, dict):
        raise ValueError('Input must be a dictionary')
    return len(dict1) == 0.
 Test: def check():
    assert my_dict({10})==False
    assert my_dict({11})==False
    assert my_dict({})==True

2025-10-16 16:53:40 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    if not arr:
        return None
    n = len(arr)
    if index < 0 or index >= n:
        return None
    rotations = rotations % n
    new_index = (index + rotations) % n
    if ranges:
        valid = False
        for (start, end) in ranges:
            if start <= new_index <= end:
                valid = True
                break
        if not valid:
            return None
    return arr[new_index]
arr = [1, 2, 3, 4, 5]
ranges = [[0, 2], [0, 3]]
rotations = 2
index = 1.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-16 16:53:42 - Error: .
 Solution: import re
def text_starta_endb(text):
    pattern = 'a.*b'
    return bool(re.search(pattern, text)).
 Test: def check():
    assert text_starta_endb("aabbbb")
    assert not text_starta_endb("aabAbbbc")
    assert not text_starta_endb("accddbbjjj")

2025-10-16 16:53:44 - Error: .
 Solution: def count_vowels(test_str):
    vowels = set('aeiouAEIOU')
    count = 0
    length = len(test_str)
    counted_chars = set()
    for i in range(length):
        if i > 0 and test_str[i - 1] in vowels or (i < length - 1 and test_str[i + 1] in vowels):
            if test_str[i] not in counted_chars:
                count += 1
                counted_chars.add(test_str[i])
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-16 16:53:48 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        raise ValueError('Array must contain at least two elements.')
    max1 = max2 = float('-inf')
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return (max2, max1)
arr = [1, 2, 3, 4, 7, 0, 8, 4].
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-16 16:53:50 - Error: .
 Solution: import re
def removezero_ip(ip):
    if not re.match('^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', ip):
        return 'Invalid IP address format'
    cleaned_octets = []
    octets = ip.split('.')
    for octet in octets:
        cleaned_octets.append(str(int(octet)))
    return '.'.join(cleaned_octets).
 Test: def check():
    assert removezero_ip("216.08.094.196")==('216.8.94.196')
    assert removezero_ip("12.01.024")==('12.1.24')
    assert removezero_ip("216.08.094.0196")==('216.8.94.196')

2025-10-16 16:54:00 - Error: .
 Solution: def empty_dit(list1):
    return isinstance(list1, list) and all((isinstance(d, dict) and (not d) for d in list1)).
 Test: def check():
    assert empty_dit([{},{},{}])==True
    assert empty_dit([{1,2},{},{}])==False
    assert empty_dit({})==True

2025-10-16 16:54:01 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-16 16:54:08 - Error: .
 Solution: from array import array
def positive_count(nums: array) -> float:
    """
    Calculate the ratio of positive numbers in an array of integers.

    Parameters:
    nums (array): An array of integers.

    Returns:
    float: The ratio of positive integers to the total number of integers.
           Returns 0.0 if the array is empty or if there are no positive integers.
    """
    total_count = len(nums)
    if total_count == 0:
        return 0.0
    positive_count = sum((1 for num in nums if num > 0))
    return positive_count / total_count.
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-16 16:54:08 - Error: .
 Solution: from collections import deque
def check_expression(exp):
    stack = deque()
    for char in exp:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0.
 Test: def check():
    assert check_expression("{()}[{}]") == True
    assert check_expression("{()}[{]") == False
    assert check_expression("{()}[{}][]({})") == True

2025-10-16 16:54:13 - Error: .
 Solution: import math
def sum_Of_product(n):
    if n < 2:
        return 0
    total_sum = 0
    for k in range(n):
        C_n_k = math.comb(n, k)
        C_n_k1 = math.comb(n, k + 1)
        total_sum += C_n_k * C_n_k1
    return total_sum.
 Test: def check():
    assert sum_Of_product(3) == 15
    assert sum_Of_product(4) == 56
    assert sum_Of_product(1) == 1

2025-10-16 16:54:14 - Error: .
 Solution: import re
def snake_to_camel(word):
    if not word:
        return ''
    return re.sub('_(.)', lambda x: x.group(1).upper(), word).
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-16 16:54:16 - Error: bad operand type for abs(): 'list'.
 Solution: def sum_of_digits(nums):
    return sum((sum((int(digit) for digit in str(abs(num)))) for num in nums)).
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-16 16:54:17 - Error: .
 Solution: def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    (gcd, x1, y1) = extended_gcd(b, a % b)
    x = y1
    y = x1 - a // b * y1
    return (gcd, x, y)
def find_solution(a, b, n):
    if a == 0 and b == 0:
        return (0, 0) if n == 0 else None
    (gcd, x, y) = extended_gcd(a, b)
    if n % gcd != 0:
        return None
    x *= n // gcd
    y *= n // gcd
    return (x, y).
 Test: def check():
    assert find_solution(2, 3, 7) == (2, 1)
    assert find_solution(4, 2, 7) == None
    assert find_solution(1, 13, 17) == (4, 1)

2025-10-16 16:54:21 - Error: .
 Solution: def is_prime(num):
    """Check if a number is prime using trial division."""
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True
def newman_prime(n):
    """Find the nth NewmanShanksWilliams prime number."""
    if n < 1:
        raise ValueError('n must be a positive integer.')
    newman_primes = []
    p = 2
    while len(newman_primes) < n:
        candidate = 2 ** p - 1
        if is_prime(candidate):
            newman_primes.append(candidate)
        p += 1
    return newman_primes[n - 1].
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-16 16:54:25 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    return sorted(nums_str, key=lambda x: int(x))
nums_str = ['4', '12', '45', '7', '0', '100', '200', '-12', '-500'].
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-16 16:54:27 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    if not text or not pattern:
        return None
    matches = [(match.group(), match.start(), match.end()) for match in re.finditer(re.escape(pattern), text)]
    return matches if matches else None
text = 'python programming, python language'
pattern = 'python'.
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-16 16:54:27 - Error: .
 Solution: import math
import cmath
def polar_rect(r, theta):
    if r < 0:
        raise ValueError('Radial distance (r) must be non-negative.')
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return (x, y).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-16 16:54:44 - Error: .
 Solution: def merge(lst):
    if not lst:
        return [[], []]
    first_elements = [sublist[0] for sublist in lst]
    second_elements = [sublist[1] for sublist in lst]
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-16 16:54:44 - Error: .
 Solution: def cal_sum(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 3
    elif n == 3:
        return 5
    (P0, P1) = (3, 0)
    sum_perrin = P0 + P1 + 2
    for i in range(3, n):
        next_perrin = P0 + P1
        sum_perrin += next_perrin
        (P0, P1) = (P1, next_perrin)
    return sum_perrin.
 Test: def check():
    assert cal_sum(9) == 49
    assert cal_sum(10) == 66
    assert cal_sum(11) == 88

2025-10-16 16:54:46 - Error: .
 Solution: def trim_tuple(test_list, K):
    """
    Trims each tuple in the given list by K elements from both ends.
    
    Parameters:
    test_list (list of tuples): The list of tuples to be trimmed.
    K (int): The number of elements to trim from each end of the tuples.
    
    Returns:
    list of tuples: A new list of tuples after trimming.
    
    Raises:
    ValueError: If K is a negative integer.
    """
    if K < 0:
        raise ValueError('K must be a non-negative integer.')
    trimmed_list = []
    for tup in test_list:
        if K >= len(tup) // 2:
            trimmed_list.append(())
        else:
            trimmed_list.append(tup[K:len(tup) - K])
    return trimmed_list
test_list = [(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)]
K = 2.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-16 16:54:50 - Error: All elements in both tuples must be numeric..
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Both tuples must be of the same length.')
    if len(test_tup1) == 0:
        return ()
    if not all((isinstance(x, (int, float)) for x in test_tup1)) or not all((isinstance(x, (int, float)) for x in test_tup2)):
        raise TypeError('All elements in both tuples must be numeric.')
    result = tuple((a * b for (a, b) in zip(test_tup1, test_tup2)))
    return result.
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-16 16:54:52 - Error: check_value() takes 1 positional argument but 2 were given.
 Solution: def check_value(d):
    if not d:
        return True
    first_value = next(iter(d.values()))
    for value in d.values():
        if value != first_value:
            return False
    return True.
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-16 16:55:09 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        raise ValueError('Strings must be of the same length.')
    count_0_to_1 = 0
    count_1_to_0 = 0
    for (a, b) in zip(str1, str2):
        if a == '0' and b == '1':
            count_0_to_1 += 1
        elif a == '1' and b == '0':
            count_1_to_0 += 1
    return max(count_0_to_1, count_1_to_0)
str1 = '1100'
str2 = '1010'.
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-16 16:55:14 - Error: Input must be a complex number or a list of complex numbers..
 Solution: import cmath
def convert(numbers):
    if isinstance(numbers, complex):
        numbers = [numbers]
    elif not isinstance(numbers, list):
        raise ValueError('Input must be a complex number or a list of complex numbers.')
    polar_coordinates = []
    for number in numbers:
        if not isinstance(number, complex):
            raise ValueError('All elements must be complex numbers.')
        polar_coordinates.append(cmath.polar(number))
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-16 16:55:15 - Error: .
 Solution: def remove_kth_element(list1, L):
    if not list1:
        return []
    if L < 0 or L >= len(list1):
        raise IndexError('Index out of bounds')
    return [list1[i] for i in range(len(list1)) if i != L].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-16 16:55:16 - Error: .
 Solution: def even_bit_set_number(n):
    """
    Set all even bits of the given integer n to 1.
    
    Parameters:
    n (int): The input integer whose even bits are to be set.
    
    Returns:
    int: The integer with all even bits set to 1.
    """
    mask = 2863311530
    result = n | mask
    return result.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-16 16:55:17 - Error: .
 Solution: def find_Rotations(s):
    n = len(s)
    if n <= 1:
        return 0
    double_s = s + s
    for i in range(1, n):
        if double_s[i:i + n] == s:
            return i
    return 0.
 Test: def check():
    assert find_Rotations("aaaa") == 1
    assert find_Rotations("ab") == 2
    assert find_Rotations("abc") == 3

2025-10-16 16:55:22 - Error: count_first_elements() missing 1 required positional argument: 'element'.
 Solution: def count_first_elements(test_tup, element):
    """
    Count the number of elements that occur before the first occurrence of the specified element in the tuple.

    Parameters:
    test_tup (tuple): The tuple to search.
    element: The element to count occurrences before.

    Returns:
    int: The count of elements before the first occurrence of the specified element.
    If the tuple is empty or the element is not found, returns 0.
    """
    if not test_tup or element not in test_tup:
        return 0
    index = test_tup.index(element)
    return index.
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-16 16:55:33 - Error: test_tup must be a list of tuples..
 Solution: from typing import List, Tuple, Any
def check_K(test_tup: List[Tuple[Any]], K: Any) -> bool:
    """
    Check if the given value K is present in any of the tuples in the list.

    Parameters:
    test_tup (List[Tuple[Any]]): A list of tuples to search through.
    K (Any): The value to search for.

    Returns:
    bool: True if K is found in any tuple, False otherwise.
    """
    if not isinstance(test_tup, list):
        raise ValueError('test_tup must be a list of tuples.')
    for tup in test_tup:
        if not isinstance(tup, tuple):
            raise ValueError('Each element in test_tup must be a tuple.')
    return any((K in tup for tup in test_tup))
test_tup = [(1, 2), (3, 4), (5, 6)]
K = 3.
 Test: def check():
    assert check_K((10, 4, 5, 6, 8), 6) == True
    assert check_K((1, 2, 3, 4, 5, 6), 7) == False
    assert check_K((7, 8, 9, 44, 11, 12), 11) == True

2025-10-16 16:55:45 - Error: .
 Solution: from itertools import chain, combinations
def combinations_list(list1):
    unique_list = list(set(list1))
    return list(chain.from_iterable((combinations(unique_list, r) for r in range(len(unique_list) + 1)))).
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-16 16:55:48 - Error: Steps must be a positive number..
 Solution: def min_Jumps(steps, d):
    if not isinstance(steps, (int, float)) or steps <= 0:
        raise ValueError('Steps must be a positive number.')
    if not isinstance(d, (int, float)):
        raise ValueError('Distance must be a number.')
    if d == 0:
        return 0
    jumps = abs(d) // steps
    if abs(d) % steps != 0:
        jumps += 1
    return jumps.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-16 16:55:54 - Error: All elements of the tuple must be strings..
 Solution: def concatenate_tuple(test_tup, delimiter=', '):
    if not isinstance(test_tup, (tuple, list)):
        raise ValueError('Input must be a tuple or a list.')
    if isinstance(test_tup, list):
        test_tup = tuple(test_tup)
    if not all((isinstance(item, str) for item in test_tup)):
        raise ValueError('All elements of the tuple must be strings.')
    return delimiter.join(test_tup).
 Test: def check():
    assert concatenate_tuple(("ID", "is", 4, "UTS") ) == 'ID-is-4-UTS'
    assert concatenate_tuple(("QWE", "is", 4, "RTY") ) == 'QWE-is-4-RTY'
    assert concatenate_tuple(("ZEN", "is", 4, "OP") ) == 'ZEN-is-4-OP'

2025-10-16 16:55:54 - Error: .
 Solution: def max_difference(test_list):
    if not test_list:
        return None
    differences = [a - b for (a, b) in test_list]
    return max(differences)
test_list = [(5, 3), (10, 2), (7, 7), (4, 1)].
 Test: def check():
    assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7
    assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15
    assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23

2025-10-16 16:55:56 - Error: Input must be a tuple..
 Solution: def find_lists(input_tuple):
    if not isinstance(input_tuple, tuple):
        raise ValueError('Input must be a tuple.')
    count = 0
    for element in input_tuple:
        if isinstance(element, list):
            count += 1
    return count.
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-16 16:55:58 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    if not isinstance(actual_cost, (int, float)) or not isinstance(sale_amount, (int, float)):
        raise TypeError('Actual cost and sale amount must be numeric values.')
    if actual_cost < 0 or sale_amount < 0:
        raise ValueError('Actual cost and sale amount must be non-negative.')
    loss = actual_cost - sale_amount
    return loss if loss > 0 else 0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-16 16:55:58 - Error: .
 Solution: import math
def surface_Area(b, s):
    """
    Calculate the surface area of a square pyramid.

    Parameters:
    b (float or int): The length of the base edge of the pyramid.
    s (float or int): The height of the pyramid.

    Returns:
    float: The surface area of the pyramid.

    Raises:
    ValueError: If base edge or height is not positive.
    TypeError: If base edge or height is not a number.
    """
    if not isinstance(b, (int, float)) or not isinstance(s, (int, float)):
        raise TypeError('Base edge and height must be numbers.')
    if b <= 0 or s <= 0:
        raise ValueError('Base edge and height must be positive numbers.')
    base_area = b ** 2
    slant_height = math.sqrt((b / 2) ** 2 + s ** 2)
    lateral_area = 2 * b * slant_height
    total_surface_area = base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-16 16:56:07 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    """
    Count the number of indices where the two lists have the same values.

    Parameters:
    nums1 (list): The first list of values.
    nums2 (list): The second list of values.

    Returns:
    int: The count of indices where nums1 and nums2 have the same values.

    Raises:
    ValueError: If the lists are not of the same length.
    TypeError: If the inputs are not lists.
    """
    if not isinstance(nums1, list) or not isinstance(nums2, list):
        raise TypeError('Both inputs must be lists.')
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    count = 0
    for (a, b) in zip(nums1, nums2):
        if a == b:
            count += 1
    return count.
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-16 16:56:14 - Error: .
 Solution: import collections as ct
def merge_dictionaries_three(dict1, dict2, dict3):
    merged_dict = ct.ChainMap(dict3, dict2, dict1)
    return dict(merged_dict).
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-16 16:56:17 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n <= 0:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-16 16:56:20 - Error: unhashable type: 'list'.
 Solution: def Find_Min(lst):
    if not lst:
        return []
    unique_elements = set()
    for x in lst:
        if isinstance(x, list):
            unique_elements.add(tuple(x))
        else:
            unique_elements.add(x)
    required_count = len(unique_elements)
    left = 0
    min_length = float('inf')
    min_sublist = []
    current_count = {}
    for right in range(len(lst)):
        current_count[lst[right]] = current_count.get(lst[right], 0) + 1
        while len(current_count) == required_count:
            current_length = right - left + 1
            if current_length < min_length:
                min_length = current_length
                min_sublist = lst[left:right + 1]
            current_count[lst[left]] -= 1
            if current_count[lst[left]] == 0:
                del current_count[lst[left]]
            left += 1
    return min_sublist if min_sublist else [].
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-16 16:56:41 - Error: find_combinations() missing 1 required positional argument: 'target_sum'.
 Solution: from itertools import combinations
def find_combinations(tuples_list, target_sum):
    if not tuples_list or not target_sum:
        return []
    result = []
    target_length = len(target_sum)
    for r in range(1, len(tuples_list) + 1):
        for combo in combinations(tuples_list, r):
            if all((len(t) == target_length for t in combo)):
                combo_sum = tuple(map(sum, zip(*combo)))
                if combo_sum == target_sum:
                    result.append(combo)
    return result
tuples_list = [(1, 2), (3, 4), (5, 6)]
target_sum = (6, 6).
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-16 16:56:47 - Error: .
 Solution: def set_left_most_unset_bit(n):
    if n < 0:
        n = ~n
    mask = 1 << n.bit_length() - 1
    while mask > 0:
        if n & mask == 0:
            return n | mask
        mask >>= 1
    return n | 1 << n.bit_length().
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-16 16:56:47 - Error: .
 Solution: def count_bidirectional(test_list):
    if not test_list:
        return 0
    count = 0
    seen = set()
    for (a, b) in test_list:
        if (b, a) in seen:
            count += 1
        seen.add((a, b))
    return count
test_list = [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)].
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-16 16:56:51 - Error: .
 Solution: def get_coordinates(test_tup):
    if not isinstance(test_tup, tuple) or len(test_tup) != 2:
        raise ValueError('Input must be a tuple of two integers.')
    (x, y) = test_tup
    adjacent_coords = [(i, j) for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]
    adjacent_coords.remove((x, y))
    return adjacent_coords.
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-16 16:56:51 - Error: .
 Solution: from typing import List, Any, Tuple
def max_length(list1: List[List[Any]]) -> Tuple[int, List[List[Any]]]:
    if not list1:
        return (0, [])
    max_len = max((len(lst) for lst in list1))
    max_lists = [lst for lst in list1 if len(lst) == max_len]
    return (max_len, max_lists).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-16 16:56:53 - Error: .
 Solution: def is_num_decagonal(num):
    """
    Check if a number is a decagonal number.

    Parameters:
    num (int): The number to check.

    Returns:
    bool: True if num is a decagonal number, False otherwise.
    """
    if num < 1:
        return False
    n = (1 + (1 + 80 * num) ** 0.5) / 20
    return n.is_integer() and n > 0.
 Test: def check():
    assert is_num_decagonal(3) == 27
    assert is_num_decagonal(7) == 175
    assert is_num_decagonal(10) == 370

2025-10-16 16:56:58 - Error: .
 Solution: def upper_ctr(s):
    if not isinstance(s, str):
        raise ValueError('Input must be a string')
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-16 16:57:05 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    if m < 0 or n < 0 or m >= len(tuplex) or (n > len(tuplex)) or (m > n):
        return ()
    result = tuplex[m:n]
    if n < len(tuplex):
        result += (n,)
    return result.
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-16 16:57:07 - Error: .
 Solution: def get_Char(strr):
    """
    Calculate a character based on the sum of ASCII values of the input string modulo 26.
    
    Args:
        strr (str): Input string.
    
    Returns:
        str: A single lowercase character derived from the ASCII sum.
    """
    if not strr:
        return 'a'
    ascii_sum = sum((ord(char) for char in strr))
    resulting_char = chr(ascii_sum % 26 + ord('a'))
    return resulting_char.
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-16 16:57:32 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] * arr[i])
    max_product_value = max(dp)
    return max_product_value if max_product_value > 1 else 0.
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-16 16:57:40 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    return re.sub('\\(.*?\\)', '', items).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-16 16:58:04 - Error: .
 Solution: def get_ludic(n):
    """ Returns a list of all lucid numbers less than or equal to n. """
    if n < 0:
        return []
    lucid_numbers = []
    for i in range(1, n + 1):
        if i & i - 1 == 0:
            lucid_numbers.append(i)
    return sorted(lucid_numbers).
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-16 16:58:19 - Error: .
 Solution: def get_median(arr1, arr2, n):
    if n == 0:
        return None
    (i, j) = (0, 0)
    (median1, median2) = (0, 0)
    for count in range(n // 2 + 1):
        if i < n and (j >= n or arr1[i] < arr2[j]):
            median1 = median2
            median2 = arr1[i]
            i += 1
        else:
            median1 = median2
            median2 = arr2[j]
            j += 1
    return median2
arr1 = [1, 12, 15, 26, 38]
arr2 = [2, 13, 17, 30, 45]
n = len(arr1).
 Test: def check():
    assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0
    assert get_median([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5
    assert get_median([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0

2025-10-16 17:23:01 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 17:23:01 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 17:23:01 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:23:01 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:23:01 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 17:23:01 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:23:01 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:23:01 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 17:23:01 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 17:23:02 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 17:23:02 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:23:02 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:23:03 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:23:03 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 17:23:03 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 17:23:03 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:23:04 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 17:23:04 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 17:23:05 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 17:23:05 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:23:05 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:23:06 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 17:23:08 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:23:20 - Error: .
 Solution: def dif_Square(n):
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:23:20 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 17:23:22 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (i, char) in enumerate(str1) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:23:22 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:23:22 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 17:23:22 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a+b+$'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:23:23 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((x for x in arr if count[x] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:23:25 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:23:25 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    return round(2 * math.pi * r * (r + h), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:23:25 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:23:25 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:23:26 - Error: .
 Solution: def find_star_num(n):
    if n <= 0:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 17:23:27 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:23:35 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:23:37 - Error: .
 Solution: def eulerian_num(n, m):
    if n == 0 and m == 0:
        return 1
    if n == 0 or m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 17:24:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:24:27 - Error: .
 Solution: def is_divisible_by_11(n):
    return n % 11 == 0
def is_Diff(n):
    return not is_divisible_by_11(n).
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 17:24:30 - Error: .
 Solution: def Find_Max_Length(lst):
    max_length = 0
    current_length = 0
    for item in lst:
        if isinstance(item, list):
            current_length = 0
        else:
            current_length += 1
            max_length = max(max_length, current_length)
    return max_length.
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-16 17:24:39 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:24:41 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(tup) / len(tup) for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:24:43 - Error: .
 Solution: def test_three_equal(x, y, z):
    equal_count = 0
    if x == y:
        equal_count += 1
    if y == z:
        equal_count += 1
    if x == z:
        equal_count += 1
    if equal_count == 3:
        return 3
    elif equal_count == 2:
        return 2
    else:
        return 0.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 17:24:47 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum if total_sum > 0 else 0.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:24:50 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:24:51 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    if z == 0:
        return None
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:24:51 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:24:52 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    n = len(arr)
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:24:54 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:24:55 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    sum_harmonic = 0.0
    for i in range(1, n):
        sum_harmonic += 1 / i
    return sum_harmonic.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:26:09 - Error: tuple index out of range.
 Solution: def multiply_elements(test_tup):
    if len(test_tup) == 2:
        return (test_tup[0] * test_tup[1],)
    first_product = test_tup[0] * test_tup[1]
    rest_result = multiply_elements(test_tup[1:])
    return (first_product,) + rest_result.
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-16 17:26:10 - Error: .
 Solution: def max_subarray_product(arr):
    if not arr:
        return 0
    return max_product_helper(arr, 0, arr[0], arr[0])
def max_product_helper(arr, index, max_product, min_product):
    if index == len(arr):
        return max_product
    current_value = arr[index]
    if current_value < 0:
        (max_product, min_product) = (min_product, max_product)
    max_product = max(current_value, max_product * current_value)
    min_product = min(current_value, min_product * current_value)
    return max_product_helper(arr, index + 1, max_product, min_product)
arr = [2, 3, -2, 4].
 Test: def check():
    assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112
    assert max_subarray_product([6, -3, -10, 0, 2]) == 180
    assert max_subarray_product([-2, -40, 0, -2, -3]) == 80

2025-10-16 17:26:14 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    underscore_index = word.find('_')
    if underscore_index == -1:
        return word.lower()
    first_segment = word[:underscore_index]
    rest_of_string = word[underscore_index + 1:]
    if first_segment == word:
        camel_case_segment = first_segment.lower()
    else:
        camel_case_segment = first_segment.capitalize()
    return camel_case_segment + snake_to_camel(rest_of_string).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:26:19 - Error: .
 Solution: def remove_odd(str1, index=0):
    if index >= len(str1):
        return ''
    if index % 2 == 0:
        return str1[index] + remove_odd(str1, index + 1)
    else:
        return remove_odd(str1, index + 1).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:26:21 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:26:24 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number represented by its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle of the complex number in radians, or None if the angle is undefined.
    """
    z = complex(a, b)
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:26:28 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:26:33 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * h + 2 * math.pi * r ** 2, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:26:34 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 17:26:38 - Error: .
 Solution: def text_match_zero_one(text):

    def matches_pattern(text):
        if len(text) == 0:
            return False
        if text[0] == 'a':
            if len(text) > 1 and text[1] == 'b':
                return matches_pattern(text[1:])
            else:
                return False
        return False
    return matches_pattern(text).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:26:41 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return jacobsthal_num(n - 2) + 2 * jacobsthal_num(n - 1)
n = 5.
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 17:26:43 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 17:26:47 - Error: .
 Solution: def freq_count(list1):
    if not list1:
        return {}
    first_element = list1[0]
    count = list1.count(first_element)
    freq_dict = {first_element: count}
    remaining_list = list1[count:]
    remaining_freq = freq_count(remaining_list)
    freq_dict.update(remaining_freq)
    return freq_dict.
 Test: def check():
    assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})
    assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})
    assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})

2025-10-16 17:27:01 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    else:
        return harmonic_sum(n - 1) + 1 / n.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:27:17 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):

    def count_rotations_util(start, end):
        if start > end:
            return 0
        if start == end:
            return start
        if arr[start] <= arr[end]:
            return 0
        mid = (start + end) // 2
        if mid < end and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > start and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] > arr[end]:
            return count_rotations_util(mid + 1, end)
        else:
            return count_rotations_util(start, mid - 1)
    return count_rotations_util(0, len(arr) - 1)
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:27:47 - Error: Function find_Volume is not defined in the solution..
 Solution: def find_volume(l, b, h):
    """
    Calculate the volume of a single triangular prism.
    
    Parameters:
    l (float): Length of the prism
    b (float): Base of the triangular base
    h (float): Height of the triangular base
    
    Returns:
    float: Volume of the triangular prism
    """
    if l <= 0 or b <= 0 or h <= 0:
        return 0
    base_area = 0.5 * b * h
    volume = base_area * l
    return volume.
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-16 17:29:47 - Error: .
 Solution: def sum_series(n):
    if n < 2:
        return 0
    return n + sum_series(n - 2).
 Test: def check():
    assert sum_series(6) == 12
    assert sum_series(10) == 30
    assert sum_series(9) == 25

2025-10-16 17:29:47 - Error: .
 Solution: def find_Parity(x):
    if x == 0:
        return False
    elif x == 1:
        return True
    elif x < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif x % 2 == 0:
        return find_Parity(x - 2)
    else:
        return find_Parity(x - 1).
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-16 17:30:04 - Error: .
 Solution: def text_match_zero_one(s):

    def match_string(s):
        if not s:
            return False
        if s[0] == 'a':
            if len(s) > 1 and s[1] == 'b':
                return True if s[2:] == '' or match_string(s[1:]) else False
        return False
    return match_string(s).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:30:06 - Error: .
 Solution: def second_smallest(numbers):
    if len(numbers) < 2:
        return None

    def find_smallest_and_second_smallest(nums):
        if len(nums) == 2:
            return (min(nums), max(nums))
        (smallest, second_smallest) = find_smallest_and_second_smallest(nums[1:])
        if nums[0] < smallest:
            return (nums[0], smallest)
        elif nums[0] < second_smallest:
            return (smallest, nums[0])
        else:
            return (smallest, second_smallest)
    (smallest, second_smallest) = find_smallest_and_second_smallest(numbers)
    return second_smallest.
 Test: def check():
    assert second_smallest([1, 2, -8, -2, 0, -2])==-2
    assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5
    assert second_smallest([2,2])==None
    assert second_smallest([2,2,2])==None

2025-10-16 17:30:31 - Error: .
 Solution: def is_odd(char):
    return ord(char) % 2 != 0
def remove_odd(str1):
    if not str1:
        return ''
    first_character = str1[0]
    remaining_string = str1[1:]
    if not is_odd(first_character):
        return first_character + remove_odd(remaining_string)
    else:
        return remove_odd(remaining_string).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:30:35 - Error: .
 Solution: def string_to_tuple(str1):
    """Convert a string to a tuple of its characters using recursion."""
    if str1 == '':
        return ()
    return (str1[0],) + string_to_tuple(str1[1:]).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 17:30:40 - Error: .
 Solution: def start_withp(words):
    found = [word for word in words if word.lower().startswith('p')]
    return tuple(found[:2]).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 17:30:41 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 'Invalid input: radius and height must be non-negative.'
    if r == 0 or h == 0:
        return 0
    base_area = 2 * math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:30:45 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return 6 * n - 6 if n > 1 else 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 17:30:54 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(n):
        digits = [int(d) for d in str(n) if d != '0']
        return all((n % d == 0 for d in digits)) if digits else False
    if startnum > endnum:
        return []
    result = []
    for num in range(startnum, endnum + 1):
        if is_divisible_by_digits(num):
            result.append(num)
    return result
result = divisible_by_digits(1, 22).
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-16 17:30:55 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    if len(nums) == 1:
        return nums[0]
    mid = len(nums) // 2
    left_max = max_occurrences(nums[:mid])
    right_max = max_occurrences(nums[mid:])
    left_count = nums.count(left_max)
    right_count = nums.count(right_max)
    if left_count >= right_count:
        return left_max
    else:
        return right_max.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-16 17:30:59 - Error: Both a and b must be numbers..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number represented by its real part 'a' and imaginary part 'b'.
    
    Parameters:
    a (int, float): The real part of the complex number.
    b (int, float): The imaginary part of the complex number.
    
    Returns:
    float: The angle in radians, or None if the angle is undefined (for the complex number 0 + 0i).
    
    Raises:
    ValueError: If either 'a' or 'b' is not a number.
    """
    if a is None or b is None:
        raise ValueError('Both a and b must be provided and cannot be None.')
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numbers.')
    if a == 0 and b == 0:
        return None
    angle = cmath.phase(complex(a, b))
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:31:00 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:31:07 - Error: Input must be a list of hashable types..
 Solution: def extract_freq(test_list, k=2):
    if not isinstance(test_list, list) or any((not isinstance(x, (int, str, float)) for x in test_list)):
        raise ValueError('Input must be a list of hashable types.')
    if k < 0:
        return 0
    if len(test_list) == 0:
        return 0 if k > 0 else 1
    if k > len(test_list):
        return 0
    unique_tuples = set()

    def count_tuples(start, k, current_tuple):
        if k == 0:
            unique_tuples.add(tuple(current_tuple))
            return
        for i in range(start, len(test_list)):
            count_tuples(i + 1, k - 1, current_tuple + [test_list[i]])
    count_tuples(0, k, [])
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 17:31:13 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0

    def helper(n, divisor):
        if divisor > n:
            return 0
        if n % divisor == 0:
            return divisor + helper(n, divisor + 1)
        else:
            return helper(n, divisor + 1)
    return helper(number, 1).
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 17:31:15 - Error: Both inputs must be lists..
 Solution: def similar_elements(test_tup1, test_tup2):
    if not isinstance(test_tup1, list) or not isinstance(test_tup2, list):
        raise ValueError('Both inputs must be lists.')
    set_tup2 = set(test_tup2)
    if not test_tup1:
        return []
    first_element = test_tup1[0]
    rest_elements = test_tup1[1:]
    if first_element in set_tup2:
        return [first_element] + similar_elements(rest_elements, test_tup2)
    else:
        return similar_elements(rest_elements, test_tup2).
 Test: def check():
    assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))
    assert set(similar_elements((1, 2, 3, 4),(5, 4, 3, 7))) == set((3, 4))
    assert set(similar_elements((11, 12, 14, 13),(17, 15, 14, 13))) == set((13, 14))

2025-10-16 17:31:19 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    else:
        return harmonic_sum(n - 1) + 1 / n.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:31:20 - Error: .
 Solution: def is_divisible_by_11(n):
    n = abs(n)
    if n == 0:
        return True
    elif n < 10:
        return n == 0
    last_digit = n % 10
    remaining_number = n // 10
    if len(str(n)) % 2 == 0:
        return is_divisible_by_11(remaining_number - last_digit)
    else:
        return is_divisible_by_11(remaining_number + last_digit)
def is_Diff(n):
    return is_divisible_by_11(n).
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 17:31:29 - Error: .
 Solution: def eulerian_num(n, m, memo=None):
    if memo is None:
        memo = {}
    if (n, m) in memo:
        return memo[n, m]
    if n == 0 and m == 0:
        return 1
    if m > n or m < 0:
        return 0
    if n > 0 and m == 0:
        return 0
    if n > 0 and m == n:
        return 0
    result = (n - m) * eulerian_num(n - 1, m - 1, memo) + (m + 1) * eulerian_num(n - 1, m, memo)
    memo[n, m] = result
    return result.
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 17:31:46 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []

    def average(tup):
        if not tup:
            return None
        return sum(tup) / len(tup)
    return [average(tup) for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:32:08 - Error: find_Odd_Pair() takes 1 positional argument but 2 were given.
 Solution: def find_Odd_Pair(A):
    if not isinstance(A, list) or any((not isinstance(x, int) for x in A)):
        raise ValueError('Input must be a list of integers.')
    odd_count = 0
    even_count = 0
    for num in A:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return odd_count * even_count
A = [1, 2, 3, 4].
 Test: def check():
    assert find_Odd_Pair([5,4,7,2,1],5) == 6
    assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12
    assert find_Odd_Pair([1,2,3],3) == 2

2025-10-16 17:32:10 - Error: words must be a list of strings.
 Solution: def long_words(n, words):
    if not isinstance(n, int):
        raise ValueError('n must be an integer')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings')
    if n < 0:
        return words
    if not words:
        return []
    first_word = words[0]
    if len(first_word) > n:
        return [first_word] + long_words(n, words[1:])
    else:
        return long_words(n, words[1:])
n = 5.
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 17:32:30 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if not arr:
        return 0
    frequency = {}
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('List must contain only numeric elements.')
        frequency[num] = frequency.get(num, 0) + 1
    return sum((num for num in frequency if frequency[num] == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:32:38 - Error: .
 Solution: def count_rotation(arr):

    def binary_search_rotations(low, high):
        if low > high:
            return 0
        if arr[low] <= arr[high]:
            return 0
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            return binary_search_rotations(mid + 1, high)
        else:
            return binary_search_rotations(low, mid - 1)
    return binary_search_rotations(0, len(arr) - 1)
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:33:15 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise TypeError('Both inputs must be lists.')
    return [item for item in li1 if item not in li2].
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:34:29 - Error: .
 Solution: def swap_List(newList):
    if len(newList) == 0:
        return newList
    elif len(newList) == 1:
        return newList
    elif len(newList) == 2:
        return [newList[1], newList[0]]
    first = newList[0]
    last = newList[-1]
    middle = newList[1:-1]
    return [last] + swap_List(middle) + [first].
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-16 17:34:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the base of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return round(2 * math.pi * r * (r + h), 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:34:44 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:34:44 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:34:45 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:34:46 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0:
        return True
    if n % 4 == 2:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:34:51 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:34:56 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:35:00 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(None)
        else:
            avg = sum(tup) / len(tup)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:35:10 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    else:
        return harmonic_sum(n - 1) + 1 / n.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:35:20 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    if '_' not in word:
        return word.lower()
    (first_segment, rest_of_string) = word.split('_', 1)
    return first_segment.lower() + rest_of_string[0].upper() + snake_to_camel(rest_of_string[1:]).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:35:26 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:36:22 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:36:22 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:36:24 - Error: .
 Solution: def start_withp(words):
    if not isinstance(words, list):
        raise ValueError('Input must be a list.')
    if any((not isinstance(word, str) for word in words)):
        raise ValueError('All elements in the list must be strings.')
    result = []
    for word in words:
        for w in word.split():
            if w.startswith('p'):
                result.append(w)
                if len(result) == 2:
                    return tuple(result)
    return tuple(result).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 17:36:24 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 17:36:26 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    if not isinstance(test_tup, tuple):
        raise ValueError('Input must be a tuple.')
    if not isinstance(to_remove, (tuple, list)):
        raise ValueError('Tuples to remove must be provided as a tuple or list.')
    remove_set = set(to_remove)
    result = tuple((item for item in test_tup if item not in remove_set))
    return result.
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 17:36:31 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for inner_tuple in nums:
        if not isinstance(inner_tuple, tuple):
            raise ValueError('Each element must be a tuple.')
        if len(inner_tuple) == 0:
            averages.append(0)
        else:
            avg = sum(inner_tuple) / len(inner_tuple)
            averages.append(round(avg, 2))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:36:32 - Error: Both inputs must be integers or floats..
 Solution: import cmath
def angle_complex(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both inputs must be integers or floats.')
    complex_number = complex(a, b)
    if complex_number == 0:
        raise ValueError('The angle is undefined for the complex number 0 + 0j.')
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:36:32 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    count = {}
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('All elements in the list must be integers or floats.')
        count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:36:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:36:37 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0, 1]
        for i in range(2, n + 1):
            next_value = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
            jacobsthal.append(next_value)
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-16 17:36:37 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:36:43 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:36:48 - Error: .
 Solution: def round_and_sum(list1):
    if not list1:
        print(0)
        return
    total_sum = sum((round(number) for number in list1))
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 17:36:57 - Error: .
 Solution: def eulerian_num(n, m):
    if not isinstance(n, int) or not isinstance(m, int):
        raise ValueError('Both n and m must be integers.')
    if n < 0 or m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            else:
                A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 17:38:55 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:39:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 17:39:36 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:39:37 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    segments = word.split('_')
    camel_case = segments[0] + ''.join((segment.capitalize() for segment in segments[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:40:00 - Error: Both inputs must be numeric..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number defined by its real and imaginary parts.

    Parameters:
    a (float or int): The real part of the complex number.
    b (float or int): The imaginary part of the complex number.

    Returns:
    float: The angle of the complex number in radians.
    
    Raises:
    ValueError: If inputs are not numeric.
    """
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise ValueError('Both inputs must be numeric.')
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:40:08 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:40:11 - Error: .
 Solution: def Diff(li1, li2):
    if not isinstance(li1, list) or not isinstance(li2, list):
        raise ValueError('Both inputs must be lists.')
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:40:32 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if len(t) == 0:
            averages.append(None)
        else:
            averages.append(sum(t) / len(t))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:40:35 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified tuples from the given tuple, including nested tuples.

    Parameters:
    test_tup (tuple): The original tuple from which to remove elements.
    to_remove (tuple): The tuple of elements to be removed.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    if not isinstance(test_tup, tuple) or not isinstance(to_remove, tuple):
        raise ValueError('Both test_tup and to_remove must be tuples.')

    def recursive_remove(tup):
        result = []
        for item in tup:
            if isinstance(item, tuple):
                if item not in to_remove:
                    result.append(recursive_remove(item))
            else:
                result.append(item)
        return tuple(result)
    return recursive_remove(test_tup)
test_tup = ((1, 2), (3, 4), (1, 2))
to_remove = ((1, 2),).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 17:40:39 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    if not arr:
        return 0
    count = {}
    for num in arr:
        if not isinstance(num, (int, float)):
            raise ValueError('All elements in the list must be integers or floats.')
        count[num] = count.get(num, 0) + 1
    return sum((num for (num, cnt) in count.items() if cnt == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:40:40 - Error: words must be a list of strings..
 Solution: def long_words(n, words):
    """
    Returns a list of words longer than n characters from the given list of words.

    Parameters:
    n (int): The minimum length of words to include in the result.
    words (list): A list of strings to be filtered.

    Returns:
    list: A list of words longer than n characters.
    """
    if not isinstance(n, int) or n < 0:
        raise ValueError('n must be a non-negative integer.')
    if not isinstance(words, list) or not all((isinstance(word, str) for word in words)):
        raise ValueError('words must be a list of strings.')
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 17:40:41 - Error: .
 Solution: def harmonic_sum(n):
    """
    Calculate the harmonic sum of n-1.
    
    The harmonic sum H(n-1) is defined as:
    H(n-1) = 1 + 1/2 + 1/3 + ... + 1/(n-1)
    
    Parameters:
    n (int): The upper limit for the harmonic sum calculation.
    
    Returns:
    float: The harmonic sum of n-1, or 0.0 if n <= 1.
    """
    if not isinstance(n, int):
        raise TypeError('Input must be an integer.')
    if n <= 1:
        return 0.0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:40:42 - Error: .
 Solution: def start_withp(words):
    if isinstance(words, str):
        words = words.split()
    elif not isinstance(words, list):
        return ('', '')
    result = [word for word in words if isinstance(word, str) and word.lower().startswith('p')]
    return tuple(result[:2]) if len(result) >= 2 else ('', '').
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 17:40:48 - Error: .
 Solution: import math
def area_of_circle(r):
    return math.pi * r * r
def surfacearea_cylinder(r, h):
    if r <= 0 or h <= 0:
        raise ValueError('Radius and height must be positive values.')
    base_area = area_of_circle(r)
    total_base_area = 2 * base_area
    lateral_area = 2 * math.pi * r * h
    return round(total_base_area + lateral_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:41:05 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[-1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] <= arr[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:42:48 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    first_char = word[0]
    if first_char == '_':
        if len(word) > 1:
            return snake_to_camel(word[1:]).capitalize()
        else:
            return snake_to_camel(word[1:])
    return first_char + snake_to_camel(word[1:]).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:43:05 - Error: .
 Solution: def text_match_zero_one(s):
    return match_string(s)
def match_string(s):
    if not s:
        return False
    if s[0] == 'a':
        return match_b(s[1:])
    return False
def match_b(s):
    if not s:
        return False
    if s[0] == 'b':
        return True if len(s) == 1 else match_b(s[1:])
    return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 17:43:47 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:44:41 - Error: .
 Solution: def remove_odd(str1, index=0):
    if index >= len(str1):
        return ''
    if index % 2 == 0:
        return str1[index] + remove_odd(str1, index + 1)
    else:
        return remove_odd(str1, index + 1).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:45:26 - Error: .
 Solution: def harmonic_sum(n):
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0:
        return 0
    total = 0
    for i in range(1, n):
        total += 1 / i
    return total.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:45:47 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        return 'Invalid input: radius and height must be non-negative.'
    base_area = math.pi * r ** 2
    lateral_area = 2 * math.pi * r * h
    total_area = 2 * base_area + lateral_area
    return round(total_area, 2)
r = 10
h = 5.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:45:49 - Error: extract_freq() missing 1 required positional argument: 'tuple_length'.
 Solution: def extract_freq(test_list, tuple_length):
    if tuple_length <= 0 or tuple_length > len(test_list):
        return 0
    unique_tuples = set()

    def backtrack(start, current_tuple):
        if len(current_tuple) == tuple_length:
            unique_tuples.add(tuple(current_tuple))
            return
        for i in range(start, len(test_list)):
            current_tuple.append(test_list[i])
            backtrack(i + 1, current_tuple)
            current_tuple.pop()
    backtrack(0, [])
    return len(unique_tuples)
test_list = [1, 2, 2, 3]
tuple_length = 2.
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 17:46:03 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) ^ set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 17:46:12 - Error: .
 Solution: def start_withp(words):
    found = []
    for word in words:
        for w in word.split():
            if w.startswith('p') and len(found) < 2:
                found.append(w)
            if len(found) == 2:
                return tuple(found)
    return tuple(found).
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 17:46:15 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):

    def binary_search_rotations(low, high):
        if low > high:
            return 0
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            return binary_search_rotations(mid + 1, high)
        else:
            return binary_search_rotations(low, mid - 1)
    n = len(arr)
    if n == 0:
        return 0
    return binary_search_rotations(0, n - 1)
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:46:17 - Error: .
 Solution: def eulerian_num(n, m):
    if n < 0 or m < 0:
        return 0
    if n == 0 and m == 0:
        return 1
    if n > 0 and m == 0:
        return 0
    if m > n:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 1
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 17:46:18 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    z = complex(a, b)
    if z == 0:
        raise ValueError('Angle is undefined for the complex number 0 + 0i')
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:46:26 - Error: can only concatenate list (not "int") to list.
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    max_length = 0
    current_length = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1] + 1:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    return max(max_length, current_length).
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-16 17:46:40 - Error: .
 Solution: def max_subarray_product(arr):
    if not arr:
        return 0

    def helper(index, current_max, current_min):
        if index == len(arr):
            return current_max
        temp_max = max(arr[index], current_max * arr[index], current_min * arr[index])
        temp_min = min(arr[index], current_max * arr[index], current_min * arr[index])
        return helper(index + 1, temp_max, temp_min)
    return helper(1, arr[0], arr[0])
arr = [2, 3, -2, 4].
 Test: def check():
    assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112
    assert max_subarray_product([6, -3, -10, 0, 2]) == 180
    assert max_subarray_product([-2, -40, 0, -2, -3]) == 80

2025-10-16 17:46:47 - Error: Function find_Volume is not defined in the solution..
 Solution: def triangle_area(l, b):
    if l == 0 or b == 0:
        return 0
    return 0.5 * l * b
def find_volume(l, b, h):
    if l < 0 or b < 0 or h < 0:
        raise ValueError('Dimensions must be non-negative.')
    area = triangle_area(l, b)
    volume = area * h
    return volume
length_of_base = 5
height_of_triangle = 3
height_of_prism = 10
volume = find_volume(length_of_base, height_of_triangle, height_of_prism).
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-16 17:47:07 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:47:22 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:47:29 - Error: .
 Solution: def find_sum(arr):
    return sum((num for num in arr if arr.count(num) == 1))
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:47:53 - Error: name 'random' is not defined.
 Solution: def kth_element(arr, k):
    if len(arr) == 0:
        raise ValueError('Array is empty')
    if k < 1 or k > len(arr):
        raise ValueError('k is out of bounds')

    def quickselect(left, right, k_index):
        if left == right:
            return arr[left]
        pivot_index = random.randint(left, right)
        pivot_value = arr[pivot_index]
        (arr[pivot_index], arr[right]) = (arr[right], arr[pivot_index])
        store_index = left
        for i in range(left, right):
            if arr[i] < pivot_value:
                (arr[store_index], arr[i]) = (arr[i], arr[store_index])
                store_index += 1
        (arr[right], arr[store_index]) = (arr[store_index], arr[right])
        if k_index == store_index:
            return arr[k_index]
        elif k_index < store_index:
            return quickselect(left, store_index - 1, k_index)
        else:
            return quickselect(store_index + 1, right, k_index)
    return quickselect(0, len(arr) - 1, k - 1)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 17:51:19 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    if count == 3:
        return 3
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 17:51:19 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    if '_' not in word:
        return word.capitalize()
    (first_segment, rest_of_string) = word.split('_', 1)
    return first_segment + snake_to_camel(rest_of_string).capitalize().
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 17:53:01 - Error: .
 Solution: def dif_Square(n):
    if n % 2 == 0 or n % 4 != 2:
        return True
    return False.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 17:53:02 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 17:54:31 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 17:54:34 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder (must be non-negative).
    h (float): The height of the cylinder (must be non-negative).

    Returns:
    float: The surface area of the cylinder. Returns 0.0 if both radius and height are zero.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    return 2 * math.pi * r * (r + h).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 17:54:41 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    sum_harmonic = 0.0
    for i in range(1, n):
        sum_harmonic += 1 / i
    return sum_harmonic.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 17:55:26 - Error: .
 Solution: def find_sum(arr):
    if not isinstance(arr, list):
        raise ValueError('Input must be a list.')
    count = {}
    for num in arr:
        if isinstance(num, (int, float)):
            count[num] = count.get(num, 0) + 1
    total_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return total_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 17:55:32 - Error: .
 Solution: def average_tuple(nums):
    if not isinstance(nums, tuple) or not all((isinstance(t, tuple) for t in nums)):
        raise ValueError('Input must be a tuple of tuples.')
    averages = []
    for t in nums:
        if not t:
            averages.append(0)
        else:
            numeric_values = [x for x in t if isinstance(x, (int, float))]
            averages.append(sum(numeric_values) / len(numeric_values) if numeric_values else 0)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 17:55:40 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Returns the angle (in radians) of the complex number formed by a and b.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle in radians, or None if the complex number is 0.
    """
    z = complex(a, b)
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 17:55:47 - Error: remove_nested() missing 1 required positional argument: 'to_remove'.
 Solution: def remove_nested(test_tup, to_remove):
    """
    Remove specified tuples from the given tuple.

    Parameters:
    test_tup (tuple): The input tuple from which to remove elements.
    to_remove (tuple): The tuple of elements to remove.

    Returns:
    tuple: A new tuple with the specified elements removed.
    """
    if not isinstance(test_tup, tuple) or not isinstance(to_remove, tuple):
        raise ValueError('Both test_tup and to_remove must be tuples.')
    to_remove_set = set(to_remove)

    def filter_tuples(tup):
        result = []
        for item in tup:
            if isinstance(item, tuple):
                filtered_item = filter_tuples(item)
                if filtered_item:
                    result.append(filtered_item)
            elif item not in to_remove_set:
                result.append(item)
        return tuple(result)
    return filter_tuples(test_tup)
test_tup = ((1, 2), (3, 4), 2, (5, 6))
to_remove = ((3, 4), 2)
result = remove_nested(test_tup, to_remove).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 17:55:51 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 17:57:54 - Error: .
 Solution: def next_power_of_2(n):
    if n <= 1:
        return 1
    smaller_power = next_power_of_2(n // 2)
    if smaller_power < n:
        return smaller_power * 2
    else:
        return smaller_power.
 Test: def check():
    assert next_power_of_2(0) == 1
    assert next_power_of_2(5) == 8
    assert next_power_of_2(17) == 32

2025-10-16 17:58:20 - Error: .
 Solution: def common_element(list1, list2):
    if not list1 or not list2:
        return False
    if list1[0] in list2:
        return True
    return common_element(list1[1:], list2).
 Test: def check():
    assert common_element([1,2,3,4,5], [5,6,7,8,9])==True
    assert common_element([1,2,3,4,5], [6,7,8,9])==None
    assert common_element(['a','b','c'], ['d','b','e'])==True

2025-10-16 17:59:51 - Error: .
 Solution: import sys
def tuple_size(tuple_list):
    if not isinstance(tuple_list, tuple):
        raise ValueError('Input must be a tuple')
    total_size = sys.getsizeof(tuple_list)
    for item in tuple_list:
        total_size += sys.getsizeof(item)
    return total_size.
 Test: def check():
    assert tuple_size(("A", 1, "B", 2, "C", 3) ) == sys.getsizeof(("A", 1, "B", 2, "C", 3))
    assert tuple_size((1, "Raju", 2, "Nikhil", 3, "Deepanshu") ) == sys.getsizeof((1, "Raju", 2, "Nikhil", 3, "Deepanshu"))
    assert tuple_size(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf"))  ) == sys.getsizeof(((1, "Lion"), ( 2, "Tiger"), (3, "Fox"), (4, "Wolf")))

2025-10-16 18:00:18 - Error: Function is_num_decagonal is not defined in the solution..
 Solution: def decagonal_number(n):
    if n < 1:
        return 0
    return n * (4 * n - 3).
 Test: def check():
    assert is_num_decagonal(3) == 27
    assert is_num_decagonal(7) == 175
    assert is_num_decagonal(10) == 370

2025-10-16 18:00:29 - Error: .
 Solution: def geometric_sum(n):
    if n < 0:
        raise ValueError('n must be a non-negative integer')
    if n == 0:
        return 0
    return geometric_sum(n - 1) + 1 / 2 ** n
n = 7.
 Test: def check():
    assert geometric_sum(7) == 1.9921875
    assert geometric_sum(4) == 1.9375
    assert geometric_sum(8) == 1.99609375

2025-10-16 18:01:20 - Error: .
 Solution: def is_samepatterns(colors, patterns):
    if len(colors) < len(patterns):
        return False
    color_to_pattern = {}
    for (color, pattern) in zip(colors, patterns):
        if color in color_to_pattern:
            if color_to_pattern[color] != pattern:
                return False
        else:
            color_to_pattern[color] = pattern
    return True
colors = ['a', 'b', 'a', 'c']
patterns = ['x', 'y', 'x', 'z'].
 Test: def check():
    assert is_samepatterns(["red","green","green"], ["a", "b", "b"])==True
    assert is_samepatterns(["red","green","greenn"], ["a","b","b"])==False
    assert is_samepatterns(["red","green","greenn"], ["a","b"])==False

2025-10-16 18:02:09 - Error: .
 Solution: def find_Element(arr, ranges, rotations, index):
    if not arr or index < 0 or index >= len(arr):
        return None
    combined_arr = []
    for r in ranges:
        combined_arr.extend(arr[r[0]:r[1] + 1])
    n = len(combined_arr)
    if n == 0:
        return None
    rotations = rotations % n
    effective_index = (index + rotations) % n
    return combined_arr[effective_index]
arr = [1, 2, 3, 4, 5]
ranges = [[0, 2], [0, 3]]
rotations = 2
index = 1.
 Test: def check():
    assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3
    assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3
    assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1

2025-10-16 18:02:42 - Error: .
 Solution: def max_sum_increasing_subseq(a, n, i, k):
    if i < 0 or k <= i:
        return 0
    max_sum = 0
    for j in range(i + 1):
        if a[j] < a[k]:
            current_sum = a[j] + max_sum_increasing_subseq(a, n, j - 1, k)
            max_sum = max(max_sum, current_sum)
    return max_sum + a[k]
a = [1, 101, 2, 3, 100, 4, 5]
n = len(a)
i = 4
k = 6.
 Test: def check():
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11
    assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7
    assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71

2025-10-16 18:03:13 - Error: .
 Solution: def min_Swaps(str1, str2):
    if len(str1) != len(str2):
        return -1
    count1 = str1.count('1')
    count2 = str2.count('1')
    if count1 != count2:
        return -1
    mismatches = 0
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            mismatches += 1
    return mismatches // 2
str1 = '1100'
str2 = '1010'.
 Test: def check():
    assert min_Swaps("1101","1110") == 1
    assert min_Swaps("111","000") == "Not Possible"
    assert min_Swaps("111","110") == "Not Possible"

2025-10-16 18:03:20 - Error: unhashable type: 'list'.
 Solution: def Find_Min(lst):
    if not lst:
        return []
    unique_elements = set()
    for x in lst:
        if isinstance(x, list):
            unique_elements.add(tuple(x))
        else:
            unique_elements.add(x)
    required_count = len(unique_elements)
    left = 0
    min_length = float('inf')
    min_sublist = []
    current_count = {}
    for right in range(len(lst)):
        current_count[lst[right]] = current_count.get(lst[right], 0) + 1
        while len(current_count) == required_count:
            if right - left + 1 < min_length:
                min_length = right - left + 1
                min_sublist = lst[left:right + 1]
            current_count[lst[left]] -= 1
            if current_count[lst[left]] == 0:
                del current_count[lst[left]]
            left += 1
    return min_sublist if min_length != float('inf') else [].
 Test: def check():
    assert Find_Min([[1],[1,2],[1,2,3]]) == [1]
    assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]
    assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']

2025-10-16 18:03:45 - Error: .
 Solution: from array import array
def positive_count(nums):
    if not nums:
        return 0
    positive_count = sum((1 for num in nums if num > 0))
    total_count = len(nums)
    return positive_count / total_count
nums = array('i', [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]).
 Test: def check():
    assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54
    assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69
    assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56

2025-10-16 18:04:19 - Error: .
 Solution: def parabola_directrix(a, b, c):
    if a == 0:
        raise ValueError("Coefficient 'a' cannot be zero for a parabola.")
    vertex_y = (4 * a * c - b ** 2) / (4 * a)
    directrix = vertex_y - 1 / (4 * a)
    return directrix.
 Test: def check():
    assert parabola_directrix(5,3,2)==-198
    assert parabola_directrix(9,8,4)==-2336
    assert parabola_directrix(2,4,6)==-130

2025-10-16 18:04:22 - Error: .
 Solution: def merge(lst):
    first_elements = []
    second_elements = []
    for sublist in lst:
        if len(sublist) == 2:
            first_elements.append(sublist[0])
            second_elements.append(sublist[1])
    return [first_elements, second_elements].
 Test: def check():
    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]
    assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]
    assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]

2025-10-16 18:04:24 - Error: .
 Solution: def tuple_intersection(test_list1, test_list2):
    set1 = {elem for tup in test_list1 for elem in tup}
    set2 = {elem for tup in test_list2 for elem in tup}
    intersection = set1.intersection(set2)
    return tuple(sorted(intersection))
test_list1 = [(3, 4), (5, 6), (9, 10), (4, 5)]
test_list2 = [(5, 4), (3, 4), (6, 5), (9, 11)].
 Test: def check():
    assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}
    assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}
    assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}

2025-10-16 18:04:28 - Error: .
 Solution: def merge_sorted_list(num1, num2, num3):
    merged_list = []
    (i, j, k) = (0, 0, 0)
    while i < len(num1) or j < len(num2) or k < len(num3):
        val1 = num1[i] if i < len(num1) else float('inf')
        val2 = num2[j] if j < len(num2) else float('inf')
        val3 = num3[k] if k < len(num3) else float('inf')
        if val1 <= val2 and val1 <= val3:
            merged_list.append(val1)
            i += 1
        elif val2 <= val1 and val2 <= val3:
            merged_list.append(val2)
            j += 1
        else:
            merged_list.append(val3)
            k += 1
    return merged_list
num1 = [25, 24, 15, 4, 5, 29, 110]
num2 = [19, 20, 11, 56, 25, 233, 154]
num3 = [24, 26, 54, 48].
 Test: def check():
    assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]
    assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]
    assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]

2025-10-16 18:04:29 - Error: .
 Solution: import math
def sum_of_divisors(n):
    if n < 1:
        return 0
    total = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
    return total
def are_equivalent(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2).
 Test: def check():
    assert are_equivalent(36, 57) == False
    assert are_equivalent(2, 4) == False
    assert are_equivalent(23, 47) == True

2025-10-16 18:04:30 - Error: .
 Solution: def count_bidirectional(test_list):
    pair_set = set()
    for (a, b) in test_list:
        if a != b:
            pair_set.add((min(a, b), max(a, b)))
    return len(pair_set)
test_list = [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)].
 Test: def check():
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3
    assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2
    assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4

2025-10-16 18:04:46 - Error: .
 Solution: def combinations_colors(l, n):
    if n == 0:
        return [()]
    result = []
    for x in l:
        for combination in combinations_colors(l, n - 1):
            result.append((x,) + combination)
    return result
n = 2.
 Test: def check():
    assert combinations_colors( ["Red","Green","Blue"],1)==[('Red',), ('Green',), ('Blue',)]
    assert combinations_colors( ["Red","Green","Blue"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]
    assert combinations_colors( ["Red","Green","Blue"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]

2025-10-16 18:05:17 - Error: .
 Solution: def get_ludic(n):
    if n < 1:
        return []
    lucid_numbers = []
    for i in range(1, n + 1):
        if is_lucid(i):
            lucid_numbers.append(i)
    return lucid_numbers
def is_lucid(num):
    if num == 1:
        return True
    if num < 1:
        return False
    return can_sum_to_lucid(num, sieve_of_eratosthenes(num))
def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    p = 2
    while p * p <= limit:
        if is_prime[p]:
            for i in range(p * p, limit + 1, p):
                is_prime[i] = False
        p += 1
    return [p for p in range(2, limit + 1) if is_prime[p]]
def can_sum_to_lucid(target, primes):
    dp = [False] * (target + 1)
    dp[0] = True
    for prime in primes:
        for j in range(target, prime - 1, -1):
            dp[j] = dp[j] or dp[j - prime]
    return dp[target]
def is_lucid(num):
    if num == 1:
        return True
    if num < 1:
        return False
    return can_sum_to_lucid(num, sieve_of_eratosthenes(num))
def get_ludic(n):
    if n < 1:
        return []
    lucid_numbers = []
    for i in range(1, n + 1):
        if is_lucid(i):
            lucid_numbers.append(i)
    return lucid_numbers.
 Test: def check():
    assert get_ludic(10) == [1, 2, 3, 5, 7]
    assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]
    assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]

2025-10-16 18:06:15 - Error: .
 Solution: def set_left_most_unset_bit(n):
    if n == 0:
        return 1
    highest_bit = 1
    while highest_bit <= n:
        highest_bit <<= 1
    return n | highest_bit >> 1 | highest_bit >> 2.
 Test: def check():
    assert set_left_most_unset_bit(10) == 14
    assert set_left_most_unset_bit(12) == 14
    assert set_left_most_unset_bit(15) == 15

2025-10-16 18:06:41 - Error: .
 Solution: def is_Sum_Of_Powers_Of_Two(n):
    if n == 0:
        return True
    if n < 0:
        return False
    power = 1
    while power <= n:
        power *= 2
    power //= 2
    return is_Sum_Of_Powers_Of_Two(n - power) or is_Sum_Of_Powers_Of_Two(n).
 Test: def check():
    assert is_Sum_Of_Powers_Of_Two(10) == True
    assert is_Sum_Of_Powers_Of_Two(7) == False
    assert is_Sum_Of_Powers_Of_Two(14) == True

2025-10-16 18:06:56 - Error: .
 Solution: import collections as ct
def merge_two_dicts(dict1, dict2):
    """Merge two dictionaries."""
    merged = dict1.copy()
    for (key, value) in dict2.items():
        if key in merged:
            merged[key] = value
        else:
            merged[key] = value
    return merged
def merge_dictionaries_three(dict1, dict2, dict3):
    """Merge three dictionaries recursively."""
    if not dict1:
        return merge_two_dicts(dict2, dict3)
    if not dict2:
        return merge_two_dicts(dict1, dict3)
    if not dict3:
        return merge_two_dicts(dict1, dict2)
    merged_first_two = merge_two_dicts(dict1, dict2)
    final_merged = merge_two_dicts(merged_first_two, dict3)
    return final_merged
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
dict3 = {'d': 5}.
 Test: def check():
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{ "O": "Orange", "W": "White", "B": "Black" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" }, { "G": "Green", "W": "White" },{"L":"lavender","B":"Blue"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}
    assert merge_dictionaries_three({ "R": "Red", "B": "Black", "P": "Pink" },{"L":"lavender","B":"Blue"},{ "G": "Green", "W": "White" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}

2025-10-16 18:07:07 - Error: .
 Solution: import heapq
def min_k(test_list, K):
    return heapq.nsmallest(K, test_list)
test_list = [(1, 'a'), (3, 'b'), (2, 'c'), (5, 'd'), (4, 'e')]
K = 3.
 Test: def check():
    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]
    assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]
    assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]

2025-10-16 18:07:28 - Error: .
 Solution: import cmath
def convert(numbers):
    if isinstance(numbers, complex):
        numbers = [numbers]
    elif not isinstance(numbers, (list, tuple)):
        return []
    polar_coordinates = []
    for num in numbers:
        if isinstance(num, complex):
            polar_coordinates.append(cmath.polar(num))
        else:
            polar_coordinates.append(None)
    return polar_coordinates.
 Test: def check():
    assert convert(1) == (1.0, 0.0)
    assert convert(4) == (4.0,0.0)
    assert convert(5) == (5.0,0.0)

2025-10-16 18:07:34 - Error: .
 Solution: def dict_depth(d):
    if not isinstance(d, dict) or not d:
        return 0
    return 1 + max((dict_depth(value) for value in d.values()), default=0).
 Test: def check():
    assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4
    assert dict_depth({'a':1, 'b': {'c':'python'}})==2
    assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3

2025-10-16 18:08:02 - Error: .
 Solution: def max_length(list1):
    if not list1:
        return (0, [])
    max_len = 0
    max_lists = []
    for lst in list1:
        current_len = len(lst)
        if current_len > max_len:
            max_len = current_len
            max_lists = [lst]
        elif current_len == max_len:
            max_lists.append(lst)
    return (max_len, max_lists).
 Test: def check():
    assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])
    assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])
    assert max_length([[5], [15,20,25]])==(3, [15,20,25])

2025-10-16 18:09:15 - Error: .
 Solution: def upper_ctr(s):
    return sum((1 for char in s if char.isupper())).
 Test: def check():
    assert upper_ctr('PYthon') == 1
    assert upper_ctr('BigData') == 1
    assert upper_ctr('program') == 0

2025-10-16 18:09:22 - Error: .
 Solution: def get_coordinates(test_tup):
    (x, y) = test_tup
    adjacent_coords = []
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            if dx != 0 or dy != 0:
                adjacent_coords.append([x + dx, y + dy])
    return sorted(adjacent_coords).
 Test: def check():
    assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]
    assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]
    assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]

2025-10-16 18:09:22 - Error: .
 Solution: import math
def polar_rect(r, theta):
    if r < 0:
        raise ValueError('Radius must be non-negative.')
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return ((x, y), complex(x, y)).
 Test: def check():
    assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))
    assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))
    assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))

2025-10-16 18:09:26 - Error: Input must be a string.
 Solution: import re
def remove_parenthesis(items):
    if not isinstance(items, str):
        raise ValueError('Input must be a string')
    return re.sub('\\(.*?\\)', '', items).strip().
 Test: def check():
    assert remove_parenthesis(["python (chrome)"])==("python")
    assert remove_parenthesis(["string(.abc)"])==("string")
    assert remove_parenthesis(["alpha(num)"])==("alpha")

2025-10-16 18:09:48 - Error: .
 Solution: def max_Product(arr):
    if len(arr) < 2:
        raise ValueError('Array must contain at least two elements.')
    max1 = max(arr[0], arr[1])
    max2 = min(arr[0], arr[1])
    for num in arr[2:]:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return (max2, max1)
arr = [1, 2, 3, 4, 7, 0, 8, 4].
 Test: def check():
    assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)
    assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)
    assert max_Product([1,2,3]) == (2,3)

2025-10-16 18:09:52 - Error: .
 Solution: import math
def surface_Area(b, h):
    if b <= 0 or h < 0:
        raise ValueError('Base edge must be positive and height must be non-negative.')
    base_area = b ** 2
    slant_height = math.sqrt((b / 2) ** 2 + h ** 2)
    lateral_area = 2 * b * slant_height
    total_surface_area = base_area + lateral_area
    return total_surface_area.
 Test: def check():
    assert surface_Area(3,4) == 33
    assert surface_Area(4,5) == 56
    assert surface_Area(1,2) == 5

2025-10-16 18:09:54 - Error: Both lists must be of the same length..
 Solution: def count_same_pair(nums1, nums2):
    if len(nums1) != len(nums2):
        raise ValueError('Both lists must be of the same length.')
    count = 0
    for i in range(len(nums1)):
        if nums1[i] == nums2[i]:
            count += 1
    return count.
 Test: def check():
    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4
    assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11
    assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1
    assert count_same_pair([0, 1, 1, 2],[0, 1, 2, 2])==3

2025-10-16 18:10:32 - Error: .
 Solution: def max_product(arr):
    if not arr:
        return 0
    n = len(arr)
    dp = [1] * n
    for i in range(n):
        dp[i] = arr[i]
    for i in range(1, n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] * arr[i])
    return max(dp)
arr = [3, 100, 4, 5, 150, 6].
 Test: def check():
    assert max_product([3, 100, 4, 5, 150, 6]) == 3000
    assert max_product([4, 42, 55, 68, 80]) == 50265600
    assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460

2025-10-16 18:10:35 - Error: count_Pairs() takes 1 positional argument but 2 were given.
 Solution: def count_Pairs(arr):
    n = len(arr)
    if n < 2:
        return 0
    unique_elements = set(arr)
    num_unique = len(unique_elements)
    if num_unique < 2:
        return 0
    return num_unique * (num_unique - 1) // 2
arr = [1, 2, 3, 1, 2].
 Test: def check():
    assert count_Pairs([1,2,1],3) == 2
    assert count_Pairs([1,1,1,1],4) == 0
    assert count_Pairs([1,2,3,4,5],5) == 10

2025-10-16 18:11:21 - Error: .
 Solution: import re
def occurance_substring(text, pattern):
    if not text or not pattern:
        return None
    matches = [(match.group(0), match.start(), match.end()) for match in re.finditer(re.escape(pattern), text)]
    if not matches:
        return None
    return matches if len(matches) > 1 else matches[0].
 Test: def check():
    assert occurance_substring('python programming, python language','python')==('python', 0, 6)
    assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)
    assert occurance_substring('python programming,programming language','language')==('language', 31, 39)
    assert occurance_substring('c++ programming, c++ language','python')==None

2025-10-16 18:11:35 - Error: .
 Solution: def get_Char(strr):
    if not strr:
        return None
    total_ascii_value = sum((ord(char) for char in strr))
    result_value = total_ascii_value % 26
    return chr(result_value + ord('a')).
 Test: def check():
    assert get_Char("abc") == "f"
    assert get_Char("gfg") == "t"
    assert get_Char("ab") == "c"

2025-10-16 18:11:42 - Error: .
 Solution: def remove_kth_element(list1, k):
    if k < 0 or k >= len(list1):
        return list1
    return list1[:k] + list1[k + 1:].
 Test: def check():
    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]
    assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]
    assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]

2025-10-16 18:11:48 - Error: .
 Solution: def trim_tuple(test_list, K):
    trimmed_list = []
    for t in test_list:
        trimmed_list.append(t[-K:] if len(t) >= K else ())
    return trimmed_list.
 Test: def check():
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'
    assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'
    assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'

2025-10-16 18:12:05 - Error: .
 Solution: def colon_tuplex(tuplex, m, n):
    """
    Extracts the n-th column from a tuple of tuples.

    Parameters:
    tuplex (tuple of tuples): The input tuple containing tuples.
    m (int): The number of rows in the tuple.
    n (int): The index of the column to extract.

    Returns:
    tuple: A tuple containing the n-th column.
    """
    if not tuplex or n < 0:
        return tuple()
    column = []
    for row in tuplex:
        if isinstance(row, tuple) and n < len(row):
            column.append(row[n])
        else:
            column.append(None)
    return tuple(column).
 Test: def check():
    assert colon_tuplex(("HELLO", 5, [], True) ,2,50)==("HELLO", 5, [50], True)
    assert colon_tuplex(("HELLO", 5, [], True) ,2,100)==(("HELLO", 5, [100],True))
    assert colon_tuplex(("HELLO", 5, [], True) ,2,500)==("HELLO", 5, [500], True)

2025-10-16 18:12:14 - Error: .
 Solution: def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
def newman_shanks_williams_primes(n):
    nsw_primes = []
    candidate = 2
    while len(nsw_primes) < n:
        if is_prime(candidate):
            if candidate in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] or (candidate > 29 and (candidate - 1) % 6 == 0):
                nsw_primes.append(candidate)
        candidate += 1
    return nsw_primes[n - 1]
def newman_prime(n):
    return newman_shanks_williams_primes(n).
 Test: def check():
    assert newman_prime(3) == 7
    assert newman_prime(4) == 17
    assert newman_prime(5) == 41

2025-10-16 18:12:39 - Error: .
 Solution: def find_lists(input_tuple):
    count = 0
    for item in input_tuple:
        if isinstance(item, list):
            count += 1
    return count.
 Test: def check():
    assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2
    assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3
    assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1

2025-10-16 18:12:40 - Error: .
 Solution: import re
def text_match_one(text):
    pattern = 'a+b+'
    return bool(re.fullmatch(pattern, text)).
 Test: def check():
    assert text_match_one("ac")==False
    assert text_match_one("dc")==False
    assert text_match_one("abba")==True

2025-10-16 18:13:05 - Error: .
 Solution: import math
def triangle_area(r):
    if r <= 0:
        return None
    return r * r / 2.
 Test: def check():
    assert triangle_area(-1) == None
    assert triangle_area(0) == 0
    assert triangle_area(2) == 4

2025-10-16 18:13:06 - Error: .
 Solution: def sort_numeric_strings(nums_str):
    return sorted(nums_str, key=lambda x: int(x)).
 Test: def check():
    assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]
    assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]
    assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]

2025-10-16 18:13:20 - Error: .
 Solution: def rearrange_bigger(n):
    digits = list(str(n))
    length = len(digits)
    i = length - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    if i == -1:
        return -1
    j = length - 1
    while digits[j] <= digits[i]:
        j -= 1
    (digits[i], digits[j]) = (digits[j], digits[i])
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    return int(''.join(digits)).
 Test: def check():
    assert rearrange_bigger(12)==21
    assert rearrange_bigger(10)==False
    assert rearrange_bigger(102)==120

2025-10-16 18:13:31 - Error: count_first_elements() missing 1 required positional argument: 'element'.
 Solution: def count_first_elements(test_tup, element):
    """
    Count the number of elements that occur before the specified element in the tuple.

    Parameters:
    test_tup (tuple): The input tuple.
    element: The element to count occurrences before.

    Returns:
    int: The count of elements before the specified element, or -1 if the element is not found.
    """
    if element not in test_tup:
        return -1
    return test_tup.index(element).
 Test: def check():
    assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3
    assert count_first_elements((2, 9, (5, 7), 11) ) == 2
    assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4

2025-10-16 18:14:06 - Error: .
 Solution: from collections import Counter
def check_occurences(test_list):
    return dict(Counter(test_list)).
 Test: def check():
    assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}
    assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}
    assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}

2025-10-16 18:15:23 - Error: .
 Solution: def count_no_of_ways(n, k):
    if n == 0:
        return 1
    if n == 1:
        return k
    if n == 2:
        return k * k
    return (k - 1) * count_no_of_ways(n - 1, k) + k * count_no_of_ways(n - 2, k)
n = 5
k = 3.
 Test: def check():
    assert count_no_of_ways(2, 4) == 16
    assert count_no_of_ways(3, 2) == 6
    assert count_no_of_ways(4, 4) == 228

2025-10-16 18:15:25 - Error: .
 Solution: def loss_amount(actual_cost, sale_amount):
    if sale_amount < actual_cost:
        return actual_cost - sale_amount
    return 0.
 Test: def check():
    assert loss_amount(1500,1200)==0
    assert loss_amount(100,200)==100
    assert loss_amount(2000,5000)==3000

2025-10-16 18:15:35 - Error: .
 Solution: def all_Bits_Set_In_The_Given_Range(n, l, r):
    if l > r:
        return True
    mask = (1 << r + 1) - 1 ^ (1 << l) - 1
    masked_n = n & mask
    return masked_n == 0
n = 4
l = 1
r = 2.
 Test: def check():
    assert all_Bits_Set_In_The_Given_Range(4,1,2) == True
    assert all_Bits_Set_In_The_Given_Range(17,2,4) == True
    assert all_Bits_Set_In_The_Given_Range(39,4,6) == False

2025-10-16 18:15:38 - Error: .
 Solution: def comb_sort(nums):
    gap = len(nums)
    shrink = 1.3
    sorted = False
    while not sorted:
        gap = max(1, int(gap / shrink))
        sorted = True
        for i in range(len(nums) - gap):
            if nums[i] > nums[i + gap]:
                (nums[i], nums[i + gap]) = (nums[i + gap], nums[i])
                sorted = False
    return nums
nums = [5, 15, 37, 25, 79].
 Test: def check():
    assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]
    assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]
    assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]

2025-10-16 18:16:06 - Error: .
 Solution: def even_bit_set_number(n):
    mask = 2863311530
    return n | mask.
 Test: def check():
    assert even_bit_set_number(10) == 10
    assert even_bit_set_number(20) == 30
    assert even_bit_set_number(30) == 30

2025-10-16 18:16:09 - Error: .
 Solution: def count_vowels(test_str):
    vowels = set('aeiouAEIOU')
    count = 0
    n = len(test_str)
    for i in range(n):
        if i > 0 and test_str[i - 1] in vowels or (i < n - 1 and test_str[i + 1] in vowels):
            count += 1
    return count.
 Test: def check():
    assert count_vowels('bestinstareels') == 7
    assert count_vowels('partofthejourneyistheend') == 12
    assert count_vowels('amazonprime') == 5

2025-10-16 18:16:14 - Error: can't multiply sequence by non-int of type 'tuple'.
 Solution: def index_multiplication(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Tuples must be of the same length')
    return tuple((a * b for (a, b) in zip(test_tup1, test_tup2))).
 Test: def check():
    assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))
    assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))
    assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))

2025-10-16 18:16:17 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return word
    if '_' not in word:
        return word
    (first_segment, _, rest_of_string) = word.partition('_')
    camel_case_segment = first_segment.lower() + (rest_of_string[0].upper() if rest_of_string else '')
    return camel_case_segment + snake_to_camel(rest_of_string[1:]).
 Test: def check():
    assert snake_to_camel('android_tv') == 'AndroidTv'
    assert snake_to_camel('google_pixel') == 'GooglePixel'
    assert snake_to_camel('apple_watch') == 'AppleWatch'

2025-10-16 18:16:25 - Error: check_value() takes 1 positional argument but 2 were given.
 Solution: def check_value(d):
    if not d:
        return True
    first_value = next(iter(d.values()))
    return all((value == first_value for value in d.values())).
 Test: def check():
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True
    assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False

2025-10-16 18:16:26 - Error: .
 Solution: def and_tuples(test_tup1, test_tup2):
    if len(test_tup1) != len(test_tup2):
        raise ValueError('Tuples must be of the same length')
    elementwise_tuples = tuple((a - b for (a, b) in zip(test_tup1, test_tup2)))
    combined_tuples = (test_tup1, test_tup2)
    return (elementwise_tuples, combined_tuples).
 Test: def check():
    assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)
    assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)
    assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)

2025-10-16 18:16:33 - Error: Input must be a list of integers..
 Solution: def sum_of_digits(n):
    if n < 0:
        n = -n
    return sum((int(digit) for digit in str(n)))
def sum_of_digits_in_list(nums):
    return [sum_of_digits(num) for num in nums]
def sum_of_digits(nums):
    if not isinstance(nums, list) or not all((isinstance(num, int) for num in nums)):
        raise ValueError('Input must be a list of integers.')
    return sum_of_digits_in_list(nums).
 Test: def check():
    assert sum_of_digits([10,2,56])==14
    assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19
    assert sum_of_digits([10,20,-4,5,-70])==19

2025-10-16 18:16:46 - Error: .
 Solution: from functools import cmp_to_key
def compare(x, y):
    if x + y > y + x:
        return -1
    elif x + y < y + x:
        return 1
    else:
        return 0
def find_Max_Num(arr):
    if not arr:
        return '0'
    arr = list(map(str, arr))
    arr.sort(key=cmp_to_key(compare))
    largest_num = ''.join(arr)
    return largest_num if largest_num[0] != '0' else '0'.
 Test: def check():
    assert find_Max_Num([1,2,3]) == 321
    assert find_Max_Num([4,5,6,1]) == 6541
    assert find_Max_Num([1,2,3,9]) == 9321

2025-10-16 18:16:50 - Error: .
 Solution: def combinations_list(list1):

    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(list1)):
            backtrack(i + 1, path + [list1[i]])
    result = []
    backtrack(0, [])
    return result.
 Test: def check():
    assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]
    assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]
    assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]

2025-10-16 18:16:51 - Error: name 'deque' is not defined.
 Solution: def min_Jumps(steps, d):
    if d == 0:
        return 0
    if d < 0:
        d = -d
    queue = deque([(0, 0)])
    visited = set()
    visited.add(0)
    while queue:
        (position, jumps) = queue.popleft()
        for step in steps:
            new_position = position + step
            if new_position == d:
                return jumps + 1
            if new_position not in visited and new_position <= d:
                visited.add(new_position)
                queue.append((new_position, jumps + 1))
    return -1
steps = [1, 2, 3]
d = 5.
 Test: def check():
    assert min_Jumps((3,4),11)==3.5
    assert min_Jumps((3,4),0)==0
    assert min_Jumps((11,14),11)==1

2025-10-16 18:17:33 - Error: find_combinations() missing 1 required positional argument: 'target_sum'.
 Solution: from itertools import combinations
def find_combinations(tuples, target_sum):
    result = []

    def backtrack(start, current_combination, current_sum):
        if current_sum == target_sum:
            result.append(tuple(current_combination))
            return
        if current_sum > target_sum:
            return
        for i in range(start, len(tuples)):
            backtrack(i + 1, current_combination + [tuples[i]], current_sum + sum(tuples[i]))
    backtrack(0, [], 0)
    return result
tuples = [(1, 2), (2, 3), (4, 1), (3, 2)]
target_sum = 7.
 Test: def check():
    assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]
    assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]
    assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]

2025-10-16 19:32:14 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-16 19:32:14 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-16 19:32:14 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 19:32:15 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 19:32:15 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 19:32:15 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 19:32:15 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-16 19:32:15 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-16 19:32:15 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 19:32:15 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 19:32:16 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 19:32:16 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:32:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 19:32:16 - Error: .
 Solution: import math
def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 19:32:17 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 19:32:17 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-16 19:32:17 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 19:32:17 - Error: .
 Solution: def get_max_sum(n):
    if n < 12:
        return n
    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n).
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-16 19:32:17 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 19:32:17 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 19:32:17 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 19:32:18 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_mid = (mid + 1) % n
        prev_mid = (mid - 1 + n) % n
        if arr[mid] <= arr[next_mid] and arr[mid] <= arr[prev_mid]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 19:32:19 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-16 19:32:20 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = 2 * math.pi * r ** 2
    total_surface_area = lateral_area + base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 19:32:31 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 19:32:32 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:32:33 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 19:32:33 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-16 19:32:34 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 19:32:35 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 19:32:35 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
import math
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 19:32:36 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 19:32:36 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 19:32:36 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 19:32:37 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) if len(t) > 0 else 0 for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 19:32:38 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 19:32:38 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 19:32:39 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n == 1:
        return True
    if n % 2 == 0:
        return True
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
            if count > 2:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 19:32:41 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(i + 1):
            A[i][j] = (i - j) * A[i - 1][j] + (j + 1) * A[i - 1][j - 1]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 19:32:42 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 19:33:47 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 19:33:54 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 19:33:59 - Error: .
 Solution: def snake_to_camel(word):
    words = word.split('_')
    camel_case = ''.join((w.capitalize() for w in words))
    if camel_case:
        camel_case = camel_case[0].lower() + camel_case[1:]
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:34:03 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 19:34:11 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        dp[i][0] = 0
        dp[i][i] = 1
    for i in range(1, n + 1):
        for j in range(1, i):
            dp[i][j] = (j + 1) * dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]
    return dp[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-16 19:34:16 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    harmonic_sum_value = 0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 19:34:17 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h, round_result=True):
    """
    Calculate the surface area of a cylinder.
    
    Parameters:
    r (float): The radius of the cylinder (must be non-negative).
    h (float): The height of the cylinder (must be non-negative).
    round_result (bool): Whether to round the result to two decimal places.
    
    Returns:
    float: The surface area of the cylinder.
    
    Raises:
    ValueError: If radius or height is negative.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2) if round_result else surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 19:34:31 - Error: .
 Solution: def find_sum(arr):
    count_map = {}
    for num in arr:
        count_map[num] = count_map.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in count_map.items() if count == 1))
    return non_repeated_sum
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 19:35:38 - Error: Both a and b must be numeric values (int or float)..
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle in radians, in the range [-, ].
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise ValueError('Both a and b must be numeric values (int or float).')
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 19:36:42 - Error: .
 Solution: from typing import Tuple, List, Union
def average_tuple(nums: Tuple[Tuple[Union[int, float], ...], ...]) -> List[Union[float, None]]:
    """
    Calculate the average of each tuple in a tuple of tuples.

    Args:
        nums (Tuple[Tuple[Union[int, float], ...], ...]): A tuple containing tuples of numbers.

    Returns:
        List[Union[float, None]]: A list of averages for each tuple, or None for empty tuples.
    """
    return [sum(tup) / len(tup) if len(tup) > 0 else None for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 19:36:42 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1
n = 5.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 19:36:48 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or all((len(t) == 0 for t in list1)):
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][0] * list1[j][1])
            product3 = abs(list1[i][1] * list1[j][0])
            product4 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 19:37:33 - Error: .
 Solution: def count_rotation(arr):
    if not arr:
        return 0
    (left, right) = (0, len(arr) - 1)
    while left <= right:
        mid = (left + right) // 2
        if mid < right and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > left and arr[mid] < arr[mid - 1]:
            return mid
        if arr[left] <= arr[mid]:
            left = mid + 1
        else:
            right = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 19:37:56 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        return None
    if not arr:
        return None

    def partition(arr, low, high):
        pivot_value = arr[high]
        store_index = low
        for i in range(low, high):
            if arr[i] < pivot_value:
                (arr[store_index], arr[i]) = (arr[i], arr[store_index])
                store_index += 1
        (arr[store_index], arr[high]) = (arr[high], arr[store_index])
        return store_index

    def quickselect(arr, low, high, k):
        if low == high:
            return arr[low]
        pivot_index = partition(arr, low, high)
        if k - 1 == pivot_index:
            return arr[pivot_index]
        elif k - 1 < pivot_index:
            return quickselect(arr, low, pivot_index - 1, k)
        else:
            return quickselect(arr, pivot_index + 1, high, k)
    return quickselect(arr, 0, len(arr) - 1, k).
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 19:38:01 - Error: .
 Solution: def is_polite(n):
    while n > 0 and n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 19:39:35 - Error: .
 Solution: def remove_odd(str1, index=0):
    if index >= len(str1):
        return ''
    if index % 2 == 0:
        return str1[index] + remove_odd(str1, index + 1)
    else:
        return remove_odd(str1, index + 1).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 19:39:45 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    underscore_index = word.find('_')
    if underscore_index == -1:
        return word
    first_segment = word[:underscore_index]
    rest_of_string = word[underscore_index + 1:]
    return first_segment + rest_of_string.capitalize() if first_segment else rest_of_string.capitalize().
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:39:48 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    if len(nums) == 1:
        return nums[0]
    mid = len(nums) // 2
    left_half = nums[:mid]
    right_half = nums[mid:]
    left_max = max_occurrences(left_half)
    right_max = max_occurrences(right_half)
    count = defaultdict(int)
    for num in nums:
        count[num] += 1
    left_count = count[left_max]
    right_count = count[right_max]
    if left_count >= right_count:
        return left_max
    else:
        return right_max.
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-16 19:39:52 - Error: .
 Solution: def is_divisible_by_11(n):
    n = abs(n)
    if n == 0 or n == 11:
        return True
    elif n < 10:
        return False
    last_digit = n % 10
    remaining_number = n // 10
    if len(str(n)) % 2 == 0:
        return is_divisible_by_11(remaining_number - last_digit)
    else:
        return is_divisible_by_11(remaining_number + last_digit)
def is_Diff(n):
    return is_divisible_by_11(n).
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 19:40:08 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (phase) of a complex number represented by its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle of the complex number in radians.
           Returns None if the complex number is zero.
    """
    z = complex(a, b)
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 19:40:26 - Error: .
 Solution: def find_sum(arr):
    count = {}
    for num in arr:
        count[num] = count.get(num, 0) + 1
    return sum((num for num in count if count[num] == 1))
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 19:40:27 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^ab+$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 19:40:31 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    return n & n - 1 != 0
n = 7.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 19:40:32 - Error: .
 Solution: def average_tuple(nums):
    averages = []
    for tup in nums:
        if len(tup) == 0:
            averages.append(0)
        else:
            averages.append(sum(tup) / len(tup))
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 19:40:37 - Error: .
 Solution: def count_rotation(arr):

    def binary_search_rotations(start, end):
        if start > end:
            return 0
        if start == end:
            return start
        mid = (start + end) // 2
        if mid < end and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > start and arr[mid] < arr[mid - 1]:
            return mid
        if arr[start] <= arr[mid]:
            return binary_search_rotations(mid + 1, end)
        else:
            return binary_search_rotations(start, mid - 1)
    n = len(arr)
    if n == 0:
        return 0
    return binary_search_rotations(0, n - 1) % n
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 19:40:38 - Error: list index out of range.
 Solution: def count_occurrences(arr, start, end, x):
    if start > end:
        return 0
    if start == end:
        return 1 if arr[start] == x else 0
    mid = (start + end) // 2
    left_count = count_occurrences(arr, start, mid, x)
    right_count = count_occurrences(arr, mid + 1, end, x)
    return left_count + right_count
def is_majority(arr, n, x):
    if n == 0:
        return False
    count = count_occurrences(arr, 0, n - 1, x)
    return count > n // 2
arr = [1, 1, 1, 2, 2, 3, 3]
n = len(arr)
x = 1.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-16 19:40:51 - Error: .
 Solution: def Diff(li1, li2):
    set1 = set(li1)
    set2 = set(li2)
    difference = list(set1 - set2)
    return difference.
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 19:40:59 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 19:41:01 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.
    
    Parameters:
    r (float): The radius of the cylinder. Must be non-negative.
    h (float): The height of the cylinder. Must be non-negative.
    
    Returns:
    float: The surface area of the cylinder.
    
    Raises:
    ValueError: If r or h is negative.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 19:41:35 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or all((len(t) == 0 for t in list1)):
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][0] * list1[j][1])
            product3 = abs(list1[i][1] * list1[j][0])
            product4 = abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 19:41:36 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise ValueError('k is out of bounds')

    def quickselect(left, right, k):
        if left == right:
            return arr[left]
        pivot_index = partition(left, right)
        if k - 1 == pivot_index:
            return arr[pivot_index]
        elif k - 1 < pivot_index:
            return quickselect(left, pivot_index - 1, k)
        else:
            return quickselect(pivot_index + 1, right, k)

    def partition(left, right):
        pivot_value = arr[right]
        store_index = left
        for i in range(left, right):
            if arr[i] < pivot_value:
                (arr[store_index], arr[i]) = (arr[i], arr[store_index])
                store_index += 1
        (arr[store_index], arr[right]) = (arr[right], arr[store_index])
        return store_index
    return quickselect(0, len(arr) - 1, k)
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 19:43:07 - Error: Function find_Parity is not defined in the solution..
 Solution: def is_odd_parity(x):
    """
    Determine if the parity of a given integer is odd.

    Parameters:
    x (int): The integer to check.

    Returns:
    bool: True if x is odd, False if x is even.
    """
    return x & 1 == 1.
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-16 19:43:08 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-16 19:43:10 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-16 19:43:11 - Error: Function opposite_Signs is not defined in the solution..
 Solution: def opposite_signs(x: int, y: int) -> bool:
    """Check if two integers have opposite signs."""
    return (x < 0) != (y < 0).
 Test: def check():
    assert opposite_Signs(1,-2) == True
    assert opposite_Signs(3,2) == False
    assert opposite_Signs(-10,-10) == False
    assert opposite_Signs(-2,2) == True

2025-10-16 19:43:12 - Error: Function square_Sum is not defined in the solution..
 Solution: def square_sum(n):
    if n == 0:
        return 0
    return n * n * (2 * n * n - 1) // 3.
 Test: def check():
    assert square_Sum(2) == 10
    assert square_Sum(3) == 35
    assert square_Sum(4) == 84

2025-10-16 19:43:15 - Error: Function Split is not defined in the solution..
 Solution: def find_even_numbers_generator(numbers):
    """Yield even numbers from the given list of numbers."""
    for number in numbers:
        if number % 2 == 0:
            yield number
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = list(find_even_numbers_generator(numbers)).
 Test: def check():
    assert Split([1,2,3,4,5]) == [2,4]
    assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]
    assert Split ([8,12,15,19]) == [8,12]

2025-10-16 19:43:19 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        return None
    return sorted(arr)[k - 1]
arr = [12, 3, 5, 7, 19]
k = 2.
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-16 19:43:19 - Error: Function swap_List is not defined in the solution..
 Solution: def swap_list(new_list):
    if len(new_list) < 2:
        return new_list
    (new_list[0], new_list[-1]) = (new_list[-1], new_list[0])
    return new_list.
 Test: def check():
    assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]
    assert swap_List([1, 2, 3]) == [3, 2, 1]
    assert swap_List([4, 5, 6]) == [6, 5, 4]

2025-10-16 19:43:19 - Error: Function surfacearea_sphere is not defined in the solution..
 Solution: import math
def surface_area_sphere(radius):
    """Calculate the surface area of a sphere given its radius."""
    if radius < 0:
        raise ValueError('Radius cannot be negative.')
    return 4 * math.pi * radius ** 2.
 Test: def check():
    assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)
    assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)

2025-10-16 19:43:21 - Error: Function is_polite is not defined in the solution..
 Solution: def is_power_of_two(x):
    return x & x - 1 == 0
def nth_polite_number(n):
    count = 0
    current_number = 1
    while count < n:
        if not is_power_of_two(current_number):
            count += 1
        current_number += 1
    return current_number - 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-16 19:43:24 - Error: Function _sum is not defined in the solution..
 Solution: def array_sum(arr):
    if not arr:
        return 0
    total = 0
    for num in arr:
        total += num
    return total
arr = [1, 2, 3, 4, 5].
 Test: def check():
    assert _sum([1, 2, 3]) == 6
    assert _sum([15, 12, 13, 10]) == 50
    assert _sum([0, 1, 2]) == 3

2025-10-16 19:43:24 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0])
            max_product = max(max_product, product)
    return max_product
def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-16 19:43:26 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) for tup in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-16 19:43:32 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for char in str1 if ord(char) % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-16 19:43:35 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-16 19:43:43 - Error: Function find_Odd_Pair is not defined in the solution..
 Solution: def find_odd_pair_count(arr):
    count_even = 0
    count_odd = 0
    for number in arr:
        if number % 2 == 0:
            count_even += 1
        else:
            count_odd += 1
    return count_even * count_odd.
 Test: def check():
    assert find_Odd_Pair([5,4,7,2,1],5) == 6
    assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12
    assert find_Odd_Pair([1,2,3],3) == 2

2025-10-16 19:43:44 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: def max_abs_diff(arr):
    if len(arr) < 2:
        return 0
    max_value = min_value = arr[0]
    for num in arr[1:]:
        if num > max_value:
            max_value = num
        elif num < min_value:
            min_value = num
    return max_value - min_value
arr = [3, 1, 4, 1, 5, 9, 2, 6, 5].
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-16 19:43:45 - Error: Function text_match_zero_one is not defined in the solution..
 Solution: def text_match_a_b(text):
    n = len(text)
    if n < 2:
        return False
    found_a = False
    for i in range(n):
        if text[i] == 'a':
            found_a = True
        elif found_a and text[i] == 'b':
            return True
        elif found_a and text[i] != 'b':
            break
    return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-16 19:43:48 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    """
    Calculate the angle (in radians) of a complex number given its real and imaginary parts.
    
    Parameters:
    a (float): The real part of the complex number.
    b (float): The imaginary part of the complex number.
    
    Returns:
    float: The angle in radians.
    """
    z = complex(a, b)
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-16 19:43:52 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 != 2.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-16 19:43:53 - Error: .
 Solution: def remove_nested(test_tup):
    result = []
    for item in test_tup:
        if isinstance(item, tuple):
            result.extend(remove_nested(item))
        else:
            result.append(item)
    return tuple(result).
 Test: def check():
    assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)
    assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)
    assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)
    assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12)

2025-10-16 19:43:54 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:43:55 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder given its radius and height.
    
    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.
    
    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * h + 2 * math.pi * r ** 2
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-16 19:43:57 - Error: Function count_Substrings is not defined in the solution..
 Solution: def count_substrings(s):
    n = len(s)
    count = 0
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            if s[j].isdigit():
                current_sum += int(s[j])
                if current_sum == j - i + 1:
                    count += 1
            else:
                break
    return count
s = '123'.
 Test: def check():
    assert count_Substrings('112112') == 6
    assert count_Substrings('111') == 6
    assert count_Substrings('1101112') == 12

2025-10-16 19:43:57 - Error: Function is_Diff is not defined in the solution..
 Solution: def is_divisible_by_11(n: int) -> bool:
    num_str = str(abs(n))
    remainder = 0
    for digit in num_str:
        remainder = (remainder * 10 + int(digit)) % 11
    return remainder == 0.
 Test: def check():
    assert is_Diff (12345) == False
    assert is_Diff(1212112) == True
    assert is_Diff(1212) == False

2025-10-16 19:43:58 - Error: Function find_Volume is not defined in the solution..
 Solution: def find_volume(length: float, base: float, height: float) -> float:
    """
    Calculate the volume of a triangular prism.
    
    Parameters:
    length (float): The length of the prism.
    base (float): The base of the triangular face.
    height (float): The height of the triangular face.
    
    Returns:
    float: The volume of the triangular prism.
    """
    return 0.5 * base * height * length.
 Test: def check():
    assert find_Volume(10,8,6) == 240
    assert find_Volume(3,2,2) == 6
    assert find_Volume(1,2,1) == 1

2025-10-16 19:44:01 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    if arr[low] <= arr[high]:
        return 0
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-16 19:44:02 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    non_repeated_sum = sum((num for (num, cnt) in count.items() if cnt == 1))
    return non_repeated_sum
arr = [1, 2, 3, 1, 1, 4, 5, 6].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-16 19:44:02 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: def last_digit_factorial(n):
    if n == 0 or n == 1:
        return 1
    if n >= 5:
        return 0
    last_digit = 1
    for i in range(2, n + 1):
        last_digit = last_digit * i % 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-16 19:44:10 - Error: Function start_withp is not defined in the solution..
 Solution: def start_with_p(words):
    count = 0
    result = []
    for word in words:
        if word.lower().startswith('p'):
            result.append(word)
            count += 1
            if count == 2:
                break
    return tuple(result)
words_list = ['apple', 'banana', 'pear', 'peach', 'plum', 'grape'].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-16 19:46:12 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-16 19:46:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((str1[i] for i in range(len(str1)) if i % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:33:58 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:33:58 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set(test_list)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-21 10:33:58 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return total_surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:33:58 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:33:59 - Error: .
 Solution: import re
def start_withp(words):
    p_words = [word for word in words if word.lower().startswith('p')]
    return p_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-21 10:33:59 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-21 10:33:59 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:33:59 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    if n % 2 == 1:
        return True
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if i > 1 and n // i % 2 == 1:
                return True
            if n // i > 1 and i % 2 == 1:
                return True
    return False
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-21 10:33:59 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-21 10:33:59 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-21 10:33:59 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
    for i in range(1, n + 1):
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-21 10:34:00 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.search(pattern, text):
        return 'Match found'
    else:
        return 'No match'.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-21 10:34:00 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:34:00 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:34:00 - Error: .
 Solution: import cmath
def angle_complex(a, b):
    complex_number = complex(a, b)
    angle = cmath.phase(complex_number)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:34:00 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total += i
    return total.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-21 10:34:00 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-21 10:34:00 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1).
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-21 10:34:00 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            if product > max_product:
                max_product = product
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:34:00 - Error: .
 Solution: def long_words(n, words):
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-21 10:34:00 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:34:01 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:34:01 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:34:14 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:34:14 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:34:15 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:34:15 - Error: list index out of range.
 Solution: def is_majority(arr, n, x):
    if n == 0:
        return False
    count = 0
    for i in range(n):
        if arr[i] == x:
            count += 1
    return count > n // 2.
 Test: def check():
    assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
    assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False
    assert is_majority([1, 1, 1, 2, 2], 5, 1) == True
    assert is_majority([1, 1, 2, 2], 5, 1) == False

2025-10-21 10:34:15 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-21 10:34:16 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:34:17 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:34:18 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    return sum((key for (key, count) in element_count.items() if count == 1)) + sum((key for key in arr if key not in element_count or element_count[key] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:34:18 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:34:18 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:34:19 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums if len(t) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:34:20 - Error: .
 Solution: def is_polite(n):
    if n < 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n != 1
n = 10.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-21 10:34:21 - Error: .
 Solution: def get_max_sum(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n < 12:
        return n
    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)
    return memo[n].
 Test: def check():
    assert get_max_sum(60) == 106
    assert get_max_sum(10) == 12
    assert get_max_sum(2) == 2

2025-10-21 10:34:21 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:34:21 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):
    if not arr:
        return 0
    n = len(arr)
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:34:23 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                A[i][j] = 0
            elif j == i:
                A[i][j] = 0
            else:
                A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-21 10:34:47 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:34:47 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    segments = word.split('_')
    camel_case = ''.join((segment.capitalize() for segment in segments))
    return camel_case[0].lower() + camel_case[1:].
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:34:49 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([char for (index, char) in enumerate(str1) if index % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:34:49 - Error: .
 Solution: def last_Digit_Factorial(n):
    if n < 0:
        return None
    if n == 0 or n == 1:
        return 1
    last_digit = 1
    for i in range(2, n + 1):
        last_digit *= i
        while last_digit % 10 == 0:
            last_digit //= 10
        last_digit %= 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-21 10:34:49 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-21 10:34:50 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:34:50 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (2 * n - 1) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-21 10:34:51 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:34:51 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (r + h)
    return round(surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:34:52 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    result = []
    for num in range(startnum, endnum + 1):
        if is_divisible_by_digits(num):
            result.append(num)
    return result.
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-21 10:34:52 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:34:52 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) for tup in nums if len(tup) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:34:54 - Error: .
 Solution: def jacobsthal_num(n):
    if n < 0:
        return 'Invalid input'
    elif n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        jacobsthal = [0, 1]
        for i in range(2, n + 1):
            next_value = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
            jacobsthal.append(next_value)
        return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-21 10:34:55 - Error: .
 Solution: def max_product_tuple(list1):
    if not list1 or len(list1) < 2:
        return 0
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[j][0]) * abs(list1[i][1] * list1[j][1])
            max_product = max(max_product, product)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:34:57 - Error: .
 Solution: def eulerian_num(n, m):
    eulerian = [[0] * (m + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        eulerian[i][0] = (i - 1) * eulerian[i - 1][0]
        for j in range(1, min(i, m + 1)):
            eulerian[i][j] = (j + 1) * eulerian[i - 1][j] + (n - i) * eulerian[i - 1][j - 1]
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-21 10:34:58 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:34:59 - Error: .
 Solution: def find_sum(arr):
    element_count = {}
    for num in arr:
        element_count[num] = element_count.get(num, 0) + 1
    non_repeated_sum = sum((num for (num, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:35:34 - Error: .
 Solution: def find_sum(arr):
    frequency = {}
    for num in arr:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1
    total_sum = 0
    for (num, count) in frequency.items():
        if count == 1:
            total_sum += num
    return total_sum
arr = [1, 2, 3, 2, 4, 5, 5].
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:35:34 - Error: .
 Solution: def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    jacobsthal = [0] * (n + 1)
    jacobsthal[0] = 0
    jacobsthal[1] = 1
    for i in range(2, n + 1):
        jacobsthal[i] = jacobsthal[i - 2] + 2 * jacobsthal[i - 1]
    return jacobsthal[n].
 Test: def check():
    assert jacobsthal_num(5) == 11
    assert jacobsthal_num(2) == 1
    assert jacobsthal_num(4) == 5
    assert jacobsthal_num(13) == 2731

2025-10-21 10:35:35 - Error: .
 Solution: def tuple_to_dict(test_tup):
    return {test_tup[i]: test_tup[i + 1] for i in range(len(test_tup) - 1)}.
 Test: def check():
    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}
    assert tuple_to_dict((1, 2, 3, 4, 5, 6)) == {1: 2, 3: 4, 5: 6}
    assert tuple_to_dict((7, 8, 9, 10, 11, 12)) == {7: 8, 9: 10, 11: 12}

2025-10-21 10:35:35 - Error: .
 Solution: def snake_to_camel(word):
    parts = word.split('_')
    camel_case = parts[0] + ''.join((part.capitalize() for part in parts[1:]))
    return camel_case.
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:35:35 - Error: .
 Solution: def remove_odd(str1):
    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0]).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:35:36 - Error: .
 Solution: def round_and_sum(list1):
    rounded_numbers = [round(num) for num in list1]
    total_sum = sum(rounded_numbers)
    result = total_sum * len(list1)
    print(result).
 Test: def check():
    assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243
    assert round_and_sum([5,2,9,24.3,29])==345
    assert round_and_sum([25.0,56.7,89.2])==513

2025-10-21 10:35:36 - Error: .
 Solution: def max_Abs_Diff(arr):
    if len(arr) < 2:
        return 0
    min_so_far = arr[0]
    max_diff = float('-inf')
    for i in range(1, len(arr)):
        max_diff = max(max_diff, arr[i] - min_so_far)
        min_so_far = min(min_so_far, arr[i])
    return max_diff
arr = [3, 1, 4, 1, 5, 9, 2, 6].
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-21 10:35:36 - Error: Input tuple must have at least two elements..
 Solution: def multiply_elements(test_tup):
    if len(test_tup) < 2:
        raise ValueError('Input tuple must have at least two elements.')
    result = tuple((test_tup[i] * test_tup[i + 1] for i in range(len(test_tup) - 1)))
    return result
test_tup = (1, 2, 3, 4).
 Test: def check():
    assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)
    assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)
    assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)
    assert multiply_elements((12,)) == ()

2025-10-21 10:35:37 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a(b+)'
    return re.fullmatch(pattern, text) is not None.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-21 10:35:38 - Error: .
 Solution: import re
def start_withp(words):
    filtered_words = [word for word in words if re.match('^p', word, re.IGNORECASE)]
    return filtered_words[:2].
 Test: def check():
    assert start_withp(["Python PHP", "Java JavaScript", "c c++"])==('Python', 'PHP')
    assert start_withp(["Python Programming","Java Programming"])==('Python','Programming')
    assert start_withp(["Pqrst Pqr","qrstuv"])==('Pqrst','Pqr')

2025-10-21 10:35:38 - Error: .
 Solution: import heapq
def k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2 or k <= 0:
        return []
    min_heap = []
    for j in range(min(k, len(nums2))):
        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))
    result = []
    while k > 0 and min_heap:
        (sum_pair, i, j) = heapq.heappop(min_heap)
        result.append((nums1[i], nums2[j]))
        if i + 1 < len(nums1):
            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))
        k -= 1
    return result.
 Test: def check():
    assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]
    assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]
    assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]

2025-10-21 10:35:38 - Error: .
 Solution: def extract_freq(test_list):
    unique_tuples = set()
    for item in test_list:
        unique_tuples.add(item)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

2025-10-21 10:35:38 - Error: .
 Solution: def long_words(n, words):
    if not words:
        return []
    return [word for word in words if len(word) > n].
 Test: def check():
    assert long_words(3,"python is a programming language")==['python','programming','language']
    assert long_words(2,"writing a program")==['writing','program']
    assert long_words(5,"sorting list")==['sorting']

2025-10-21 10:35:38 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (float): The radius of the cylinder.
    h (float): The height of the cylinder.

    Returns:
    float: The surface area of the cylinder.
    """
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    surface_area = 2 * math.pi * r * (h + r)
    return surface_area.
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:35:39 - Error: .
 Solution: def average_tuple(nums):
    if not nums:
        return []
    averages = []
    for t in nums:
        if len(t) == 0:
            averages.append(0)
        else:
            avg = sum(t) / len(t)
            averages.append(avg)
    return averages.
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:35:43 - Error: .
 Solution: def find_Parity(x):
    return 'Odd' if x % 2 != 0 else 'Even'.
 Test: def check():
    assert find_Parity(12) == False
    assert find_Parity(7) == True
    assert find_Parity(10) == False

2025-10-21 10:35:44 - Error: .
 Solution: def kth_element(arr, k):
    if k < 1 or k > len(arr):
        raise ValueError('k is out of bounds')
    sorted_arr = sorted(arr)
    return sorted_arr[k - 1].
 Test: def check():
    assert kth_element([12,3,5,7,19], 2) == 3
    assert kth_element([17,24,8,23], 3) == 8
    assert kth_element([16,21,25,36,4], 4) == 36

2025-10-21 10:35:44 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return True.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:35:45 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 0:
        return 0
    harmonic_sum_value = 0.0
    for i in range(1, n):
        harmonic_sum_value += 1 / i
    return harmonic_sum_value.
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:35:46 - Error: .
 Solution: def sum_div(number):
    if number < 1:
        return 0
    total_sum = 0
    for i in range(1, number + 1):
        if number % i == 0:
            total_sum += i
    return total_sum.
 Test: def check():
    assert sum_div(8)==7
    assert sum_div(12)==16
    assert sum_div(7)==1

2025-10-21 10:35:47 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-21 10:35:48 - Error: .
 Solution: def extract_index_list(l1, l2, l3):

    def helper(i, j, k, memo):
        if i >= len(l1) or j >= len(l2) or k >= len(l3):
            return []
        if (i, j, k) in memo:
            return memo[i, j, k]
        if l1[i] == l2[j] == l3[k]:
            result = [l1[i]] + helper(i + 1, j + 1, k + 1, memo)
        elif l1[i] < l2[j] and l1[i] < l3[k]:
            result = helper(i + 1, j, k, memo)
        elif l2[j] < l1[i] and l2[j] < l3[k]:
            result = helper(i, j + 1, k, memo)
        else:
            result = helper(i, j, k + 1, memo)
        memo[i, j, k] = result
        return result
    return helper(0, 0, 0, {})
l1 = [1, 2, 3, 4]
l2 = [2, 3, 4, 5]
l3 = [3, 4, 5, 6].
 Test: def check():
    assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 7]
    assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 6, 5],[0, 1, 2, 3, 4, 6, 7])==[1, 6]
    assert extract_index_list([1, 1, 3, 4, 6, 5, 6],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 5]
    assert extract_index_list([1, 2, 3, 4, 6, 6, 6],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[]

2025-10-21 10:35:48 - Error: .
 Solution: def max_product_tuple(list1):
    if len(list1) < 2:
        return 0
    max_product = 0
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product1 = abs(list1[i][0] * list1[j][1])
            product2 = abs(list1[i][1] * list1[j][0])
            max_product = max(max_product, product1, product2)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:35:48 - Error: .
 Solution: def rgb_to_hsv(r, g, b):
    r /= 255.0
    g /= 255.0
    b /= 255.0
    max_c = max(r, g, b)
    min_c = min(r, g, b)
    delta = max_c - min_c
    if delta == 0:
        h = 0
    elif max_c == r:
        h = (60 * ((g - b) / delta) + 360) % 360
    elif max_c == g:
        h = (60 * ((b - r) / delta) + 120) % 360
    else:
        h = (60 * ((r - g) / delta) + 240) % 360
    s = 0 if max_c == 0 else delta / max_c
    v = max_c
    return (h, s, v).
 Test: def check():
    assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)
    assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)
    assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)

2025-10-21 10:35:49 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Get the angle (phase) of a complex number.
    
    Parameters:
    z (complex): A complex number.
    
    Returns:
    float: The angle of the complex number in radians.
    """
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:35:49 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    if n == 1:
        return 1
    star_numbers = [0] * (n + 1)
    star_numbers[1] = 1
    for i in range(2, n + 1):
        star_numbers[i] = star_numbers[i - 1] + 6 * (i - 1)
    return star_numbers[n].
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-21 10:35:49 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if arr[0] < arr[n - 1]:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        mid = (low + high) // 2
        if mid < n - 1 and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > 0 and arr[mid] < arr[mid - 1]:
            return mid
        if arr[mid] >= arr[low]:
            low = mid + 1
        else:
            high = mid - 1
    return 0
arr = [15, 18, 2, 3, 6, 12].
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:35:50 - Error: .
 Solution: def is_polite(n):
    return n & n - 1 != 0
n = 5.
 Test: def check():
    assert is_polite(7) == 11
    assert is_polite(4) == 7
    assert is_polite(9) == 13

2025-10-21 10:35:50 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq_item = None
    max_freq_count = 0
    for (item, count) in frequency.items():
        if count > max_freq_count:
            max_freq_count = count
            max_freq_item = item
    return (max_freq_item, max_freq_count).
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-21 10:35:50 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-21 10:35:51 - Error: median_trapezium() takes 2 positional arguments but 3 were given.
 Solution: def median_trapezium(base1, base2):
    """
    Calculate the median length of a trapezium given its two bases.
    
    Parameters:
    base1 (float): Length of the first base of the trapezium.
    base2 (float): Length of the second base of the trapezium.
    
    Returns:
    float: The median length of the trapezium.
    """
    return (base1 + base2) / 2.
 Test: def check():
    assert median_trapezium(15,25,35)==20
    assert median_trapezium(10,20,30)==15
    assert median_trapezium(6,9,4)==7.5

2025-10-21 10:35:51 - Error: .
 Solution: def Find_Max_Length(lst):
    if not lst:
        return 0
    n = len(lst)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if lst[i] > lst[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
lst = [10, 9, 2, 5, 3, 7, 101, 18].
 Test: def check():
    assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4
    assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3
    assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5

2025-10-21 10:36:23 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:36:24 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = '^a(b+)$'
    return bool(re.match(pattern, text)).
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-21 10:36:24 - Error: .
 Solution: def last_Digit_Factorial(n):
    if n < 0:
        return None
    if n == 0 or n == 1:
        return 1
    last_digit = 1
    for i in range(2, n + 1):
        last_digit *= i
        while last_digit % 10 == 0:
            last_digit //= 10
        last_digit %= 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-21 10:36:24 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:36:24 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.capitalize() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:36:24 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 2 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:36:25 - Error: .
 Solution: def Diff(li1, li2):
    return list(set(li1) - set(li2)).
 Test: def check():
    assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]
    assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]
    assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]

2025-10-21 10:36:26 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0.0
    return sum((1.0 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:36:27 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        return 0
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-21 10:36:27 - Error: must be real number, not tuple.
 Solution: import cmath
def angle_complex(a, b):
    complex_a = complex(a)
    complex_b = complex(b)
    angle_a = cmath.phase(complex_a)
    angle_b = cmath.phase(complex_b)
    return (angle_a, angle_b).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:36:27 - Error: .
 Solution: def average_tuple(nums):
    return [sum(t) / len(t) for t in nums].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:36:27 - Error: .
 Solution: def max_product_tuple(list1):
    max_product = float('-inf')
    for i in range(len(list1)):
        for j in range(i + 1, len(list1)):
            product = abs(list1[i][0] * list1[i][1] * list1[j][0] * list1[j][1])
            max_product = max(max_product, product)
    return max_product if max_product != float('-inf') else 0.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:36:28 - Error: .
 Solution: def divisible_by_digits(startnum, endnum):

    def is_divisible_by_digits(num):
        digits = [int(d) for d in str(num) if d != '0']
        return all((num % d == 0 for d in digits)) if digits else False
    return [num for num in range(startnum, endnum + 1) if is_divisible_by_digits(num)].
 Test: def check():
    assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
    assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]
    assert divisible_by_digits(20,25)==[22, 24]

2025-10-21 10:36:29 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    count = Counter(arr)
    return sum((num for (num, freq) in count.items() if freq == 1)) + sum((num for num in arr if num not in count or count[num] > 1)).
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:36:30 - Error: Both inputs must be lists..
 Solution: def similar_elements(test_tup1, test_tup2):
    if not isinstance(test_tup1, list) or not isinstance(test_tup2, list):
        raise ValueError('Both inputs must be lists.')
    set1 = set(test_tup1)
    set2 = set(test_tup2)
    common_elements = set1.intersection(set2)
    return sorted(list(common_elements)).
 Test: def check():
    assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))
    assert set(similar_elements((1, 2, 3, 4),(5, 4, 3, 7))) == set((3, 4))
    assert set(similar_elements((11, 12, 14, 13),(17, 15, 14, 13))) == set((13, 14))

2025-10-21 10:36:30 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:36:33 - Error: Function count_rotation is not defined in the solution..
 Solution: def count_rotations(arr):

    def binary_search(arr, low, high):
        if high < low:
            return 0
        if high == low:
            return low
        mid = (low + high) // 2
        if mid < high and arr[mid] > arr[mid + 1]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        if arr[low] >= arr[mid]:
            return binary_search(arr, low, mid - 1)
        return binary_search(arr, mid + 1, high)
    n = len(arr)
    if n == 0:
        return 0
    rotations = binary_search(arr, 0, n - 1)
    return rotations if rotations != n else 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:36:33 - Error: .
 Solution: def find_length(string):
    arr = [1 if char == '1' else -1 for char in string]
    max_diff = 0
    current_sum = 0
    sum_index_map = {0: -1}
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum in sum_index_map:
            max_diff = max(max_diff, i - sum_index_map[current_sum])
        else:
            sum_index_map[current_sum] = i
    return max_diff.
 Test: def check():
    assert find_length("11000010001") == 6
    assert find_length("10111") == 1
    assert find_length("11011101100101") == 2

2025-10-21 10:36:39 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    eulerian = [[0] * (n + 1) for _ in range(n + 1)]
    eulerian[0][0] = 1
    for i in range(1, n + 1):
        for j in range(0, i + 1):
            eulerian[i][j] = (i - 1) * (eulerian[i - 1][j] + eulerian[i - 1][j - 1]) if j < i else 0
    return eulerian[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-21 10:37:25 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:37:26 - Error: .
 Solution: import re
def text_match_zero_one(text):
    pattern = 'a+b+'
    if re.fullmatch(pattern, text):
        return True
    else:
        return False.
 Test: def check():
    assert text_match_zero_one("ac")==False
    assert text_match_zero_one("dc")==False
    assert text_match_zero_one("abbbba")==True
    assert text_match_zero_one("dsabbbba")==True
    assert text_match_zero_one("asbbbba")==False
    assert text_match_zero_one("abaaa")==True

2025-10-21 10:37:27 - Error: .
 Solution: def test_three_equal(x, y, z):
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:37:27 - Error: .
 Solution: def string_to_tuple(str1):
    return tuple(str1).
 Test: def check():
    assert string_to_tuple("python 3.0")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')
    assert string_to_tuple("item1")==('i', 't', 'e', 'm', '1')
    assert string_to_tuple("15.10")==('1', '5', '.', '1', '0')

2025-10-21 10:37:28 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    angle = cmath.phase(z)
    return angle.
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:37:28 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:37:29 - Error: .
 Solution: def snake_to_camel(word):
    components = word.split('_')
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:37:29 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:37:31 - Error: .
 Solution: def is_undulating(n):
    s = str(n)
    if len(s) < 2:
        return True
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            return False
    for i in range(2, len(s)):
        if s[i] == s[i - 2]:
            return False
    return True.
 Test: def check():
    assert is_undulating(1212121) == True
    assert is_undulating(1991) == False
    assert is_undulating(121) == True

2025-10-21 10:37:36 - Error: .
 Solution: import math
def surfacearea_cylinder(r, h):
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:37:38 - Error: .
 Solution: def average_tuple(nums):
    return [sum(tup) / len(tup) for tup in nums if len(tup) > 0].
 Test: def check():
    assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]
    assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]
    assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]

2025-10-21 10:37:39 - Error: .
 Solution: def find_sum(arr):
    from collections import Counter
    element_count = Counter(arr)
    non_repeated_sum = sum((key for (key, count) in element_count.items() if count == 1))
    return non_repeated_sum.
 Test: def check():
    assert find_sum([1,2,3,1,1,4,5,6]) == 21
    assert find_sum([1,10,9,4,2,10,10,45,4]) == 71
    assert find_sum([12,10,9,45,2,10,10,45,10]) == 78

2025-10-21 10:37:41 - Error: .
 Solution: def find_star_num(n):
    if n < 1:
        raise ValueError('n must be a positive integer.')
    return n * (6 * n - 6) // 2 + 1.
 Test: def check():
    assert find_star_num(3) == 37
    assert find_star_num(4) == 73
    assert find_star_num(5) == 121

2025-10-21 10:37:41 - Error: .
 Solution: def count_rotation(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return 0
    (low, high) = (0, n - 1)
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next_index = (mid + 1) % n
        prev_index = (mid - 1 + n) % n
        if arr[mid] <= arr[next_index] and arr[mid] <= arr[prev_index]:
            return mid
        if arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0.
 Test: def check():
    assert count_rotation([3,2,1]) == 1
    assert count_rotation([4,5,1,2,3]) == 2
    assert count_rotation([7,8,9,1,2,3]) == 3
    assert count_rotation([1,2,3]) == 0
    assert count_rotation([1,3,2]) == 2

2025-10-21 10:37:46 - Error: .
 Solution: def max_product_tuple(list1):
    n = len(list1)
    if n < 2:
        return 0
    max_product = 0
    for i in range(n):
        for j in range(i + 1, n):
            product1 = abs(list1[i][0] * list1[j][0])
            product2 = abs(list1[i][1] * list1[j][1])
            product3 = abs(list1[i][0] * list1[j][1])
            product4 = abs(list1[i][1] * list1[j][0])
            max_product = max(max_product, product1, product2, product3, product4)
    return max_product.
 Test: def check():
    assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36
    assert max_product_tuple([(10,20), (15,2), (5,10)] )==200
    assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484

2025-10-21 10:37:48 - Error: .
 Solution: def eulerian_num(n, m):
    if m < 0 or m > n:
        return 0
    if n == 0 and m == 0:
        return 1
    if n == 1 and m == 0:
        return 1
    if n == 1 and m == 1:
        return 0
    A = [[0] * (n + 1) for _ in range(n + 1)]
    A[0][0] = 1
    for i in range(1, n + 1):
        A[i][0] = 0
        A[i][i] = 0
        for j in range(1, i):
            A[i][j] = (i - j) * A[i - 1][j - 1] + (j + 1) * A[i - 1][j]
    return A[n][m].
 Test: def check():
    assert eulerian_num(3, 1) == 4
    assert eulerian_num(4, 1) == 11
    assert eulerian_num(5, 3) == 26

2025-10-21 10:38:52 - Error: Function max_Abs_Diff is not defined in the solution..
 Solution: def max_abs_diff(arr):
    if not arr or len(arr) == 1:
        return 0
    min_val = min(arr)
    max_val = max(arr)
    return max_val - min_val.
 Test: def check():
    assert max_Abs_Diff((2,1,5,3)) == 4
    assert max_Abs_Diff((9,3,2,5,1)) == 8
    assert max_Abs_Diff((3,2,1)) == 2

2025-10-21 10:38:53 - Error: Function last_Digit_Factorial is not defined in the solution..
 Solution: def last_digit_factorial(n):
    """
    Calculate the last digit of the factorial of a given non-negative integer n.

    Parameters:
    n (int): A non-negative integer for which to calculate the factorial's last digit.

    Returns:
    int: The last digit of n! (factorial of n).

    Raises:
    ValueError: If n is a negative integer.
    """
    if n < 0:
        raise ValueError('Input must be a non-negative integer.')
    if n == 0 or n == 1:
        return 1
    last_digit = 1
    for i in range(2, n + 1):
        last_digit = last_digit * i % 10
    return last_digit.
 Test: def check():
    assert last_Digit_Factorial(4) == 4
    assert last_Digit_Factorial(21) == 0
    assert last_Digit_Factorial(30) == 0

2025-10-21 10:38:54 - Error: .
 Solution: def test_three_equal(x, y, z):
    if not all((isinstance(i, int) for i in (x, y, z))):
        raise ValueError('All inputs must be integers.')
    count = 0
    if x == y:
        count += 1
    if y == z:
        count += 1
    if x == z:
        count += 1
    return count.
 Test: def check():
    assert test_three_equal(1,1,1) == 3
    assert test_three_equal(-1,-2,-3) == 0
    assert test_three_equal(1,2,2) == 2

2025-10-21 10:38:54 - Error: .
 Solution: def dif_Square(n):
    if n < 0:
        return False
    return n % 4 == 0 or n % 4 == 1 or n == 0.
 Test: def check():
    assert dif_Square(5) == True
    assert dif_Square(10) == False
    assert dif_Square(15) == True

2025-10-21 10:38:54 - Error: .
 Solution: def snake_to_camel(word):
    if not word:
        return ''
    components = word.split('_')
    components = [x for x in components if x]
    if not components:
        return ''
    return components[0] + ''.join((x.title() for x in components[1:])).
 Test: def check():
    assert snake_to_camel('python_program')=='PythonProgram'
    assert snake_to_camel('python_language')==('PythonLanguage')
    assert snake_to_camel('programming_language')==('ProgrammingLanguage')

2025-10-21 10:38:55 - Error: .
 Solution: def harmonic_sum(n):
    if n <= 1:
        return 0
    return sum((1 / i for i in range(1, n))).
 Test: def check():
    assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)
    assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)
    assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)

2025-10-21 10:38:56 - Error: .
 Solution: from collections import defaultdict
def max_occurrences(nums):
    if not nums:
        return None
    frequency = defaultdict(int)
    for num in nums:
        frequency[num] += 1
    max_freq = 0
    max_items = []
    for (item, freq) in frequency.items():
        if freq > max_freq:
            max_freq = freq
            max_items = [item]
        elif freq == max_freq:
            max_items.append(item)
    return max_items if len(max_items) > 1 else max_items[0].
 Test: def check():
    assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2
    assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8
    assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20

2025-10-21 10:38:58 - Error: angle_complex() takes 1 positional argument but 2 were given.
 Solution: import cmath
def angle_complex(z):
    """
    Calculate the angle (phase) of a complex number.

    Parameters:
    z (complex): A complex number.

    Returns:
    float: The angle in radians. Returns None if the complex number is zero.
    """
    if z == 0:
        return None
    return cmath.phase(z).
 Test: def check():
    assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)
    assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)
    assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)

2025-10-21 10:38:58 - Error: .
 Solution: def remove_odd(str1):
    return ''.join((char for (index, char) in enumerate(str1) if index % 2 == 0)).
 Test: def check():
    assert remove_odd("python")==("yhn")
    assert remove_odd("program")==("rga")
    assert remove_odd("language")==("agae")

2025-10-21 10:39:00 - Error: .
 Solution: import math
from typing import Union
def surfacearea_cylinder(r: Union[int, float], h: Union[int, float]) -> float:
    """
    Calculate the surface area of a cylinder.

    Parameters:
    r (Union[int, float]): The radius of the cylinder.
    h (Union[int, float]): The height of the cylinder.

    Returns:
    float: The total surface area of the cylinder.

    Raises:
    ValueError: If radius or height is negative or not a number.
    """
    if not isinstance(r, (int, float)) or not isinstance(h, (int, float)):
        raise ValueError('Both radius and height must be numeric values.')
    if r < 0 or h < 0:
        raise ValueError('Radius and height must be non-negative values.')
    lateral_area = 2 * math.pi * r * h
    base_area = math.pi * r ** 2
    total_surface_area = lateral_area + 2 * base_area
    return round(total_surface_area, 2).
 Test: def check():
    assert surfacearea_cylinder(10,5)==942.45
    assert surfacearea_cylinder(4,5)==226.18800000000002
    assert surfacearea_cylinder(4,10)==351.848

2025-10-21 10:39:01 - Error: .
 Solution: def extract_freq(test_list):
    """
    Extract the number of unique tuples from a given list.

    Parameters:
    test_list (list): A list containing items that can be converted to tuples.

    Returns:
    int: The number of unique tuples in the list.
    """
    unique_tuples = set()
    for item in test_list:
        if isinstance(item, tuple):
            unique_tuples.add(item)
    return len(unique_tuples).
 Test: def check():
    assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3
    assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4
    assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4

