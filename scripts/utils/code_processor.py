"""
Code processing utilities for workflow operations.

This module provides utilities for cleaning and processing code content
generated by LLMs, handling various formatting issues commonly encountered.
"""

import re
from typing import Dict, Any, Optional


class CodeProcessor:
    """Utilities for processing and cleaning code content."""
    
    @staticmethod
    def clean_code_content(content: str) -> str:
        """
        Clean code content by removing markdown code block markers and fixing formatting issues.
        
        This method handles:
        - Multiple levels of ``` markers (````python, ```python, ```)
        - Mixed code block markers
        - Preserves internal code formatting
        - Removes excessive whitespace
        
        Args:
            content: Raw code content that may contain markdown markers
            
        Returns:
            Cleaned code content
        """
        if not content:
            return content
        
        # Remove multiple levels of code block markers
        # Handle ````python (4 backticks), ```python (3 backticks), etc.
        content = re.sub(r'^`{3,}python\s*\n?', '', content, flags=re.MULTILINE)
        content = re.sub(r'^`{3,}\s*\n?', '', content, flags=re.MULTILINE)
        content = re.sub(r'\n?`{3,}\s*$', '', content, flags=re.MULTILINE)
        
        # Handle cases where there are ``` inside the code (like in the example)
        # Split by lines and process each line
        lines = content.split('\n')
        cleaned_lines = []
        in_nested_block = False
        
        for line in lines:
            # Check if this line is just ``` markers
            stripped_line = line.strip()
            if re.match(r'^`{3,}$', stripped_line):
                # This is a nested code block marker, skip it
                in_nested_block = not in_nested_block
                continue
            elif re.match(r'^`{3,}python\s*$', stripped_line):
                # This is a nested python code block marker, skip it
                in_nested_block = not in_nested_block
                continue
            else:
                cleaned_lines.append(line)
        
        content = '\n'.join(cleaned_lines)
        
        # Remove any leading/trailing whitespace but preserve internal formatting
        content = content.strip()
        
        return content
    
    @staticmethod
    def clean_prompt_content(content: str) -> str:
        """
        Clean prompt content, handling special cases for prompt files.
        
        Args:
            content: Raw prompt content
            
        Returns:
            Cleaned prompt content
        """
        if not content:
            return content
        
        # For prompts, we need to be more careful about preserving structure
        # but still remove outer markdown blocks
        
        # Remove outer code block markers but preserve inner structure
        content = re.sub(r'^```python\s*\n?', '', content, flags=re.MULTILINE)
        content = re.sub(r'^```\s*\n?', '', content, flags=re.MULTILINE)
        content = re.sub(r'\n?```\s*$', '', content, flags=re.MULTILINE)
        
        # Remove leading/trailing whitespace
        content = content.strip()
        
        return content
    
    @staticmethod
    def extract_fields_from_response(response: str, fields: list) -> Optional[Dict[str, str]]:
        """
        Extract fields from LLM response using regex patterns.
        
        Args:
            response: Raw response text from LLM
            fields: List of field names to extract
            
        Returns:
            Dictionary with extracted fields or None if extraction fails
        """
        try:
            result = {field: "" for field in fields}
            
            # Extract each field with regex
            for field in fields:
                pattern = rf"<{field}>(.*?)</{field}>"
                match = re.search(pattern, response, re.DOTALL)
                if match:
                    content = match.group(1).strip()
                    
                    # Apply appropriate cleaning based on field type
                    if field in ['graph', 'code']:
                        content = CodeProcessor.clean_code_content(content)
                    elif field in ['prompt']:
                        content = CodeProcessor.clean_prompt_content(content)
                    
                    result[field] = content
            
            # Verify we have at least some content
            if not any(result.values()):
                return None
            
            return result
            
        except Exception as e:
            return None
    
    @staticmethod
    def validate_code_syntax(code: str, language: str = "python") -> tuple[bool, str]:
        """
        Validate code syntax for basic errors.
        
        Args:
            code: Code to validate
            language: Programming language (currently only supports python)
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        if not code.strip():
            return False, "Empty code content"
        
        if language.lower() == "python":
            try:
                compile(code, '<string>', 'exec')
                return True, ""
            except SyntaxError as e:
                return False, f"Syntax error: {str(e)}"
            except Exception as e:
                return False, f"Compilation error: {str(e)}"
        
        return True, ""  # Default to valid for unknown languages


class WorkflowProcessor:
    """Utilities for processing workflow-specific content."""
    
    @staticmethod
    def extract_workflow_metadata(workflow_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract and standardize workflow metadata.
        
        Args:
            workflow_data: Raw workflow data
            
        Returns:
            Standardized metadata dictionary
        """
        return {
            "round": workflow_data.get("round", 0),
            "score": workflow_data.get("avg_score", workflow_data.get("score", 0.0)),
            "solved_problems": workflow_data.get("solved_problems", []),
            "creation_method": workflow_data.get("creation_method", "unknown"),
            "source_workflows": workflow_data.get("source_workflows", []),
            "metadata": workflow_data.get("metadata", {})
        }
    
    @staticmethod
    def format_workflow_for_prompt(workflow_data: Dict[str, Any], index: int = 1) -> str:
        """
        Format workflow data for inclusion in prompts.
        
        Args:
            workflow_data: Workflow data to format
            index: Index number for the workflow
            
        Returns:
            Formatted workflow string for prompts
        """
        metadata = WorkflowProcessor.extract_workflow_metadata(workflow_data)
        
        formatted = f"""
**Workflow {index}**:
- Round: {metadata['round']}
- Score: {metadata['score']:.3f}
- Problems Solved: {len(metadata['solved_problems'])}
- Creation Method: {metadata['creation_method']}

Graph Code:
```python
{workflow_data.get('graph', '')}
```

Prompt:
```
{workflow_data.get('prompt', '')}
```
"""
        return formatted.strip()
